<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: SHM 仕様書</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">共有メモリを用いた高速で扱いやすいプロセス間通信マネージャ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">SHM 仕様書 </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md102">目的</a></li>
<li class="level1"><a href="#autotoc_md103">概要</a><ul><li class="level2"><a href="#autotoc_md104">フレームワークのコンテクスト</a></li>
<li class="level2"><a href="#autotoc_md105">システム機能</a><ul><li class="level3"><a href="#autotoc_md106">メモリ管理処理の隠蔽</a></li>
<li class="level3"><a href="#autotoc_md107">ポインタレスコーディング</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md108">ユーザ特性</a><ul><li class="level3"><a href="#autotoc_md109">開発者</a></li>
<li class="level3"><a href="#autotoc_md110">設計者</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md111">定義・用語</a><ul><li class="level3"><a href="#autotoc_md112">ローカルメモリ</a></li>
<li class="level3"><a href="#autotoc_md113">共有メモリ</a></li>
<li class="level3"><a href="#autotoc_md114">標準レイアウト型</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md115">アーキテクチャ設計</a><ul><li class="level2"><a href="#autotoc_md116">システム全体構成</a></li>
<li class="level2"><a href="#autotoc_md117">レイヤ構成</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md118">詳細設計</a><ul><li class="level2"><a href="#autotoc_md119">クラス階層構造</a></li>
<li class="level2"><a href="#autotoc_md120">共有メモリレイアウト</a></li>
<li class="level2"><a href="#autotoc_md121">データフロー</a><ul><li class="level3"><a href="#autotoc_md122">Publish処理フロー</a></li>
<li class="level3"><a href="#autotoc_md123">Subscribe処理フロー</a></li>
<li class="level3"><a href="#autotoc_md124">waitFor処理フロー</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md125">通信プロトコル</a><ul><li class="level2"><a href="#autotoc_md126">リングバッファアルゴリズム</a><ul><li class="level3"><a href="#autotoc_md127">バッファ選択アルゴリズム</a></li>
<li class="level3"><a href="#autotoc_md128">データ読み取りアルゴリズム</a></li>
</ul>
</li>
<li class="level2"><a href="#autotoc_md129">同期機構</a><ul><li class="level3"><a href="#autotoc_md130">Mutex とCondition Variable</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md131">パフォーマンス特性</a><ul><li class="level2"><a href="#autotoc_md132">メモリ使用量</a></li>
<li class="level2"><a href="#autotoc_md133">レイテンシ特性</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md134">セキュリティ考慮事項</a><ul><li class="level2"><a href="#autotoc_md135">アクセス権限</a></li>
<li class="level2"><a href="#autotoc_md136">データ整合性</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md137">エラーハンドリング</a><ul><li class="level2"><a href="#autotoc_md138">エラー分類と対処</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md139">Python バインディング設計</a><ul><li class="level2"><a href="#autotoc_md140">Boost.Python ラッパー構造</a></li>
<li class="level2"><a href="#autotoc_md141">Python/C++ データ変換</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md142">拡張性考慮</a><ul><li class="level2"><a href="#autotoc_md143">新しいデータ型の追加</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md144">参照</a><ul><li class="level2"><a href="#autotoc_md145">man shm_overview</a></li>
<li class="level2"><a href="#autotoc_md146">関連技術仕様</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>[<a href="../md_manual_spec_en.html">English</a> | 日本語]</p>
<h1><a class="anchor" id="autotoc_md102"></a>
目的</h1>
<p>SHM (Shared-memory based Handy-communication Manager)の目的は，異なるプロセス間でできるだけ安全かつ高速な通信を行うことである．また、学生が使用しやすいように、考慮して設計したはずである．インストール方法などは，README.mdを参照すること．</p>
<h1><a class="anchor" id="autotoc_md103"></a>
概要</h1>
<h2><a class="anchor" id="autotoc_md104"></a>
フレームワークのコンテクスト</h2>
<p>宇都宮大学計測・ロボット工学研究室では，一般にプログラムで利用されるローカルメモリに加えて，プログラム間のデータのやり取りに利用できる共有メモリを使用する． 共有メモリはローカルメモリとは異なり，開発者が確保したメモリを開放する必要がない（不用意に開放すると他のプログラムにデータが渡せなくなる）ことやポインタを利用するために初学者に対する敷居が微妙に高いこと，設計者が新しいライブラリを作成する度にそれぞれのメモリに合わせて処理を作成する必要があることなど問題点があった． 本フレームワークは，共有メモリによるデータのやり取りを隠蔽し，初学者にもわかりやすいプロセス間通信を提供する．</p>
<h2><a class="anchor" id="autotoc_md105"></a>
システム機能</h2>
<h3><a class="anchor" id="autotoc_md106"></a>
メモリ管理処理の隠蔽</h3>
<p>共有メモリの領域確保やバッファへのアクセスをクラスに隠蔽することで、容易にプロセス間通信する機能を実現した。ただし、標準では標準レイアウト型のクラスのみをサポートする。その他のクラスについては都度特殊化したPublisher/Subscriberを定義することで対応できる．詳細はサンプルを参照のこと．</p>
<h3><a class="anchor" id="autotoc_md107"></a>
ポインタレスコーディング</h3>
<p>基本的に、ローカルメモリに確保した変数を出版者（Publisher）に渡したり、購読者（Subscriber）からのトピックを受け取るのみであり、従来のように共有メモリのポインタを意識してコーディングすることがなくなった．</p>
<h2><a class="anchor" id="autotoc_md108"></a>
ユーザ特性</h2>
<h3><a class="anchor" id="autotoc_md109"></a>
開発者</h3>
<p>開発者とは，本ライブラリなどの研究室内外のライブラリを利用して新しいプログラムを作成するものを指す．主に、学部４年生などのプログラミング初学者を対象としている．</p>
<h3><a class="anchor" id="autotoc_md110"></a>
設計者</h3>
<p>設計者とは，本ライブラリを利用して新しいライブラリを作成し，現状のノウハウを後輩に受け継ぐものを指す．主に，修士２年生を対象としている．</p>
<h2><a class="anchor" id="autotoc_md111"></a>
定義・用語</h2>
<h3><a class="anchor" id="autotoc_md112"></a>
ローカルメモリ</h3>
<p>ローカルメモリとは，１プロセス内でアクセスできる仮想記憶領域を指す．通常のプログラミング時に利用される記憶領域であり，利用後にちゃんと開放しないと将来的に大変な（プログラムがしばらく正常に動いていたのに，急に動かなくなる）ことになる領域である．</p>
<h3><a class="anchor" id="autotoc_md113"></a>
共有メモリ</h3>
<p>共有メモリとは，プロセス間で共通して利用可能な記憶領域を指す．特殊な手段によって確保される記憶領域であり，様々な実装方法があるが、今回はPOSIXのファイルマップドメモリを採用している．これは、共有メモリに格納するデータをファイルとして扱う方式であり，Linuxでは/dev/shmの直下に確保したメモリ領域が確認できる．</p>
<h3><a class="anchor" id="autotoc_md114"></a>
標準レイアウト型</h3>
<p>クラスまたは構造体にC言語にはない仮想関数のような特定のC++言語の機能が含まれておらず，すべてのメンバーに同じアクセス制御が含まれている場合、それは標準レイアウト型である．memcpyが可能で，Cプログラムで使用できるようにレイアウトが明確に定義されている．標準レイアウト型は，ユーザー定義された特殊なメンバー関数を持つことができる．さらに，標準レイアウト型には，次のような特性がある．</p><ul>
<li>仮想関数または仮想基底クラスがない</li>
<li>すべての非静的データ メンバーに同じアクセス制御が含まれている</li>
<li>クラス型のすべての非静的メンバーが標準レイアウトである</li>
<li>すべての基底クラスが標準レイアウトである</li>
<li>最初の非静的データ メンバーと同じ型の基底クラスがない</li>
<li>次のいずれかの条件を満たしている．<ul>
<li>最派生クラスに非静的データ メンバーがなく、非静的データ メンバーの基底クラスが 1 つしかない</li>
<li>非静的データ メンバーを含む基底クラスがない</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md115"></a>
アーキテクチャ設計</h1>
<h2><a class="anchor" id="autotoc_md116"></a>
システム全体構成</h2>
<p> 
<div class="mermaid">
graph TB
    subgraph "プロセス A"
        PA[アプリケーション A]
        PubA[Publisher A]
    end
    
    subgraph "プロセス B"
        PB[アプリケーション B]
        SubB[Subscriber B]
    end
    
    subgraph "プロセス C"
        PC[アプリケーション C]
        SubC[Subscriber C]
    end
    
    subgraph "共有メモリ領域"
        SM[共有メモリセグメント]
        RB[リングバッファ]
        Meta[メタデータ]
    end
    
    PA --> PubA
    PubA --> SM
    SM --> RB
    RB --> SubB
    RB --> SubC
    SubB --> PB
    SubC --> PC
    
    SM --> Meta
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md117"></a>
レイヤ構成</h2>
<p> 
<div class="mermaid">
graph TB
    subgraph "アプリケーション層"
        APP[ユーザアプリケーション]
    end
    
    subgraph "SHM API層"
        PUB[Publisher&lt;T&gt;]
        SUB[Subscriber&lt;T&gt;]
    end
    
    subgraph "共有メモリ管理層"
        SHM[SharedMemory]
        POSIX[SharedMemoryPosix]
        RB[RingBuffer]
    end
    
    subgraph "OS層"
        KERNEL[Linux Kernel]
        SHMFS[/dev/shm ファイルシステム]
    end
    
    APP --> PUB
    APP --> SUB
    PUB --> SHM
    SUB --> SHM
    SHM --> POSIX
    POSIX --> RB
    POSIX --> KERNEL
    KERNEL --> SHMFS
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md118"></a>
詳細設計</h1>
<h2><a class="anchor" id="autotoc_md119"></a>
クラス階層構造</h2>
<p> 
<div class="mermaid">
classDiagram
    class SharedMemory {
        <<abstract>>
        #int shm_fd
        #int shm_oflag
        #PERM shm_perm
        #size_t shm_size
        #unsigned char* shm_ptr
        +SharedMemory(int oflag, PERM perm)
        +getSize() size_t
        +getPtr() unsigned char*
        +connect(size_t size)* bool
        +disconnect()* int
        +isDisconnected()* bool
    }
    
    class SharedMemoryPosix {
        -string shm_name
        +SharedMemoryPosix(string name, int oflag, PERM perm)
        +connect(size_t size) bool
        +disconnect() int
        +isDisconnected() bool
    }
    
    class RingBuffer {
        -unsigned char* memory_ptr
        -pthread_mutex_t* mutex
        -pthread_cond_t* condition
        -size_t* element_size
        -size_t* buf_num
        -atomic~uint64_t~* timestamp_list
        -unsigned char* data_list
        -uint64_t timestamp_us
        -uint64_t data_expiry_time_us
        +RingBuffer(unsigned char* first_ptr, size_t size, int buffer_num)
        +getSize(size_t element_size, int buffer_num)$ size_t
        +getTimestamp_us() uint64_t
        +setTimestamp_us(uint64_t input_time_us, int buffer_num)
        +getNewestBufferNum() int
        +getOldestBufferNum() int
        +allocateBuffer(int buffer_num) bool
        +getElementSize() size_t
        +getDataList() unsigned char*
        +signal()
        +waitFor(uint64_t timeout_usec) bool
        +isUpdated() bool
        +setDataExpiryTime_us(uint64_t time_us)
    }
    
    class Publisher~T~ {
        -string shm_name
        -int shm_buf_num
        -PERM shm_perm
        -unique_ptr~SharedMemory~ shared_memory
        -unique_ptr~RingBuffer~ ring_buffer
        -size_t data_size
        +Publisher(string name, int buffer_num, PERM perm)
        +publish(const T& data)
    }
    
    class Subscriber~T~ {
        -string shm_name
        -unique_ptr~SharedMemory~ shared_memory
        -unique_ptr~RingBuffer~ ring_buffer
        -int current_reading_buffer
        -uint64_t data_expiry_time_us
        +Subscriber(string name)
        +subscribe(bool* state) T
        +waitFor(uint64_t timeout_usec) bool
        +setDataExpiryTime_us(uint64_t time_us)
    }
    
    SharedMemory <|-- SharedMemoryPosix
    Publisher~T~ *-- SharedMemory
    Publisher~T~ *-- RingBuffer
    Subscriber~T~ *-- SharedMemory
    Subscriber~T~ *-- RingBuffer
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md120"></a>
共有メモリレイアウト</h2>
<p> 
<div class="mermaid">
graph TB
    subgraph "共有メモリセグメント"
        subgraph "メタデータ領域"
            MUTEX[pthread_mutex_t]
            COND[pthread_cond_t]
            ESIZE[element_size]
            BUFNUM[buffer_num]
        end
        
        subgraph "タイムスタンプ領域"
            TS0[timestamp[0]]
            TS1[timestamp[1]]
            TS2[timestamp[2]]
            TSN[timestamp[n-1]]
        end
        
        subgraph "データ領域"
            DATA0[data_buffer[0]]
            DATA1[data_buffer[1]]
            DATA2[data_buffer[2]]
            DATAN[data_buffer[n-1]]
        end
    end
    
    MUTEX --> COND
    COND --> ESIZE
    ESIZE --> BUFNUM
    BUFNUM --> TS0
    TS0 --> TS1
    TS1 --> TS2
    TS2 --> TSN
    TSN --> DATA0
    DATA0 --> DATA1
    DATA1 --> DATA2
    DATA2 --> DATAN
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md121"></a>
データフロー</h2>
<h3><a class="anchor" id="autotoc_md122"></a>
Publish処理フロー</h3>
<p> 
<div class="mermaid">
sequenceDiagram
    participant App as アプリケーション
    participant Pub as Publisher
    participant RB as RingBuffer
    participant SM as SharedMemory
    
    App->>+Pub: publish(data)
    Pub->>+RB: getOldestBufferNum()
    RB-->>-Pub: buffer_index
    
    loop 最大10回リトライ
        Pub->>+RB: allocateBuffer(buffer_index)
        alt バッファ確保成功
            RB-->>-Pub: true
        else バッファ確保失敗
            RB-->>Pub: false
            Note over Pub: 1ms待機
            Pub->>RB: getOldestBufferNum()
            RB-->>Pub: 新しいbuffer_index
        end
    end
    
    Pub->>SM: データをバッファにコピー
    Pub->>RB: setTimestamp_us(current_time, buffer_index)
    Pub->>RB: signal()
    Note over RB: 待機中のSubscriberに通知
    Pub-->>-App: 処理完了
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h3><a class="anchor" id="autotoc_md123"></a>
Subscribe処理フロー</h3>
<p> 
<div class="mermaid">
sequenceDiagram
    participant App as アプリケーション
    participant Sub as Subscriber
    participant RB as RingBuffer
    participant SM as SharedMemory
    
    App->>+Sub: subscribe(&is_success)
    
    alt 共有メモリが切断されている場合
        Sub->>+SM: connect()
        SM-->>-Sub: 接続結果
        alt 接続失敗
            Sub-->>App: (default_value, false)
        end
        Sub->>RB: 新しいRingBufferインスタンス作成
    end
    
    Sub->>+RB: getNewestBufferNum()
    RB-->>-Sub: buffer_index
    
    alt 有効なバッファが見つからない
        Sub-->>App: (前回の値, false)
    else 有効なバッファが見つかった
        Sub->>SM: バッファからデータをコピー
        Sub-->>-App: (data, true)
    end
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h3><a class="anchor" id="autotoc_md124"></a>
waitFor処理フロー</h3>
<p> 
<div class="mermaid">
sequenceDiagram
    participant App as アプリケーション
    participant Sub as Subscriber
    participant RB as RingBuffer
    
    App->>+Sub: waitFor(timeout_usec)
    
    alt 共有メモリが切断されている場合
        Sub->>Sub: 再接続処理
        alt 再接続失敗
            Sub-->>App: false
        end
    end
    
    Sub->>+RB: waitFor(timeout_usec)
    Note over RB: pthread_cond_timedwait で待機
    
    alt タイムアウト前にシグナル受信
        RB-->>-Sub: true
        Sub-->>-App: true
    else タイムアウト
        RB-->>Sub: false
        Sub-->>App: false
    end
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md125"></a>
通信プロトコル</h1>
<h2><a class="anchor" id="autotoc_md126"></a>
リングバッファアルゴリズム</h2>
<h3><a class="anchor" id="autotoc_md127"></a>
バッファ選択アルゴリズム</h3>
<p> 
<div class="mermaid">
flowchart TD
    Start([開始]) --> GetOldest[最古のタイムスタンプを持つバッファを特定]
    GetOldest --> TryAlloc{バッファ確保を試行}
    TryAlloc -->|成功| WriteData[データ書き込み]
    TryAlloc -->|失敗| CheckRetry{リトライ回数 < 10?}
    CheckRetry -->|Yes| Wait[1ms待機]
    Wait --> GetOldest
    CheckRetry -->|No| Error[エラー: バッファ確保失敗]
    WriteData --> UpdateTime[タイムスタンプ更新]
    UpdateTime --> Signal[条件変数でシグナル送信]
    Signal --> End([終了])
    Error --> End
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h3><a class="anchor" id="autotoc_md128"></a>
データ読み取りアルゴリズム</h3>
<p> 
<div class="mermaid">
flowchart TD
    Start([開始]) --> CheckConn{共有メモリ接続済み?}
    CheckConn -->|No| Reconnect[再接続試行]
    Reconnect --> ConnSuccess{接続成功?}
    ConnSuccess -->|No| ReturnFail[失敗を返す]
    ConnSuccess -->|Yes| GetNewest
    CheckConn -->|Yes| GetNewest[最新のタイムスタンプを持つバッファを特定]
    GetNewest --> ValidBuffer{有効なバッファ?}
    ValidBuffer -->|No| ReturnOld[前回値と失敗フラグを返す]
    ValidBuffer -->|Yes| CheckExpiry{データが有効期限内?}
    CheckExpiry -->|No| ReturnOld
    CheckExpiry -->|Yes| ReadData[データ読み取り]
    ReadData --> ReturnSuccess[データと成功フラグを返す]
    ReturnFail --> End([終了])
    ReturnOld --> End
    ReturnSuccess --> End
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md129"></a>
同期機構</h2>
<h3><a class="anchor" id="autotoc_md130"></a>
Mutex とCondition Variable</h3>
<p> 
<div class="mermaid">
stateDiagram-v2
    [*] --> Unlocked : 初期状態
    
    state Publisher {
        Unlocked --> Locked : pthread_mutex_lock
        Locked --> Writing : バッファ確保成功
        Writing --> Unlocked : pthread_mutex_unlock + pthread_cond_signal
        Locked --> Unlocked : バッファ確保失敗 + pthread_mutex_unlock
    }
    
    state Subscriber {
        Unlocked --> Waiting : waitFor() 呼び出し
        Waiting --> Unlocked : タイムアウト
        Waiting --> Processing : シグナル受信
        Processing --> Unlocked : データ読み取り完了
    }
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md131"></a>
パフォーマンス特性</h1>
<h2><a class="anchor" id="autotoc_md132"></a>
メモリ使用量</h2>
<p>共有メモリセグメントのサイズは以下の式で計算される：</p>
<div class="fragment"><div class="line">total_size = metadata_size + timestamp_array_size + data_array_size</div>
<div class="line"> </div>
<div class="line">metadata_size = sizeof(pthread_mutex_t) + sizeof(pthread_cond_t) + </div>
<div class="line">                sizeof(size_t) + sizeof(size_t)</div>
<div class="line"> </div>
<div class="line">timestamp_array_size = sizeof(uint64_t) * buffer_num</div>
<div class="line"> </div>
<div class="line">data_array_size = element_size * buffer_num</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md133"></a>
レイテンシ特性</h2>
<p> 
<div class="mermaid">
graph LR
    subgraph "レイテンシ構成要素"
        A[アプリケーション処理] --> B[Publisher処理]
        B --> C[Mutex獲得]
        C --> D[メモリコピー]
        D --> E[タイムスタンプ更新]
        E --> F[Signal送信]
        F --> G[Subscriber処理]
        G --> H[アプリケーション処理]
    end
    
    subgraph "典型的な時間"
        T1[アプリ: ~1μs]
        T2[Pub: ~2μs]
        T3[Mutex: ~0.5μs]
        T4[Copy: ~0.1μs]
        T5[Time: ~0.1μs]
        T6[Signal: ~0.5μs]
        T7[Sub: ~2μs]
        T8[アプリ: ~1μs]
    end
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md134"></a>
セキュリティ考慮事項</h1>
<h2><a class="anchor" id="autotoc_md135"></a>
アクセス権限</h2>
<p> 
<div class="mermaid">
graph TB
    subgraph "POSIX権限モデル"
        Owner[所有者]
        Group[グループ]
        Others[その他]
    end
    
    subgraph "権限種別"
        Read[読み取り: S_IRUSR/S_IRGRP/S_IROTH]
        Write[書き込み: S_IWUSR/S_IWGRP/S_IWOTH]
    end
    
    subgraph "デフォルト設定"
        Default["DEFAULT_PERM = 0666<br/>(全ユーザ読み書き可能)"]
    end
    
    Owner --> Read
    Owner --> Write
    Group --> Read
    Group --> Write
    Others --> Read
    Others --> Write
    
    Default -.-> Owner
    Default -.-> Group
    Default -.-> Others
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md136"></a>
データ整合性</h2>
<p> 
<div class="mermaid">
sequenceDiagram
    participant P1 as Publisher 1
    participant P2 as Publisher 2
    participant Mutex as Mutex
    participant Buffer as SharedBuffer
    participant S as Subscriber
    
    Note over P1,S: 複数Publisherからの同時書き込み
    
    P1->>+Mutex: lock()
    P2->>Mutex: lock() (ブロック)
    Mutex-->>-P1: 獲得成功
    
    P1->>Buffer: データ書き込み
    P1->>Buffer: タイムスタンプ更新
    P1->>+Mutex: unlock() + signal()
    Mutex-->>-P2: 獲得成功
    
    P2->>Buffer: データ書き込み
    P2->>Buffer: タイムスタンプ更新
    P2->>Mutex: unlock() + signal()
    
    S->>Buffer: 最新データ読み取り
    Note over S: P2のデータを取得
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md137"></a>
エラーハンドリング</h1>
<h2><a class="anchor" id="autotoc_md138"></a>
エラー分類と対処</h2>
<p> 
<div class="mermaid">
flowchart TD
    Error([エラー発生]) --> CheckType{エラー種別}
    
    CheckType -->|初期化エラー| InitError[初期化エラー]
    CheckType -->|通信エラー| CommError[通信エラー]
    CheckType -->|メモリエラー| MemError[メモリエラー]
    CheckType -->|タイムアウト| TimeoutError[タイムアウトエラー]
    
    InitError --> InitActions[・名前の確認<br/>・権限の確認<br/>・POD型の確認]
    CommError --> CommActions[・共有メモリ再接続<br/>・Publisher側確認<br/>・プロセス生存確認]
    MemError --> MemActions[・メモリ不足確認<br/>・セグメント削除<br/>・システム再起動]
    TimeoutError --> TimeoutActions[・タイムアウト値調整<br/>・Publisher頻度確認<br/>・システム負荷確認]
    
    InitActions --> LogError[エラーログ出力]
    CommActions --> LogError
    MemActions --> LogError
    TimeoutActions --> LogError
    
    LogError --> Recovery{回復可能?}
    Recovery -->|Yes| Retry[リトライ処理]
    Recovery -->|No| Abort[処理中断]
    
    Retry --> Success{成功?}
    Success -->|Yes| End([正常終了])
    Success -->|No| Recovery
    Abort --> End
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md139"></a>
Python バインディング設計</h1>
<h2><a class="anchor" id="autotoc_md140"></a>
Boost.Python ラッパー構造</h2>
<p> 
<div class="mermaid">
classDiagram
    class PublisherBool {
        +PublisherBool(string name, bool arg, int buffer_num)
        +_publish(bool data)
    }
    
    class PublisherInt {
        +PublisherInt(string name, int arg, int buffer_num)
        +_publish(int data)
    }
    
    class PublisherFloat {
        +PublisherFloat(string name, float arg, int buffer_num)
        +_publish(float data)
    }
    
    class SubscriberBool {
        +SubscriberBool(string name, bool arg)
        +_subscribe() tuple~bool, bool~
    }
    
    class SubscriberInt {
        +SubscriberInt(string name, int arg)
        +_subscribe() tuple~int, bool~
    }
    
    class SubscriberFloat {
        +SubscriberFloat(string name, float arg)
        +_subscribe() tuple~float, bool~
    }
    
    class Publisher~T~ {
        <<C++ Template>>
    }
    
    class Subscriber~T~ {
        <<C++ Template>>
    }
    
    Publisher~T~ <|-- PublisherBool
    Publisher~T~ <|-- PublisherInt
    Publisher~T~ <|-- PublisherFloat
    Subscriber~T~ <|-- SubscriberBool
    Subscriber~T~ <|-- SubscriberInt
    Subscriber~T~ <|-- SubscriberFloat
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h2><a class="anchor" id="autotoc_md141"></a>
Python/C++ データ変換</h2>
<p> 
<div class="mermaid">
sequenceDiagram
    participant Py as Python App
    participant Boost as Boost.Python
    participant Wrapper as C++ Wrapper
    participant Core as SHM Core
    
    Note over Py,Core: Publish処理
    Py->>+Boost: pub.publish(data)
    Boost->>+Wrapper: _publish(converted_data)
    Note over Boost: Python型 → C++型変換
    Wrapper->>+Core: publish(data)
    Core-->>-Wrapper: void
    Wrapper-->>-Boost: void
    Boost-->>-Py: None
    
    Note over Py,Core: Subscribe処理
    Py->>+Boost: data, success = sub.subscribe()
    Boost->>+Wrapper: _subscribe()
    Wrapper->>+Core: subscribe(&is_success)
    Core-->>-Wrapper: result_data
    Wrapper-->>-Boost: make_tuple(result_data, is_success)
    Note over Boost: C++型 → Python型変換
    Boost-->>-Py: (data, success)
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md142"></a>
拡張性考慮</h1>
<h2><a class="anchor" id="autotoc_md143"></a>
新しいデータ型の追加</h2>
<p> 
<div class="mermaid">
flowchart TD
    Start([新しい型Tを追加]) --> CheckPOD{POD型?}
    CheckPOD -->|Yes| UseTemplate[既存テンプレートを使用]
    CheckPOD -->|No| Specialize[テンプレート特殊化]
    
    UseTemplate --> InstantiateC[C++でPublisher&lt;T&gt;,<br/>Subscriber&lt;T&gt;をインスタンス化]
    Specialize --> CustomImpl[カスタム実装<br/>・シリアライゼーション<br/>・デシリアライゼーション]
    
    CustomImpl --> InstantiateC
    InstantiateC --> PythonNeeded{Python対応必要?}
    
    PythonNeeded -->|Yes| CreateWrapper[Boost.Pythonラッパー作成<br/>・PublisherT<br/>・SubscriberT]
    PythonNeeded -->|No| TestC[C++テスト実装]
    
    CreateWrapper --> UpdateModule[BOOST_PYTHON_MODULEに追加]
    UpdateModule --> TestPy[Pythonテスト実装]
    TestPy --> TestC
    TestC --> Document[ドキュメント更新]
    Document --> End([完了])
</div>
<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>
</p>
<h1><a class="anchor" id="autotoc_md144"></a>
参照</h1>
<h2><a class="anchor" id="autotoc_md145"></a>
man shm_overview</h2>
<p>Posix共有メモリの概要が記載されているURLを以下に示す． <a href="https://linuxjm.osdn.jp/html/LDP_man-pages/man7/shm_overview.7.html">https://linuxjm.osdn.jp/html/LDP_man-pages/man7/shm_overview.7.html</a></p>
<h2><a class="anchor" id="autotoc_md146"></a>
関連技術仕様</h2>
<ul>
<li>POSIX.1-2001 共有メモリオブジェクト</li>
<li>POSIX.1-2001 pthread mutexとcondition variables</li>
<li>C++11 標準レイアウト型</li>
<li>Boost.Python 1.75+ </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 5 2025 13:54:48 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
