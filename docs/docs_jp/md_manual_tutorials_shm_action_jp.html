<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: ⚡ Action通信完全ガイド - 長時間非同期処理をマスターしよう</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">共有メモリを用いた高速で扱いやすいプロセス間通信マネージャ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">⚡ Action通信完全ガイド - 長時間非同期処理をマスターしよう </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../md_manual_tutorials_shm_action_en.html">English</a> | 日本語]</p>
<h1><a class="anchor" id="autotoc_md225"></a>
🎯 このガイドで学べること</h1>
<ul>
<li><b>Action通信の深い理解</b>: 非同期処理パターンの設計思想から実装詳細まで</li>
<li><b>長時間処理の管理</b>: 進捗監視、キャンセル機能、エラーハンドリング</li>
<li><b>高度なワークフロー設計</b>: 並列処理、タスクチェーン、状態管理</li>
<li><b>実践的な応用例</b>: ファイル処理、機械学習、大容量データ変換</li>
</ul>
<h1><a class="anchor" id="autotoc_md226"></a>
🧠 Action通信の深い理解</h1>
<h2><a class="anchor" id="autotoc_md227"></a>
🏗️ アーキテクチャ解説</h2>
<div class="fragment"><div class="line"><span class="comment">// Action通信の内部構造</span></div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                   共有メモリ空間                              │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              アクションキュー                        │    │</div>
<div class="line">│  │ [Goal 0][Goal 1][Goal 2]...[Goal N-1]             │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  実行位置                    追加位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              フィードバックキュー                    │    │</div>
<div class="line">│  │ [FB 0][FB 1][FB 2]...[FB N-1]                     │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  読取位置                    書込位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              結果キュー                             │    │</div>
<div class="line">│  │ [Result 0][Result 1]...[Result N-1]               │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  読取位置                    書込位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  アクション状態管理:                                         │</div>
<div class="line">│  - ゴールID (一意識別子)                                     │</div>
<div class="line">│  - 実行状態 (待機/実行中/完了/キャンセル/エラー)              │</div>
<div class="line">│  - 進捗情報 (完了率、残り時間、処理詳細)                      │</div>
<div class="line">│  - キャンセルフラグ (非同期キャンセル要求)                    │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Multiple Clients ← [shared memory] → Single Server</div>
<div class="line">      │                                        │</div>
<div class="line">   ゴール送信                             アクション実行エンジン</div>
<div class="line">   フィードバック受信                           │</div>
<div class="line">   結果受信                                 長時間処理</div>
<div class="line">   キャンセル要求                            進捗報告</div>
<div class="line">      │                                   結果生成</div>
<div class="line">   非同期監視</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md228"></a>
⚡ なぜ長時間処理に最適なのか？</h2>
<p><b>1. 非同期実行とフィードバック</b> </p><div class="fragment"><div class="line"><span class="comment">// アクションの基本パターン</span></div>
<div class="line">ActionClient&lt;GoalType, ResultType, FeedbackType&gt; client(<span class="stringliteral">&quot;action_server&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ゴール送信（非ブロッキング）</span></div>
<div class="line">uint64_t goal_id = client.sendGoal(goal_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 他の処理を継続...</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="comment">// フィードバック確認</span></div>
<div class="line">    FeedbackType feedback;</div>
<div class="line">    <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;進捗: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 完了確認</span></div>
<div class="line">    <span class="keywordflow">if</span> (client.isComplete(goal_id)) {</div>
<div class="line">        ResultType result = client.getResult(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 必要に応じてキャンセル</span></div>
<div class="line">    <span class="keywordflow">if</span> (user_cancel_request) {</div>
<div class="line">        client.cancelGoal(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. 状態管理と進捗監視</b> </p><div class="fragment"><div class="line"><span class="comment">// 内部的な状態管理</span></div>
<div class="line"><span class="keyword">enum class</span> ActionStatus {</div>
<div class="line">    PENDING,        <span class="comment">// 待機中</span></div>
<div class="line">    ACTIVE,         <span class="comment">// 実行中</span></div>
<div class="line">    PREEMPTED,      <span class="comment">// 中断された</span></div>
<div class="line">    SUCCEEDED,      <span class="comment">// 成功完了</span></div>
<div class="line">    ABORTED,        <span class="comment">// 異常終了</span></div>
<div class="line">    REJECTED,       <span class="comment">// 拒否された</span></div>
<div class="line">    RECALLED        <span class="comment">// 取り消された</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ActionState {</div>
<div class="line">    uint64_t goal_id;</div>
<div class="line">    ActionStatus status;</div>
<div class="line">    uint64_t start_time;</div>
<div class="line">    uint64_t last_feedback_time;</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint32_t estimated_duration_ms;</div>
<div class="line">    <span class="keywordtype">char</span> status_text[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 状態追跡システム</span></div>
<div class="line"><span class="keyword">class </span>ActionStateTracker {</div>
<div class="line">    std::unordered_map&lt;uint64_t, ActionState&gt; active_actions_;</div>
<div class="line">    std::mutex state_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> updateProgress(uint64_t goal_id, <span class="keywordtype">float</span> progress, <span class="keyword">const</span> std::string&amp; text) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(state_mutex_);</div>
<div class="line">        <span class="keyword">auto</span>&amp; state = active_actions_[goal_id];</div>
<div class="line">        state.progress_percent = progress;</div>
<div class="line">        state.last_feedback_time = getCurrentTimeUs();</div>
<div class="line">        strncpy(state.status_text, text.c_str(), 255);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 自動的な完了時間推定</span></div>
<div class="line">        <span class="keywordflow">if</span> (progress &gt; 0.0f) {</div>
<div class="line">            uint64_t elapsed = state.last_feedback_time - state.start_time;</div>
<div class="line">            state.estimated_duration_ms = (elapsed / progress) * (100.0f - progress) / 1000;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>3. 高度なワークフロー管理</b> </p><div class="fragment"><div class="line"><span class="comment">// 複数アクションの並列実行</span></div>
<div class="line"><span class="keyword">class </span>ParallelActionManager {</div>
<div class="line">    std::vector&lt;ActionClient&lt;GoalType, ResultType, FeedbackType&gt;&gt; clients_;</div>
<div class="line">    std::vector&lt;uint64_t&gt; active_goals_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> executeParallelActions(<span class="keyword">const</span> std::vector&lt;GoalType&gt;&amp; goals) {</div>
<div class="line">        active_goals_.clear();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// すべてのゴールを並列送信</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; goals.size(); ++i) {</div>
<div class="line">            uint64_t goal_id = clients_[i].sendGoal(goals[i]);</div>
<div class="line">            active_goals_.push_back(goal_id);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 完了監視</span></div>
<div class="line">        <span class="keywordflow">while</span> (!active_goals_.empty()) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = active_goals_.begin(); it != active_goals_.end();) {</div>
<div class="line">                <span class="keywordtype">size_t</span> client_index = it - active_goals_.begin();</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (clients_[client_index].isComplete(*it)) {</div>
<div class="line">                    <span class="keyword">auto</span> result = clients_[client_index].getResult(*it);</div>
<div class="line">                    processResult(result);</div>
<div class="line">                    it = active_goals_.erase(it);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// フィードバック処理</span></div>
<div class="line">                    FeedbackType feedback;</div>
<div class="line">                    <span class="keywordflow">if</span> (clients_[client_index].getFeedback(*it, feedback)) {</div>
<div class="line">                        updateProgressDisplay(client_index, feedback);</div>
<div class="line">                    }</div>
<div class="line">                    ++it;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md229"></a>
🚀 基本的な使い方</h1>
<h2><a class="anchor" id="autotoc_md230"></a>
1. 簡単なファイル処理アクション</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ファイル処理ゴール</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> output_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> operation[64];      <span class="comment">// &quot;compress&quot;, &quot;encrypt&quot;, &quot;convert&quot;</span></div>
<div class="line">    <span class="keywordtype">float</span> quality;           <span class="comment">// 品質設定 (0.0 - 1.0)</span></div>
<div class="line">    <span class="keywordtype">bool</span> preserve_metadata;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ファイル処理結果</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint64_t input_size;</div>
<div class="line">    uint64_t output_size;</div>
<div class="line">    uint32_t processing_time_ms;</div>
<div class="line">    <span class="keywordtype">float</span> compression_ratio;</div>
<div class="line">    <span class="keywordtype">char</span> error_message[256];</div>
<div class="line">    <span class="keywordtype">char</span> final_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ファイル処理フィードバック</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessFeedback {</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint64_t bytes_processed;</div>
<div class="line">    uint64_t bytes_remaining;</div>
<div class="line">    uint32_t estimated_time_remaining_ms;</div>
<div class="line">    <span class="keywordtype">char</span> current_stage[128];</div>
<div class="line">    <span class="keywordtype">float</span> current_speed_mbps;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ファイル処理サーバー</span></div>
<div class="line"><span class="keyword">class </span>FileProcessingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;FileProcessGoal, FileProcessResult, FileProcessFeedback&gt; server_;</div>
<div class="line">    std::thread processing_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingServer() : server_(<span class="stringliteral">&quot;file_processor&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        processing_thread_ = std::thread(&amp;FileProcessingServer::processLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理サーバーを開始しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (processing_thread_.joinable()) {</div>
<div class="line">            processing_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理サーバーを停止しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                FileProcessGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理開始: &quot;</span> &lt;&lt; goal.input_path </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; goal.output_path &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 非同期でファイル処理を実行</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal, start_time]() {</div>
<div class="line">                    processFile(goal_id, goal, start_time);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processFile(uint64_t goal_id, <span class="keyword">const</span> FileProcessGoal&amp; goal, </div>
<div class="line">                    std::chrono::high_resolution_clock::time_point start_time) {</div>
<div class="line">        FileProcessResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.input_size = 0;</div>
<div class="line">        result.output_size = 0;</div>
<div class="line">        result.compression_ratio = 1.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// 入力ファイルサイズ取得</span></div>
<div class="line">            std::ifstream input(goal.input_path, std::ios::binary | std::ios::ate);</div>
<div class="line">            <span class="keywordflow">if</span> (!input.is_open()) {</div>
<div class="line">                strncpy(result.error_message, <span class="stringliteral">&quot;入力ファイルを開けません&quot;</span>, 255);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            result.input_size = input.tellg();</div>
<div class="line">            input.seekg(0, std::ios::beg);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 出力ファイル準備</span></div>
<div class="line">            std::ofstream output(goal.output_path, std::ios::binary);</div>
<div class="line">            <span class="keywordflow">if</span> (!output.is_open()) {</div>
<div class="line">                strncpy(result.error_message, <span class="stringliteral">&quot;出力ファイルを作成できません&quot;</span>, 255);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ファイル処理実行</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> BUFFER_SIZE = 64 * 1024;  <span class="comment">// 64KB buffer</span></div>
<div class="line">            std::vector&lt;char&gt; buffer(BUFFER_SIZE);</div>
<div class="line">            uint64_t total_processed = 0;</div>
<div class="line">            </div>
<div class="line">            FileProcessFeedback feedback;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (input.read(buffer.data(), BUFFER_SIZE) || input.gcount() &gt; 0) {</div>
<div class="line">                <span class="comment">// キャンセル確認</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    result.success = <span class="keyword">false</span>;</div>
<div class="line">                    strncpy(result.error_message, <span class="stringliteral">&quot;処理がキャンセルされました&quot;</span>, 255);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    input.close();</div>
<div class="line">                    output.close();</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keywordtype">size_t</span> bytes_read = input.gcount();</div>
<div class="line">                total_processed += bytes_read;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// データ処理シミュレーション（実際の処理に置き換え）</span></div>
<div class="line">                processData(buffer.data(), bytes_read, goal.operation, goal.quality);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 処理データの書き込み</span></div>
<div class="line">                output.write(buffer.data(), bytes_read);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// フィードバック更新</span></div>
<div class="line">                feedback.progress_percent = (float)total_processed / result.input_size * 100.0f;</div>
<div class="line">                feedback.bytes_processed = total_processed;</div>
<div class="line">                feedback.bytes_remaining = result.input_size - total_processed;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    current_time - start_time);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (elapsed.count() &gt; 0 &amp;&amp; total_processed &gt; 0) {</div>
<div class="line">                    feedback.current_speed_mbps = (float)total_processed / elapsed.count() / 1024.0f;</div>
<div class="line">                    <span class="keywordflow">if</span> (feedback.progress_percent &gt; 0) {</div>
<div class="line">                        feedback.estimated_time_remaining_ms = </div>
<div class="line">                            elapsed.count() * (100.0f - feedback.progress_percent) / feedback.progress_percent;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                snprintf(feedback.current_stage, 127, <span class="stringliteral">&quot;%s処理中&quot;</span>, goal.operation);</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 処理速度調整（実際の処理負荷に応じて）</span></div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            input.close();</div>
<div class="line">            output.close();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 結果設定</span></div>
<div class="line">            std::ifstream output_check(goal.output_path, std::ios::binary | std::ios::ate);</div>
<div class="line">            result.output_size = output_check.tellg();</div>
<div class="line">            output_check.close();</div>
<div class="line">            </div>
<div class="line">            result.compression_ratio = (float)result.output_size / result.input_size;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.processing_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            strncpy(result.final_path, goal.output_path, 511);</div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">            </div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理完了: &quot;</span> &lt;&lt; result.processing_time_ms &lt;&lt; <span class="stringliteral">&quot;ms, &quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;圧縮率: &quot;</span> &lt;&lt; result.compression_ratio &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(result.error_message, e.what(), 255);</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processData(<span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size, <span class="keyword">const</span> <span class="keywordtype">char</span>* operation, <span class="keywordtype">float</span> quality) {</div>
<div class="line">        <span class="comment">// 実際のデータ処理アルゴリズム</span></div>
<div class="line">        <span class="comment">// この例では簡単な変換をシミュレート</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(operation, <span class="stringliteral">&quot;encrypt&quot;</span>) == 0) {</div>
<div class="line">            <span class="comment">// 簡単な暗号化シミュレーション</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; ++i) {</div>
<div class="line">                data[i] ^= 0x55;  <span class="comment">// XOR暗号化</span></div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(operation, <span class="stringliteral">&quot;compress&quot;</span>) == 0) {</div>
<div class="line">            <span class="comment">// 圧縮シミュレーション（実際にはzlib等を使用）</span></div>
<div class="line">            <span class="comment">// quality値に基づいて処理時間を調整</span></div>
<div class="line">            <span class="keyword">auto</span> delay = std::chrono::microseconds((<span class="keywordtype">int</span>)(100 * quality));</div>
<div class="line">            std::this_thread::sleep_for(delay);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ファイル処理クライアント</span></div>
<div class="line"><span class="keyword">class </span>FileProcessingClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionClient&lt;FileProcessGoal, FileProcessResult, FileProcessFeedback&gt; client_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingClient() : client_(<span class="stringliteral">&quot;file_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> processFile(<span class="keyword">const</span> std::string&amp; input_path, <span class="keyword">const</span> std::string&amp; output_path,</div>
<div class="line">                    <span class="keyword">const</span> std::string&amp; operation, <span class="keywordtype">float</span> quality = 0.8f) {</div>
<div class="line">        FileProcessGoal goal;</div>
<div class="line">        strncpy(goal.input_path, input_path.c_str(), 511);</div>
<div class="line">        strncpy(goal.output_path, output_path.c_str(), 511);</div>
<div class="line">        strncpy(goal.operation, operation.c_str(), 63);</div>
<div class="line">        goal.quality = quality;</div>
<div class="line">        goal.preserve_metadata = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理要求送信...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        uint64_t goal_id = client_.sendGoal(goal);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 進捗監視</span></div>
<div class="line">        <span class="keywordflow">while</span> (!client_.isComplete(goal_id)) {</div>
<div class="line">            FileProcessFeedback feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client_.getFeedback(goal_id, feedback)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;\r進捗: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) </div>
<div class="line">                          &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;% (&quot;</span></div>
<div class="line">                          &lt;&lt; feedback.current_stage &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">                          &lt;&lt; feedback.current_speed_mbps &lt;&lt; <span class="stringliteral">&quot; MB/s, &quot;</span></div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;残り: &quot;</span> &lt;&lt; feedback.estimated_time_remaining_ms / 1000 &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div>
<div class="line">                          &lt;&lt; std::flush;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(200));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 結果取得</span></div>
<div class="line">        <span class="keywordflow">if</span> (client_.getState(goal_id) == ActionStatus::SUCCEEDED) {</div>
<div class="line">            FileProcessResult result = client_.getResult(goal_id);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;処理完了!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  入力サイズ: &quot;</span> &lt;&lt; result.input_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  出力サイズ: &quot;</span> &lt;&lt; result.output_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  処理時間: &quot;</span> &lt;&lt; result.processing_time_ms &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  圧縮率: &quot;</span> &lt;&lt; result.compression_ratio &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            FileProcessResult result = client_.getResult(goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;処理失敗: &quot;</span> &lt;&lt; result.error_message &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> cancelProcessing(uint64_t goal_id) {</div>
<div class="line">        client_.cancelGoal(goal_id);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;処理キャンセル要求を送信しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用例</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// サーバー開始</span></div>
<div class="line">        FileProcessingServer server;</div>
<div class="line">        server.start();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアントテスト</span></div>
<div class="line">        FileProcessingClient client;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ファイル処理実行</span></div>
<div class="line">        <span class="keywordtype">bool</span> success = client.processFile(</div>
<div class="line">            <span class="stringliteral">&quot;/tmp/input.txt&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;/tmp/output.enc&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;encrypt&quot;</span>,</div>
<div class="line">            0.9f</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (success) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理が成功しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー停止</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">        server.stop();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ashm__action_8hpp_html"><div class="ttname"><a href="shm__action_8hpp.html">shm_action.hpp</a></div><div class="ttdoc">メモリの格納方法を規定するクラスの定義</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md231"></a>
2. 機械学習訓練アクション</h2>
<div class="fragment"><div class="line"><span class="comment">// 機械学習訓練のデータ構造</span></div>
<div class="line"><span class="keyword">struct </span>MLTrainingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> dataset_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> model_type[64];         <span class="comment">// &quot;neural_network&quot;, &quot;svm&quot;, &quot;random_forest&quot;</span></div>
<div class="line">    <span class="keywordtype">char</span> output_model_path[512];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ハイパーパラメータ</span></div>
<div class="line">    <span class="keywordtype">float</span> learning_rate;</div>
<div class="line">    <span class="keywordtype">int</span> epochs;</div>
<div class="line">    <span class="keywordtype">int</span> batch_size;</div>
<div class="line">    <span class="keywordtype">float</span> validation_split;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 設定フラグ</span></div>
<div class="line">    <span class="keywordtype">bool</span> use_gpu;</div>
<div class="line">    <span class="keywordtype">bool</span> early_stopping;</div>
<div class="line">    <span class="keywordtype">int</span> max_training_time_minutes;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">float</span> final_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> final_loss;</div>
<div class="line">    <span class="keywordtype">int</span> epochs_completed;</div>
<div class="line">    uint32_t training_time_ms;</div>
<div class="line">    uint64_t model_size_bytes;</div>
<div class="line">    <span class="keywordtype">char</span> model_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> error_details[512];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 詳細メトリクス</span></div>
<div class="line">    <span class="keywordtype">float</span> validation_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> validation_loss;</div>
<div class="line">    <span class="keywordtype">float</span> overfitting_score;</div>
<div class="line">    <span class="keywordtype">char</span> best_checkpoint_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingFeedback {</div>
<div class="line">    <span class="keywordtype">int</span> current_epoch;</div>
<div class="line">    <span class="keywordtype">int</span> total_epochs;</div>
<div class="line">    <span class="keywordtype">float</span> current_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> current_loss;</div>
<div class="line">    <span class="keywordtype">float</span> validation_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> validation_loss;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 進捗情報</span></div>
<div class="line">    <span class="keywordtype">float</span> epoch_progress_percent;</div>
<div class="line">    <span class="keywordtype">float</span> overall_progress_percent;</div>
<div class="line">    uint32_t epoch_time_ms;</div>
<div class="line">    uint32_t estimated_remaining_ms;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// リアルタイム統計</span></div>
<div class="line">    <span class="keywordtype">float</span> samples_per_second;</div>
<div class="line">    <span class="keywordtype">char</span> current_phase[64];      <span class="comment">// &quot;training&quot;, &quot;validation&quot;, &quot;checkpointing&quot;</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_improving;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 機械学習訓練サーバー</span></div>
<div class="line"><span class="keyword">class </span>MLTrainingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;MLTrainingGoal, MLTrainingResult, MLTrainingFeedback&gt; server_;</div>
<div class="line">    std::thread training_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MLTrainingServer() : server_(<span class="stringliteral">&quot;ml_trainer&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        training_thread_ = std::thread(&amp;MLTrainingServer::trainingLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;機械学習訓練サーバーを開始しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (training_thread_.joinable()) {</div>
<div class="line">            training_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;機械学習訓練サーバーを停止しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> trainingLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                MLTrainingGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;訓練開始: &quot;</span> &lt;&lt; goal.model_type </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, データセット: &quot;</span> &lt;&lt; goal.dataset_path &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 訓練を非同期で実行</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal]() {</div>
<div class="line">                    trainModel(goal_id, goal);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> trainModel(uint64_t goal_id, <span class="keyword">const</span> MLTrainingGoal&amp; goal) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        MLTrainingResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.epochs_completed = 0;</div>
<div class="line">        result.final_accuracy = 0.0f;</div>
<div class="line">        result.final_loss = std::numeric_limits&lt;float&gt;::max();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// データセット読み込み</span></div>
<div class="line">            <span class="keywordflow">if</span> (!loadDataset(goal.dataset_path)) {</div>
<div class="line">                strncpy(result.error_details, <span class="stringliteral">&quot;データセットの読み込みに失敗&quot;</span>, 511);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// モデル初期化</span></div>
<div class="line">            MLModel model = initializeModel(goal.model_type, goal);</div>
<div class="line">            </div>
<div class="line">            MLTrainingFeedback feedback;</div>
<div class="line">            <span class="keywordtype">float</span> best_accuracy = 0.0f;</div>
<div class="line">            <span class="keywordtype">int</span> epochs_without_improvement = 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// エポックループ</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> epoch = 0; epoch &lt; goal.epochs; ++epoch) {</div>
<div class="line">                <span class="comment">// キャンセル確認</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    strncpy(result.error_details, <span class="stringliteral">&quot;訓練がキャンセルされました&quot;</span>, 511);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> epoch_start = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 訓練フェーズ</span></div>
<div class="line">                feedback.current_epoch = epoch + 1;</div>
<div class="line">                feedback.total_epochs = goal.epochs;</div>
<div class="line">                strcpy(feedback.current_phase, <span class="stringliteral">&quot;training&quot;</span>);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordtype">float</span> epoch_loss = 0.0f;</div>
<div class="line">                <span class="keywordtype">float</span> epoch_accuracy = 0.0f;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// バッチ処理ループ</span></div>
<div class="line">                <span class="keywordtype">int</span> total_batches = getDatasetSize() / goal.batch_size;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> batch = 0; batch &lt; total_batches; ++batch) {</div>
<div class="line">                    <span class="comment">// バッチデータ取得</span></div>
<div class="line">                    <span class="keyword">auto</span> batch_data = getBatch(batch, goal.batch_size);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// フォワードパス</span></div>
<div class="line">                    <span class="keyword">auto</span> predictions = model.forward(batch_data.inputs);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 損失計算</span></div>
<div class="line">                    <span class="keywordtype">float</span> batch_loss = calculateLoss(predictions, batch_data.targets);</div>
<div class="line">                    epoch_loss += batch_loss;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// バックプロパゲーション</span></div>
<div class="line">                    model.backward(batch_loss, goal.learning_rate);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 精度計算</span></div>
<div class="line">                    <span class="keywordtype">float</span> batch_accuracy = calculateAccuracy(predictions, batch_data.targets);</div>
<div class="line">                    epoch_accuracy += batch_accuracy;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// バッチレベルフィードバック</span></div>
<div class="line">                    feedback.epoch_progress_percent = (float)(batch + 1) / total_batches * 100.0f;</div>
<div class="line">                    feedback.overall_progress_percent = </div>
<div class="line">                        ((float)epoch + feedback.epoch_progress_percent / 100.0f) / goal.epochs * 100.0f;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                    <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                        current_time - epoch_start);</div>
<div class="line">                    feedback.samples_per_second = (float)(batch + 1) * goal.batch_size / </div>
<div class="line">                                                 (elapsed.count() / 1000.0f);</div>
<div class="line">                    </div>
<div class="line">                    server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 適度な間隔でフィードバック送信（CPU負荷軽減）</span></div>
<div class="line">                    <span class="keywordflow">if</span> (batch % 10 == 0) {</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                epoch_loss /= total_batches;</div>
<div class="line">                epoch_accuracy /= total_batches;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 検証フェーズ</span></div>
<div class="line">                strcpy(feedback.current_phase, <span class="stringliteral">&quot;validation&quot;</span>);</div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> validation_result = validateModel(model, goal.validation_split);</div>
<div class="line">                </div>
<div class="line">                feedback.current_accuracy = epoch_accuracy;</div>
<div class="line">                feedback.current_loss = epoch_loss;</div>
<div class="line">                feedback.validation_accuracy = validation_result.accuracy;</div>
<div class="line">                feedback.validation_loss = validation_result.loss;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> epoch_end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                feedback.epoch_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    epoch_end - epoch_start).count();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 残り時間推定</span></div>
<div class="line">                <span class="keywordflow">if</span> (epoch &gt; 0) {</div>
<div class="line">                    feedback.estimated_remaining_ms = </div>
<div class="line">                        feedback.epoch_time_ms * (goal.epochs - epoch - 1);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 改善判定</span></div>
<div class="line">                feedback.is_improving = validation_result.accuracy &gt; best_accuracy;</div>
<div class="line">                <span class="keywordflow">if</span> (feedback.is_improving) {</div>
<div class="line">                    best_accuracy = validation_result.accuracy;</div>
<div class="line">                    epochs_without_improvement = 0;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ベストモデルを保存</span></div>
<div class="line">                    saveCheckpoint(model, goal.output_model_path, epoch);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    epochs_without_improvement++;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 早期停止チェック</span></div>
<div class="line">                <span class="keywordflow">if</span> (goal.early_stopping &amp;&amp; epochs_without_improvement &gt;= 10) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;早期停止: &quot;</span> &lt;&lt; epochs_without_improvement </div>
<div class="line">                              &lt;&lt; <span class="stringliteral">&quot; エポック改善なし&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                result.epochs_completed = epoch + 1;</div>
<div class="line">                result.final_accuracy = validation_result.accuracy;</div>
<div class="line">                result.final_loss = validation_result.loss;</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;エポック &quot;</span> &lt;&lt; (epoch + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; goal.epochs </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; - 損失: &quot;</span> &lt;&lt; epoch_loss &lt;&lt; <span class="stringliteral">&quot;, 精度: &quot;</span> &lt;&lt; epoch_accuracy</div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, 検証精度: &quot;</span> &lt;&lt; validation_result.accuracy &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 最終結果設定</span></div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.training_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 最終モデル保存</span></div>
<div class="line">            saveModel(model, goal.output_model_path);</div>
<div class="line">            result.model_size_bytes = getFileSize(goal.output_model_path);</div>
<div class="line">            strncpy(result.model_path, goal.output_model_path, 511);</div>
<div class="line">            </div>
<div class="line">            result.validation_accuracy = feedback.validation_accuracy;</div>
<div class="line">            result.validation_loss = feedback.validation_loss;</div>
<div class="line">            result.overfitting_score = calculateOverfittingScore(</div>
<div class="line">                feedback.current_accuracy, feedback.validation_accuracy);</div>
<div class="line">            </div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;訓練完了: &quot;</span> &lt;&lt; result.training_time_ms / 1000.0f &lt;&lt; <span class="stringliteral">&quot;秒, &quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;最終精度: &quot;</span> &lt;&lt; result.final_accuracy &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(result.error_details, e.what(), 511);</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;訓練エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 簡略化されたML関数群（実際の実装ではより高度な処理）</span></div>
<div class="line">    <span class="keywordtype">bool</span> loadDataset(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="comment">// データセット読み込みシミュレーション</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>MLModel {</div>
<div class="line">        <span class="keywordtype">void</span> forward(<span class="keyword">const</span> std::vector&lt;float&gt;&amp; inputs) { <span class="comment">/* ... */</span> }</div>
<div class="line">        <span class="keywordtype">void</span> backward(<span class="keywordtype">float</span> loss, <span class="keywordtype">float</span> learning_rate) { <span class="comment">/* ... */</span> }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    MLModel initializeModel(<span class="keyword">const</span> std::string&amp; type, <span class="keyword">const</span> MLTrainingGoal&amp; goal) {</div>
<div class="line">        <span class="keywordflow">return</span> MLModel{};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>ValidationResult {</div>
<div class="line">        <span class="keywordtype">float</span> accuracy;</div>
<div class="line">        <span class="keywordtype">float</span> loss;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    ValidationResult validateModel(<span class="keyword">const</span> MLModel&amp; model, <span class="keywordtype">float</span> validation_split) {</div>
<div class="line">        <span class="comment">// 検証処理シミュレーション</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ランダムな結果生成（実際の実装では真の検証）</span></div>
<div class="line">        ValidationResult result;</div>
<div class="line">        result.accuracy = 0.7f + (rand() % 300) / 1000.0f;  <span class="comment">// 0.7-1.0</span></div>
<div class="line">        result.loss = 1.0f - result.accuracy + (rand() % 100) / 1000.0f;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> saveCheckpoint(<span class="keyword">const</span> MLModel&amp; model, <span class="keyword">const</span> std::string&amp; path, <span class="keywordtype">int</span> epoch) {</div>
<div class="line">        <span class="comment">// チェックポイント保存</span></div>
<div class="line">        std::string checkpoint_path = path + <span class="stringliteral">&quot;_epoch_&quot;</span> + std::to_string(epoch);</div>
<div class="line">        <span class="comment">// 実際の保存処理...</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> saveModel(<span class="keyword">const</span> MLModel&amp; model, <span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="comment">// 最終モデル保存</span></div>
<div class="line">        <span class="comment">// 実際の保存処理...</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">size_t</span> getFileSize(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="keywordflow">return</span> 1024 * 1024;  <span class="comment">// 1MB（例）</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> calculateOverfittingScore(<span class="keywordtype">float</span> train_acc, <span class="keywordtype">float</span> val_acc) {</div>
<div class="line">        <span class="keywordflow">return</span> std::max(0.0f, train_acc - val_acc);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md232"></a>
🚀 実践的な使用例</h1>
<h2><a class="anchor" id="autotoc_md233"></a>
1. 大容量データ変換パイプライン</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;future&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// データ変換パイプラインのゴール</span></div>
<div class="line"><span class="keyword">struct </span>DataPipelineGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_directory[512];</div>
<div class="line">    <span class="keywordtype">char</span> output_directory[512];</div>
<div class="line">    <span class="keywordtype">char</span> pipeline_config[1024];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// パイプライン設定</span></div>
<div class="line">    <span class="keywordtype">int</span> max_parallel_jobs;</div>
<div class="line">    <span class="keywordtype">int</span> batch_size;</div>
<div class="line">    <span class="keywordtype">float</span> quality_threshold;</div>
<div class="line">    <span class="keywordtype">bool</span> skip_existing;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// フィルタリング設定</span></div>
<div class="line">    <span class="keywordtype">char</span> file_pattern[128];</div>
<div class="line">    uint64_t min_file_size;</div>
<div class="line">    uint64_t max_file_size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DataPipelineResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint32_t total_files;</div>
<div class="line">    uint32_t processed_files;</div>
<div class="line">    uint32_t failed_files;</div>
<div class="line">    uint32_t skipped_files;</div>
<div class="line">    </div>
<div class="line">    uint64_t total_input_size;</div>
<div class="line">    uint64_t total_output_size;</div>
<div class="line">    uint32_t total_processing_time_ms;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> average_processing_speed_mbps;</div>
<div class="line">    <span class="keywordtype">float</span> overall_compression_ratio;</div>
<div class="line">    <span class="keywordtype">char</span> summary_report[2048];</div>
<div class="line">    <span class="keywordtype">char</span> error_log_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DataPipelineFeedback {</div>
<div class="line">    uint32_t current_file_index;</div>
<div class="line">    uint32_t total_files;</div>
<div class="line">    <span class="keywordtype">char</span> current_file_name[256];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 全体進捗</span></div>
<div class="line">    <span class="keywordtype">float</span> overall_progress_percent;</div>
<div class="line">    uint32_t files_completed;</div>
<div class="line">    uint32_t files_failed;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 現在の処理</span></div>
<div class="line">    <span class="keywordtype">float</span> current_file_progress;</div>
<div class="line">    <span class="keywordtype">char</span> current_stage[128];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// パフォーマンス統計</span></div>
<div class="line">    <span class="keywordtype">float</span> current_speed_mbps;</div>
<div class="line">    uint32_t estimated_remaining_ms;</div>
<div class="line">    uint32_t active_workers;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 品質統計</span></div>
<div class="line">    <span class="keywordtype">float</span> average_quality_score;</div>
<div class="line">    uint32_t quality_failures;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 高度なデータ処理パイプライン</span></div>
<div class="line"><span class="keyword">class </span>DataPipelineServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;DataPipelineGoal, DataPipelineResult, DataPipelineFeedback&gt; server_;</div>
<div class="line">    std::thread pipeline_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataPipelineServer() : server_(<span class="stringliteral">&quot;data_pipeline&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        pipeline_thread_ = std::thread(&amp;DataPipelineServer::pipelineLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データパイプラインサーバーを開始しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (pipeline_thread_.joinable()) {</div>
<div class="line">            pipeline_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データパイプラインサーバーを停止しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> pipelineLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                DataPipelineGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;パイプライン開始: &quot;</span> &lt;&lt; goal.input_directory </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; goal.output_directory &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// パイプライン実行を非同期で開始</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal]() {</div>
<div class="line">                    executePipeline(goal_id, goal);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> executePipeline(uint64_t goal_id, <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        DataPipelineResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.total_files = 0;</div>
<div class="line">        result.processed_files = 0;</div>
<div class="line">        result.failed_files = 0;</div>
<div class="line">        result.skipped_files = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// ファイルリスト取得</span></div>
<div class="line">            std::vector&lt;std::string&gt; file_list = scanDirectory(goal.input_directory, goal);</div>
<div class="line">            result.total_files = file_list.size();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (file_list.empty()) {</div>
<div class="line">                strncpy(result.summary_report, <span class="stringliteral">&quot;処理対象ファイルが見つかりませんでした&quot;</span>, 2047);</div>
<div class="line">                server_.setSucceeded(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 並列処理の準備</span></div>
<div class="line">            std::vector&lt;std::thread&gt; workers;</div>
<div class="line">            std::queue&lt;std::string&gt; file_queue;</div>
<div class="line">            std::mutex queue_mutex;</div>
<div class="line">            std::atomic&lt;uint32_t&gt; completed_files{0};</div>
<div class="line">            std::atomic&lt;uint32_t&gt; failed_files{0};</div>
<div class="line">            std::atomic&lt;uint64_t&gt; total_input_bytes{0};</div>
<div class="line">            std::atomic&lt;uint64_t&gt; total_output_bytes{0};</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ファイルキューに追加</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : file_list) {</div>
<div class="line">                file_queue.push(file);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            DataPipelineFeedback feedback;</div>
<div class="line">            feedback.total_files = result.total_files;</div>
<div class="line">            feedback.active_workers = std::min((uint32_t)goal.max_parallel_jobs, result.total_files);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ワーカースレッド開始</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; goal.max_parallel_jobs &amp;&amp; !file_queue.empty(); ++i) {</div>
<div class="line">                workers.emplace_back([&amp;, i]() {</div>
<div class="line">                    workerFunction(goal_id, goal, file_queue, queue_mutex, </div>
<div class="line">                                 completed_files, failed_files, </div>
<div class="line">                                 total_input_bytes, total_output_bytes, feedback);</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 進捗監視</span></div>
<div class="line">            <span class="keywordflow">while</span> (completed_files + failed_files &lt; result.total_files) {</div>
<div class="line">                <span class="comment">// キャンセル確認</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    <span class="comment">// すべてのワーカーに停止シグナル送信</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers) {</div>
<div class="line">                        <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                            worker.join();</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    result.processed_files = completed_files;</div>
<div class="line">                    result.failed_files = failed_files;</div>
<div class="line">                    strncpy(result.summary_report, <span class="stringliteral">&quot;処理がキャンセルされました&quot;</span>, 2047);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// フィードバック更新</span></div>
<div class="line">                feedback.files_completed = completed_files;</div>
<div class="line">                feedback.files_failed = failed_files;</div>
<div class="line">                feedback.overall_progress_percent = </div>
<div class="line">                    (float)(completed_files + failed_files) / result.total_files * 100.0f;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    current_time - start_time);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (elapsed.count() &gt; 0 &amp;&amp; completed_files &gt; 0) {</div>
<div class="line">                    feedback.current_speed_mbps = </div>
<div class="line">                        (float)total_input_bytes / elapsed.count() / 1024.0f;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (feedback.overall_progress_percent &gt; 0) {</div>
<div class="line">                        feedback.estimated_remaining_ms = </div>
<div class="line">                            elapsed.count() * (100.0f - feedback.overall_progress_percent) / </div>
<div class="line">                            feedback.overall_progress_percent;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ワーカー終了待ち</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers) {</div>
<div class="line">                <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                    worker.join();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 最終結果設定</span></div>
<div class="line">            result.processed_files = completed_files;</div>
<div class="line">            result.failed_files = failed_files;</div>
<div class="line">            result.total_input_size = total_input_bytes;</div>
<div class="line">            result.total_output_size = total_output_bytes;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.total_processing_time_ms = </div>
<div class="line">                std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result.total_processing_time_ms &gt; 0) {</div>
<div class="line">                result.average_processing_speed_mbps = </div>
<div class="line">                    (float)result.total_input_size / result.total_processing_time_ms / 1024.0f;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result.total_input_size &gt; 0) {</div>
<div class="line">                result.overall_compression_ratio = </div>
<div class="line">                    (float)result.total_output_size / result.total_input_size;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// サマリーレポート生成</span></div>
<div class="line">            generateSummaryReport(result, goal);</div>
<div class="line">            </div>
<div class="line">            result.success = (result.failed_files == 0);</div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;パイプライン完了: &quot;</span> &lt;&lt; result.processed_files &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> </div>
<div class="line">                      &lt;&lt; result.total_files &lt;&lt; <span class="stringliteral">&quot; ファイル処理&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            snprintf(result.summary_report, 2047, <span class="stringliteral">&quot;パイプラインエラー: %s&quot;</span>, e.what());</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;パイプラインエラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> workerFunction(uint64_t goal_id, <span class="keyword">const</span> DataPipelineGoal&amp; goal,</div>
<div class="line">                       std::queue&lt;std::string&gt;&amp; file_queue, std::mutex&amp; queue_mutex,</div>
<div class="line">                       std::atomic&lt;uint32_t&gt;&amp; completed_files, std::atomic&lt;uint32_t&gt;&amp; failed_files,</div>
<div class="line">                       std::atomic&lt;uint64_t&gt;&amp; total_input_bytes, std::atomic&lt;uint64_t&gt;&amp; total_output_bytes,</div>
<div class="line">                       DataPipelineFeedback&amp; feedback) {</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            std::string current_file;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ファイル取得</span></div>
<div class="line">            {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(queue_mutex);</div>
<div class="line">                <span class="keywordflow">if</span> (file_queue.empty()) {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                current_file = file_queue.front();</div>
<div class="line">                file_queue.pop();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <span class="comment">// ファイル処理実行</span></div>
<div class="line">                <span class="keyword">auto</span> process_result = processFile(current_file, goal);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (process_result.success) {</div>
<div class="line">                    completed_files++;</div>
<div class="line">                    total_input_bytes += process_result.input_size;</div>
<div class="line">                    total_output_bytes += process_result.output_size;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    failed_files++;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 個別ファイルのフィードバック更新</span></div>
<div class="line">                {</div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(queue_mutex);</div>
<div class="line">                    strncpy(feedback.current_file_name, </div>
<div class="line">                           extractFileName(current_file).c_str(), 255);</div>
<div class="line">                    feedback.current_file_index = completed_files + failed_files;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                failed_files++;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ファイル処理エラー (&quot;</span> &lt;&lt; current_file &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> </div>
<div class="line">                          &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>FileProcessResult {</div>
<div class="line">        <span class="keywordtype">bool</span> success;</div>
<div class="line">        uint64_t input_size;</div>
<div class="line">        uint64_t output_size;</div>
<div class="line">        uint32_t processing_time_ms;</div>
<div class="line">        <span class="keywordtype">float</span> quality_score;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    FileProcessResult processFile(<span class="keyword">const</span> std::string&amp; file_path, </div>
<div class="line">                                 <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        FileProcessResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.input_size = 0;</div>
<div class="line">        result.output_size = 0;</div>
<div class="line">        result.quality_score = 0.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ファイルサイズ取得</span></div>
<div class="line">        result.input_size = getFileSize(file_path);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 実際のファイル処理（例：画像変換、データ圧縮等）</span></div>
<div class="line">        std::string output_path = generateOutputPath(file_path, goal.output_directory);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 処理シミュレーション</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50 + rand() % 200));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 品質チェック</span></div>
<div class="line">        result.quality_score = 0.8f + (rand() % 200) / 1000.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (result.quality_score &gt;= goal.quality_threshold) {</div>
<div class="line">            result.output_size = result.input_size * 0.7f;  <span class="comment">// 圧縮例</span></div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        result.processing_time_ms = </div>
<div class="line">            std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;std::string&gt; scanDirectory(<span class="keyword">const</span> std::string&amp; directory, </div>
<div class="line">                                          <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        <span class="comment">// ディレクトリスキャン実装</span></div>
<div class="line">        std::vector&lt;std::string&gt; files;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 例：100ファイルを生成</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {</div>
<div class="line">            files.push_back(directory + <span class="stringliteral">&quot;/file_&quot;</span> + std::to_string(i) + <span class="stringliteral">&quot;.dat&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> files;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> generateSummaryReport(DataPipelineResult&amp; result, <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        snprintf(result.summary_report, 2047,</div>
<div class="line">                <span class="stringliteral">&quot;パイプライン処理完了\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;総ファイル数: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;成功: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;失敗: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;スキップ: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;処理時間: %.2f秒\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;平均速度: %.2f MB/s\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;圧縮率: %.2f\n&quot;</span>,</div>
<div class="line">                result.total_files,</div>
<div class="line">                result.processed_files,</div>
<div class="line">                result.failed_files,</div>
<div class="line">                result.skipped_files,</div>
<div class="line">                result.total_processing_time_ms / 1000.0f,</div>
<div class="line">                result.average_processing_speed_mbps,</div>
<div class="line">                result.overall_compression_ratio);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md234"></a>
🛠️ パフォーマンス最適化テクニック</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
1. 状態管理の最適化</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 高効率な状態管理システム</span></div>
<div class="line"><span class="keyword">class </span>OptimizedActionStateManager {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>ActionState {</div>
<div class="line">        std::atomic&lt;ActionStatus&gt; status;</div>
<div class="line">        std::atomic&lt;float&gt; progress;</div>
<div class="line">        std::atomic&lt;uint64_t&gt; last_update_time;</div>
<div class="line">        std::string status_text;</div>
<div class="line">        std::mutex text_mutex;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::unordered_map&lt;uint64_t, std::unique_ptr&lt;ActionState&gt;&gt; states_;</div>
<div class="line">    std::shared_mutex states_mutex_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 状態変更通知システム</span></div>
<div class="line">    std::vector&lt;std::function&lt;void(uint64_t, ActionStatus)&gt;&gt; status_callbacks_;</div>
<div class="line">    std::mutex callbacks_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    uint64_t createAction(uint64_t goal_id) {</div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> state = std::make_unique&lt;ActionState&gt;();</div>
<div class="line">        state-&gt;status.store(ActionStatus::PENDING);</div>
<div class="line">        state-&gt;progress.store(0.0f);</div>
<div class="line">        state-&gt;last_update_time.store(getCurrentTimeUs());</div>
<div class="line">        </div>
<div class="line">        states_[goal_id] = std::move(state);</div>
<div class="line">        </div>
<div class="line">        notifyStatusChange(goal_id, ActionStatus::PENDING);</div>
<div class="line">        <span class="keywordflow">return</span> goal_id;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> updateProgress(uint64_t goal_id, <span class="keywordtype">float</span> progress, <span class="keyword">const</span> std::string&amp; text = <span class="stringliteral">&quot;&quot;</span>) {</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != states_.end()) {</div>
<div class="line">            it-&gt;second-&gt;progress.store(progress);</div>
<div class="line">            it-&gt;second-&gt;last_update_time.store(getCurrentTimeUs());</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!text.empty()) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; text_lock(it-&gt;second-&gt;text_mutex);</div>
<div class="line">                it-&gt;second-&gt;status_text = text;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> setStatus(uint64_t goal_id, ActionStatus status) {</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != states_.end()) {</div>
<div class="line">            ActionStatus old_status = it-&gt;second-&gt;status.exchange(status);</div>
<div class="line">            <span class="keywordflow">if</span> (old_status != status) {</div>
<div class="line">                notifyStatusChange(goal_id, status);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ActionStatus getStatus(uint64_t goal_id)<span class="keyword"> const </span>{</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">return</span> (it != states_.end()) ? it-&gt;second-&gt;status.load() : ActionStatus::PENDING;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> getProgress(uint64_t goal_id)<span class="keyword"> const </span>{</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">return</span> (it != states_.end()) ? it-&gt;second-&gt;progress.load() : 0.0f;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> addStatusCallback(std::function&lt;<span class="keywordtype">void</span>(uint64_t, ActionStatus)&gt; callback) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(callbacks_mutex_);</div>
<div class="line">        status_callbacks_.push_back(callback);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 古い状態のクリーンアップ</span></div>
<div class="line">    <span class="keywordtype">void</span> cleanupExpiredStates(uint64_t expiry_time_us) {</div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> current_time = getCurrentTimeUs();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = states_.begin(); it != states_.end();) {</div>
<div class="line">            <span class="keywordflow">if</span> (current_time - it-&gt;second-&gt;last_update_time.load() &gt; expiry_time_us) {</div>
<div class="line">                it = states_.erase(it);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                ++it;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> notifyStatusChange(uint64_t goal_id, ActionStatus status) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(callbacks_mutex_);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; callback : status_callbacks_) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                callback(goal_id, status);</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Status callback error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t getCurrentTimeUs()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now().time_since_epoch()).count();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md236"></a>
2. 高性能フィードバック配信</h2>
<div class="fragment"><div class="line"><span class="comment">// バッチ化フィードバックシステム</span></div>
<div class="line"><span class="keyword">class </span>BatchedFeedbackSystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>FeedbackBatch {</div>
<div class="line">        std::vector&lt;uint64_t&gt; goal_ids;</div>
<div class="line">        std::vector&lt;std::string&gt; feedback_data;</div>
<div class="line">        uint64_t timestamp;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::queue&lt;FeedbackBatch&gt; pending_batches_;</div>
<div class="line">    std::mutex batch_mutex_;</div>
<div class="line">    std::condition_variable batch_cv_;</div>
<div class="line">    std::thread delivery_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 設定パラメータ</span></div>
<div class="line">    <span class="keywordtype">size_t</span> max_batch_size_;</div>
<div class="line">    uint32_t batch_timeout_ms_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    BatchedFeedbackSystem(<span class="keywordtype">size_t</span> max_batch_size = 100, uint32_t batch_timeout_ms = 50)</div>
<div class="line">        : max_batch_size_(max_batch_size), batch_timeout_ms_(batch_timeout_ms), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        delivery_thread_ = std::thread(&amp;BatchedFeedbackSystem::deliveryLoop, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        batch_cv_.notify_all();</div>
<div class="line">        <span class="keywordflow">if</span> (delivery_thread_.joinable()) {</div>
<div class="line">            delivery_thread_.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> addFeedback(uint64_t goal_id, <span class="keyword">const</span> std::string&amp; feedback) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(batch_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 現在のバッチに追加または新しいバッチ作成</span></div>
<div class="line">        <span class="keywordflow">if</span> (pending_batches_.empty() || </div>
<div class="line">            pending_batches_.back().goal_ids.size() &gt;= max_batch_size_) {</div>
<div class="line">            </div>
<div class="line">            FeedbackBatch new_batch;</div>
<div class="line">            new_batch.timestamp = getCurrentTimeMs();</div>
<div class="line">            pending_batches_.push(new_batch);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span>&amp; current_batch = pending_batches_.back();</div>
<div class="line">        current_batch.goal_ids.push_back(goal_id);</div>
<div class="line">        current_batch.feedback_data.push_back(feedback);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// バッチが満杯になったら即座に配信トリガー</span></div>
<div class="line">        <span class="keywordflow">if</span> (current_batch.goal_ids.size() &gt;= max_batch_size_) {</div>
<div class="line">            batch_cv_.notify_one();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> deliveryLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            std::unique_lock&lt;std::mutex&gt; lock(batch_mutex_);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// タイムアウトまたは新しいバッチ待機</span></div>
<div class="line">            batch_cv_.wait_for(lock, std::chrono::milliseconds(batch_timeout_ms_),</div>
<div class="line">                              [<span class="keyword">this</span>] { <span class="keywordflow">return</span> !pending_batches_.empty() || !running_; });</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!running_) <span class="keywordflow">break</span>;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 配信対象バッチの収集</span></div>
<div class="line">            std::vector&lt;FeedbackBatch&gt; batches_to_deliver;</div>
<div class="line">            uint64_t current_time = getCurrentTimeMs();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (!pending_batches_.empty()) {</div>
<div class="line">                <span class="keyword">auto</span>&amp; batch = pending_batches_.front();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// タイムアウトまたはサイズ条件で配信</span></div>
<div class="line">                <span class="keywordflow">if</span> (batch.goal_ids.size() &gt;= max_batch_size_ ||</div>
<div class="line">                    (current_time - batch.timestamp) &gt;= batch_timeout_ms_) {</div>
<div class="line">                    </div>
<div class="line">                    batches_to_deliver.push_back(std::move(batch));</div>
<div class="line">                    pending_batches_.pop();</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keywordflow">break</span>;  <span class="comment">// まだ配信時期ではない</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            lock.unlock();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// バッチ配信実行</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; batch : batches_to_deliver) {</div>
<div class="line">                deliverBatch(batch);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> deliverBatch(<span class="keyword">const</span> FeedbackBatch&amp; batch) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// 実際のフィードバック配信処理</span></div>
<div class="line">            <span class="comment">// 共有メモリへの一括書き込み等</span></div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;フィードバックバッチ配信: &quot;</span> &lt;&lt; batch.goal_ids.size() </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; items&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Feedback delivery error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t getCurrentTimeMs()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now().time_since_epoch()).count();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md237"></a>
📊 パフォーマンス測定とベンチマーク</h1>
<h2><a class="anchor" id="autotoc_md238"></a>
詳細ベンチマーク</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ActionPerformanceBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>BenchmarkResult {</div>
<div class="line">        std::vector&lt;double&gt; goal_submission_times;</div>
<div class="line">        std::vector&lt;double&gt; feedback_latencies;</div>
<div class="line">        std::vector&lt;double&gt; completion_times;</div>
<div class="line">        std::vector&lt;double&gt; throughput_measurements;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    BenchmarkResult results_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> runActionBenchmark() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== Action通信ベンチマーク開始 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 1. ゴール送信レイテンシテスト</span></div>
<div class="line">        measureGoalSubmissionLatency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. フィードバック配信レイテンシテスト</span></div>
<div class="line">        measureFeedbackLatency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. 長時間アクションのスループットテスト</span></div>
<div class="line">        measureLongRunningActionThroughput();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 4. 並列アクション処理テスト</span></div>
<div class="line">        measureConcurrentActionProcessing();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 5. メモリ効率テスト</span></div>
<div class="line">        measureMemoryEfficiency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 結果解析</span></div>
<div class="line">        analyzeResults();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> measureGoalSubmissionLatency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ゴール送信レイテンシ測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 即座に完了</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal * 2);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        results_.goal_submission_times.clear();</div>
<div class="line">        results_.goal_submission_times.reserve(1000);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアント側測定</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            uint64_t goal_id = client.sendGoal(i);</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            results_.goal_submission_times.push_back(duration);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 完了待ち</span></div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureFeedbackLatency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;フィードバックレイテンシ測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;feedback_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;feedback_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;bool&gt; measurement_complete{<span class="keyword">false</span>};</div>
<div class="line">        results_.feedback_latencies.clear();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;]() {</div>
<div class="line">            <span class="keywordflow">while</span> (!measurement_complete) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 定期的にフィードバック送信</span></div>
<div class="line">                    for (int i = 0; i &lt; 100; ++i) {</div>
<div class="line">                        auto start = std::chrono::high_resolution_clock::now();</div>
<div class="line">                        </div>
<div class="line">                        server.publishFeedback(goal_id, (float)i);</div>
<div class="line">                        </div>
<div class="line">                        auto end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                            end - start).count();</div>
<div class="line">                        </div>
<div class="line">                        {</div>
<div class="line">                            static std::mutex latency_mutex;</div>
<div class="line">                            std::lock_guard&lt;std::mutex&gt; lock(latency_mutex);</div>
<div class="line">                            results_.feedback_latencies.push_back(duration);</div>
<div class="line">                        }</div>
<div class="line">                        </div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    server.setSucceeded(goal_id, 100);</div>
<div class="line">                    measurement_complete = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアント側でフィードバック受信</span></div>
<div class="line">        uint64_t goal_id = client.sendGoal(1);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">            <span class="keywordtype">float</span> feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">                <span class="comment">// フィードバック受信時刻を記録（簡略化）</span></div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureLongRunningActionThroughput() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;長時間アクションスループット測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_ACTIONS = 50;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> ACTION_DURATION_MS = 200;</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;int&gt; completed_actions{0};</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;]() {</div>
<div class="line">            <span class="keywordflow">while</span> (completed_actions &lt; NUM_ACTIONS) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 長時間処理をシミュレート</span></div>
<div class="line">                    std::thread([&amp;, goal_id, goal]() {</div>
<div class="line">                        for (int i = 0; i &lt; 10; ++i) {</div>
<div class="line">                            server.publishFeedback(goal_id, (float)i * 10.0f);</div>
<div class="line">                            std::this_thread::sleep_for(</div>
<div class="line">                                std::chrono::milliseconds(ACTION_DURATION_MS / 10));</div>
<div class="line">                        }</div>
<div class="line">                        </div>
<div class="line">                        server.setSucceeded(goal_id, goal);</div>
<div class="line">                        completed_actions++;</div>
<div class="line">                    }).detach();</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 複数のアクションを並列送信</span></div>
<div class="line">        std::vector&lt;uint64_t&gt; goal_ids;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_ACTIONS; ++i) {</div>
<div class="line">            goal_ids.push_back(client.sendGoal(i));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// すべての完了を待機</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint64_t goal_id : goal_ids) {</div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> total_duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end_time - start_time);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> throughput = (double)NUM_ACTIONS / total_duration.count() * 1000.0;  <span class="comment">// actions/sec</span></div>
<div class="line">        results_.throughput_measurements.push_back(throughput);</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;スループット: &quot;</span> &lt;&lt; throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureConcurrentActionProcessing() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;並列アクション処理性能測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;concurrent_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; client_counts = {1, 2, 4, 8, 16};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> client_count : client_counts) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            std::atomic&lt;int&gt; completed{0};</div>
<div class="line">            std::vector&lt;std::thread&gt; client_threads;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// サーバー側スレッド</span></div>
<div class="line">            std::thread server_thread([&amp;]() {</div>
<div class="line">                <span class="keywordflow">while</span> (completed &lt; client_count * 10) {</div>
<div class="line">                    <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                        uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                        int goal = server.getGoal(goal_id);</div>
<div class="line">                        </div>
<div class="line">                        <span class="comment">// 軽い処理</span></div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">                        server.setSucceeded(goal_id, goal);</div>
<div class="line">                        completed++;</div>
<div class="line">                    }</div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 複数クライアントスレッド</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; client_count; ++i) {</div>
<div class="line">                client_threads.emplace_back([i]() {</div>
<div class="line">                    ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;concurrent_test&quot;</span>);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 10; ++j) {</div>
<div class="line">                        uint64_t goal_id = client.sendGoal(i * 10 + j);</div>
<div class="line">                        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                            std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : client_threads) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            server_thread.join();</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> concurrent_throughput = (double)(client_count * 10) / duration * 1000.0;</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;同時クライアント数 &quot;</span> &lt;&lt; client_count &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">                      &lt;&lt; concurrent_throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureMemoryEfficiency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;メモリ効率測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// メモリ使用量測定の実装は環境依存</span></div>
<div class="line">        <span class="comment">// ここでは概念的な測定を示す</span></div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;std::vector&lt;char&gt;, std::vector&lt;char&gt;, <span class="keywordtype">float</span>&gt; server(<span class="stringliteral">&quot;memory_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;std::vector&lt;char&gt;, std::vector&lt;char&gt;, <span class="keywordtype">float</span>&gt; client(<span class="stringliteral">&quot;memory_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;size_t&gt; data_sizes = {1024, 10240, 102400, 1048576};  <span class="comment">// 1KB to 1MB</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> size : data_sizes) {</div>
<div class="line">            std::vector&lt;char&gt; large_data(size, <span class="charliteral">&#39;X&#39;</span>);</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            uint64_t goal_id = client.sendGoal(large_data);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// サーバー側で処理</span></div>
<div class="line">            std::thread([&amp;]() {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    auto goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// データをそのまま返す</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal);</div>
<div class="line">                }</div>
<div class="line">            }).detach();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> bandwidth = (double)size / duration;  <span class="comment">// bytes/μs = MB/s</span></div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;データサイズ &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; bytes: &quot;</span></div>
<div class="line">                      &lt;&lt; bandwidth &lt;&lt; <span class="stringliteral">&quot; MB/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> analyzeResults() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n=== ベンチマーク結果解析 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ゴール送信レイテンシ解析</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.goal_submission_times.empty()) {</div>
<div class="line">            analyzeLatencyVector(results_.goal_submission_times, <span class="stringliteral">&quot;ゴール送信レイテンシ&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// フィードバックレイテンシ解析</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.feedback_latencies.empty()) {</div>
<div class="line">            analyzeLatencyVector(results_.feedback_latencies, <span class="stringliteral">&quot;フィードバックレイテンシ&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// スループット解析</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.throughput_measurements.empty()) {</div>
<div class="line">            <span class="keywordtype">double</span> avg_throughput = std::accumulate(</div>
<div class="line">                results_.throughput_measurements.begin(),</div>
<div class="line">                results_.throughput_measurements.end(), 0.0) / </div>
<div class="line">                results_.throughput_measurements.size();</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;平均スループット: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(2)</div>
<div class="line">                      &lt;&lt; avg_throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> analyzeLatencyVector(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; latencies, <span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line">        <span class="keyword">auto</span> sorted_latencies = latencies;</div>
<div class="line">        std::sort(sorted_latencies.begin(), sorted_latencies.end());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> mean = std::accumulate(latencies.begin(), latencies.end(), 0.0) / latencies.size();</div>
<div class="line">        <span class="keywordtype">double</span> min_val = sorted_latencies.front();</div>
<div class="line">        <span class="keywordtype">double</span> max_val = sorted_latencies.back();</div>
<div class="line">        <span class="keywordtype">double</span> p50 = sorted_latencies[sorted_latencies.size() * 0.5];</div>
<div class="line">        <span class="keywordtype">double</span> p95 = sorted_latencies[sorted_latencies.size() * 0.95];</div>
<div class="line">        <span class="keywordtype">double</span> p99 = sorted_latencies[sorted_latencies.size() * 0.99];</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; (μs):&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  平均: &quot;</span> &lt;&lt; mean &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  最小: &quot;</span> &lt;&lt; min_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  最大: &quot;</span> &lt;&lt; max_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  50%ile: &quot;</span> &lt;&lt; p50 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  95%ile: &quot;</span> &lt;&lt; p95 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  99%ile: &quot;</span> &lt;&lt; p99 &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (p99 &lt; 1000.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  🏆 優秀: 99%のレイテンシが1ms以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p99 &lt; 10000.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  👍 良好: 99%のレイテンシが10ms以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  ⚠️  要改善: レイテンシが高めです&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ベンチマーク実行</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        ActionPerformanceBenchmark benchmark;</div>
<div class="line">        benchmark.runActionBenchmark();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ベンチマークエラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md239"></a>
❓ よくある質問</h1>
<h2><a class="anchor" id="autotoc_md240"></a>
Q1. アクションが完了しない場合はどうすればよいですか？</h2>
<p><b>A</b>: 以下をチェックしてください：</p><ul>
<li>サーバーが正しく動作し、ゴールを受け付けているか</li>
<li>サーバー側で例外やデッドロックが発生していないか</li>
<li>アクション内でキャンセル確認を定期的に行っているか</li>
<li>タイムアウト設定が適切か</li>
</ul>
<h2><a class="anchor" id="autotoc_md241"></a>
Q2. フィードバックが届かない場合の原因は？</h2>
<p><b>A</b>: 考えられる原因：</p><ul>
<li>フィードバック送信間隔が短すぎる（バッファオーバーフロー）</li>
<li>共有メモリのサイズ不足</li>
<li>クライアント側でフィードバック読み取りが遅い</li>
<li>ネットワーク遅延（リモート使用時）</li>
</ul>
<h2><a class="anchor" id="autotoc_md242"></a>
Q3. 長時間アクションの途中でプロセスがクラッシュした場合は？</h2>
<p><b>A</b>: Action通信では以下の対策があります：</p><ul>
<li><b>チェックポイント保存</b>: 定期的に進捗を永続化</li>
<li><b>再開機能</b>: 中断点からの復旧機能</li>
<li><b>状態監視</b>: 別プロセスでアクション状態を監視</li>
<li><b>タイムアウト設定</b>: 無応答状態の自動検出</li>
</ul>
<h2><a class="anchor" id="autotoc_md243"></a>
Q4. 複数のアクションを並列実行する際の注意点は？</h2>
<p><b>A</b>: 以下に注意してください：</p><ul>
<li><b>リソース競合</b>: ファイルやデバイスの排他制御</li>
<li><b>メモリ使用量</b>: 各アクションのメモリ消費量を考慮</li>
<li><b>CPU負荷</b>: 適切なワーカー数の設定</li>
<li><b>優先度制御</b>: 重要なアクションの優先実行</li>
</ul>
<h1><a class="anchor" id="autotoc_md244"></a>
🔧 トラブルシューティング</h1>
<h2><a class="anchor" id="autotoc_md245"></a>
よくある問題と解決法</h2>
<div class="fragment"><div class="line"><span class="comment">// Action通信診断ツール</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> diagnose_action_communication() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;=== Action通信診断 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// 1. サーバー作成テスト</span></div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;diagnostic_action&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ サーバー作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. クライアント作成テスト</span></div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;diagnostic_action&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ クライアント作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. 通信テスト</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordtype">int</span> test_count = 0;</div>
<div class="line">            <span class="keywordflow">while</span> (test_count &lt; 3) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;サーバー: ゴール受信 &quot;</span> &lt;&lt; goal &lt;&lt; std::endl;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// フィードバック送信</span></div>
<div class="line">                    for (int i = 0; i &lt; 5; ++i) {</div>
<div class="line">                        server.publishFeedback(goal_id, (float)i * 20.0f);</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;サーバー: フィードバック送信 &quot;</span> &lt;&lt; (i * 20) &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// 結果送信</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal * 2);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;サーバー: 結果送信 &quot;</span> &lt;&lt; (goal * 2) &lt;&lt; std::endl;</div>
<div class="line">                    test_count++;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ゴール送信</span></div>
<div class="line">        uint64_t goal_id = client.sendGoal(21);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;クライアント: ゴール送信 21&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// フィードバック監視</span></div>
<div class="line">        <span class="keywordtype">bool</span> feedback_received = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">            <span class="keywordtype">float</span> feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;クライアント: フィードバック受信 &quot;</span> &lt;&lt; feedback &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                feedback_received = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 結果確認</span></div>
<div class="line">        <span class="keywordflow">if</span> (client.getState(goal_id) == ActionStatus::SUCCEEDED) {</div>
<div class="line">            <span class="keywordtype">int</span> result = client.getResult(goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;クライアント: 結果受信 &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result == 42 &amp;&amp; feedback_received) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;✅ 通信テスト成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 通信テスト失敗: 期待値42、実際値&quot;</span> &lt;&lt; result </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, フィードバック受信: &quot;</span> &lt;&lt; (feedback_received ? <span class="stringliteral">&quot;○&quot;</span> : <span class="stringliteral">&quot;×&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 通信テスト失敗: アクションが失敗&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 診断エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;以下を確認してください:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - 共有メモリの権限設定&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - 他のプロセスがアクションを使用中でないか&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - システムリソースの不足&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - メモリサイズの設定&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 堅牢なアクションクライアントの例</span></div>
<div class="line"><span class="keyword">class </span>RobustActionClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionClient&lt;GoalType, ResultType, FeedbackType&gt; client_;</div>
<div class="line">    std::string action_name_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RobustActionClient(<span class="keyword">const</span> std::string&amp; action_name) </div>
<div class="line">        : client_(action_name), action_name_(action_name) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> executeGoalWithRetry(<span class="keyword">const</span> GoalType&amp; goal, ResultType&amp; result, </div>
<div class="line">                             <span class="keywordtype">int</span> max_retries = 3, <span class="keywordtype">int</span> timeout_ms = 30000) {</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> retry = 0; retry &lt; max_retries; ++retry) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ゴール実行 (試行 &quot;</span> &lt;&lt; (retry + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; max_retries &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                uint64_t goal_id = client_.sendGoal(goal);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// タイムアウト付き完了待機</span></div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">while</span> (!client_.isComplete(goal_id)) {</div>
<div class="line">                    <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                    <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                        current_time - start_time);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (elapsed.count() &gt; timeout_ms) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;タイムアウト: ゴールをキャンセルします...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        client_.cancelGoal(goal_id);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// フィードバック表示</span></div>
<div class="line">                    FeedbackType feedback;</div>
<div class="line">                    <span class="keywordflow">if</span> (client_.getFeedback(goal_id, feedback)) {</div>
<div class="line">                        displayFeedback(feedback);</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 結果確認</span></div>
<div class="line">                ActionStatus status = client_.getState(goal_id);</div>
<div class="line">                <span class="keywordflow">if</span> (status == ActionStatus::SUCCEEDED) {</div>
<div class="line">                    result = client_.getResult(goal_id);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;成功: ゴール完了&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;失敗: &quot;</span> &lt;&lt; actionStatusToString(status) &lt;&lt; std::endl;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (retry &lt; max_retries - 1) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;再試行します...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (retry &lt; max_retries - 1) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;再試行します...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;最大再試行回数に達しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">throw</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> displayFeedback(<span class="keyword">const</span> FeedbackType&amp; feedback) {</div>
<div class="line">        <span class="comment">// フィードバック表示の実装</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;進捗更新...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::string actionStatusToString(ActionStatus status) {</div>
<div class="line">        <span class="keywordflow">switch</span> (status) {</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::PENDING: <span class="keywordflow">return</span> <span class="stringliteral">&quot;待機中&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::ACTIVE: <span class="keywordflow">return</span> <span class="stringliteral">&quot;実行中&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::PREEMPTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;中断&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::SUCCEEDED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;成功&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::ABORTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;異常終了&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::REJECTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;拒否&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::RECALLED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;取り消し&quot;</span>;</div>
<div class="line">            <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;不明&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md246"></a>
📚 次のステップ</h1>
<p>Action通信をマスターしたら、以下の高度なトピックに挑戦してみましょう：</p>
<ol type="1">
<li><b><a class="el" href="md_manual_tutorials_shm_pub_sub_jp.html">📡 Pub/Sub通信</a></b> - 高速ブロードキャスト通信</li>
<li><b><a class="el" href="md_manual_tutorials_shm_service_jp.html">🤝 Service通信</a></b> - 確実な要求応答通信</li>
<li><b><a class="el" href="md_manual_tutorials_python_jp.html">🐍 Python連携</a></b> - PythonでAction通信</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md248"></a>
📄 ライセンス情報</h1>
<p>本ドキュメントで紹介しているサンプルコードは、shared-memory-based-handy-communication-manager プロジェクトの一部として <b>Apache License 2.0</b> の下で提供されています。</p>
<ul>
<li>✅ <b>商用利用可能</b>: サンプルコードを商業プロジェクトで自由に使用</li>
<li>✅ <b>改変可能</b>: ニーズに合わせてコードを修正・拡張</li>
<li>✅ <b>再配布可能</b>: ライセンス表示を保持して再配布</li>
</ul>
<p>詳細は<a href="../LICENSE">LICENSEファイル</a>をご確認ください。</p>
<hr  />
<p>この完全ガイドで、Action通信の真の力を引き出し、次世代の高度な非同期処理システムを構築しましょう！ 🚀✨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 5 2025 13:54:48 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
