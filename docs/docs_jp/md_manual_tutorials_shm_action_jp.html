<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: âš¡ Actioné€šä¿¡å®Œå…¨ã‚¬ã‚¤ãƒ‰ - é•·æ™‚é–“éåŒæœŸå‡¦ç†ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ã‚ˆã†</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">å…±æœ‰ãƒ¡ãƒ¢ãƒªã‚’ç”¨ã„ãŸé«˜é€Ÿã§æ‰±ã„ã‚„ã™ã„ãƒ—ãƒ­ã‚»ã‚¹é–“é€šä¿¡ãƒãƒãƒ¼ã‚¸ãƒ£</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">âš¡ Actioné€šä¿¡å®Œå…¨ã‚¬ã‚¤ãƒ‰ - é•·æ™‚é–“éåŒæœŸå‡¦ç†ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ã‚ˆã† </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../md_manual_tutorials_shm_action_en.html">English</a> | æ—¥æœ¬èª]</p>
<h1><a class="anchor" id="autotoc_md225"></a>
ğŸ¯ ã“ã®ã‚¬ã‚¤ãƒ‰ã§å­¦ã¹ã‚‹ã“ã¨</h1>
<ul>
<li><b>Actioné€šä¿¡ã®æ·±ã„ç†è§£</b>: éåŒæœŸå‡¦ç†ãƒ‘ã‚¿ãƒ¼ãƒ³ã®è¨­è¨ˆæ€æƒ³ã‹ã‚‰å®Ÿè£…è©³ç´°ã¾ã§</li>
<li><b>é•·æ™‚é–“å‡¦ç†ã®ç®¡ç†</b>: é€²æ—ç›£è¦–ã€ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ©Ÿèƒ½ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°</li>
<li><b>é«˜åº¦ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼è¨­è¨ˆ</b>: ä¸¦åˆ—å‡¦ç†ã€ã‚¿ã‚¹ã‚¯ãƒã‚§ãƒ¼ãƒ³ã€çŠ¶æ…‹ç®¡ç†</li>
<li><b>å®Ÿè·µçš„ãªå¿œç”¨ä¾‹</b>: ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã€æ©Ÿæ¢°å­¦ç¿’ã€å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿å¤‰æ›</li>
</ul>
<h1><a class="anchor" id="autotoc_md226"></a>
ğŸ§  Actioné€šä¿¡ã®æ·±ã„ç†è§£</h1>
<h2><a class="anchor" id="autotoc_md227"></a>
ğŸ—ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è§£èª¬</h2>
<div class="fragment"><div class="line"><span class="comment">// Actioné€šä¿¡ã®å†…éƒ¨æ§‹é€ </span></div>
<div class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</div>
<div class="line">â”‚                   å…±æœ‰ãƒ¡ãƒ¢ãƒªç©ºé–“                              â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚­ãƒ¥ãƒ¼                        â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [Goal 0][Goal 1][Goal 2]...[Goal N-1]             â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  å®Ÿè¡Œä½ç½®                    è¿½åŠ ä½ç½®                â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚­ãƒ¥ãƒ¼                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [FB 0][FB 1][FB 2]...[FB N-1]                     â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  èª­å–ä½ç½®                    æ›¸è¾¼ä½ç½®                â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              çµæœã‚­ãƒ¥ãƒ¼                             â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [Result 0][Result 1]...[Result N-1]               â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  èª­å–ä½ç½®                    æ›¸è¾¼ä½ç½®                â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ç®¡ç†:                                         â”‚</div>
<div class="line">â”‚  - ã‚´ãƒ¼ãƒ«ID (ä¸€æ„è­˜åˆ¥å­)                                     â”‚</div>
<div class="line">â”‚  - å®Ÿè¡ŒçŠ¶æ…‹ (å¾…æ©Ÿ/å®Ÿè¡Œä¸­/å®Œäº†/ã‚­ãƒ£ãƒ³ã‚»ãƒ«/ã‚¨ãƒ©ãƒ¼)              â”‚</div>
<div class="line">â”‚  - é€²æ—æƒ…å ± (å®Œäº†ç‡ã€æ®‹ã‚Šæ™‚é–“ã€å‡¦ç†è©³ç´°)                      â”‚</div>
<div class="line">â”‚  - ã‚­ãƒ£ãƒ³ã‚»ãƒ«ãƒ•ãƒ©ã‚° (éåŒæœŸã‚­ãƒ£ãƒ³ã‚»ãƒ«è¦æ±‚)                    â”‚</div>
<div class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
<div class="line"> </div>
<div class="line">Multiple Clients â† [shared memory] â†’ Single Server</div>
<div class="line">      â”‚                                        â”‚</div>
<div class="line">   ã‚´ãƒ¼ãƒ«é€ä¿¡                             ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å®Ÿè¡Œã‚¨ãƒ³ã‚¸ãƒ³</div>
<div class="line">   ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡                           â”‚</div>
<div class="line">   çµæœå—ä¿¡                                 é•·æ™‚é–“å‡¦ç†</div>
<div class="line">   ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¦æ±‚                            é€²æ—å ±å‘Š</div>
<div class="line">      â”‚                                   çµæœç”Ÿæˆ</div>
<div class="line">   éåŒæœŸç›£è¦–</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md228"></a>
âš¡ ãªãœé•·æ™‚é–“å‡¦ç†ã«æœ€é©ãªã®ã‹ï¼Ÿ</h2>
<p><b>1. éåŒæœŸå®Ÿè¡Œã¨ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</b> </p><div class="fragment"><div class="line"><span class="comment">// ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®åŸºæœ¬ãƒ‘ã‚¿ãƒ¼ãƒ³</span></div>
<div class="line">ActionClient&lt;GoalType, ResultType, FeedbackType&gt; client(<span class="stringliteral">&quot;action_server&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ã‚´ãƒ¼ãƒ«é€ä¿¡ï¼ˆéãƒ–ãƒ­ãƒƒã‚­ãƒ³ã‚°ï¼‰</span></div>
<div class="line">uint64_t goal_id = client.sendGoal(goal_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ä»–ã®å‡¦ç†ã‚’ç¶™ç¶š...</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç¢ºèª</span></div>
<div class="line">    FeedbackType feedback;</div>
<div class="line">    <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;é€²æ—: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// å®Œäº†ç¢ºèª</span></div>
<div class="line">    <span class="keywordflow">if</span> (client.isComplete(goal_id)) {</div>
<div class="line">        ResultType result = client.getResult(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// å¿…è¦ã«å¿œã˜ã¦ã‚­ãƒ£ãƒ³ã‚»ãƒ«</span></div>
<div class="line">    <span class="keywordflow">if</span> (user_cancel_request) {</div>
<div class="line">        client.cancelGoal(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. çŠ¶æ…‹ç®¡ç†ã¨é€²æ—ç›£è¦–</b> </p><div class="fragment"><div class="line"><span class="comment">// å†…éƒ¨çš„ãªçŠ¶æ…‹ç®¡ç†</span></div>
<div class="line"><span class="keyword">enum class</span> ActionStatus {</div>
<div class="line">    PENDING,        <span class="comment">// å¾…æ©Ÿä¸­</span></div>
<div class="line">    ACTIVE,         <span class="comment">// å®Ÿè¡Œä¸­</span></div>
<div class="line">    PREEMPTED,      <span class="comment">// ä¸­æ–­ã•ã‚ŒãŸ</span></div>
<div class="line">    SUCCEEDED,      <span class="comment">// æˆåŠŸå®Œäº†</span></div>
<div class="line">    ABORTED,        <span class="comment">// ç•°å¸¸çµ‚äº†</span></div>
<div class="line">    REJECTED,       <span class="comment">// æ‹’å¦ã•ã‚ŒãŸ</span></div>
<div class="line">    RECALLED        <span class="comment">// å–ã‚Šæ¶ˆã•ã‚ŒãŸ</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ActionState {</div>
<div class="line">    uint64_t goal_id;</div>
<div class="line">    ActionStatus status;</div>
<div class="line">    uint64_t start_time;</div>
<div class="line">    uint64_t last_feedback_time;</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint32_t estimated_duration_ms;</div>
<div class="line">    <span class="keywordtype">char</span> status_text[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// çŠ¶æ…‹è¿½è·¡ã‚·ã‚¹ãƒ†ãƒ </span></div>
<div class="line"><span class="keyword">class </span>ActionStateTracker {</div>
<div class="line">    std::unordered_map&lt;uint64_t, ActionState&gt; active_actions_;</div>
<div class="line">    std::mutex state_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> updateProgress(uint64_t goal_id, <span class="keywordtype">float</span> progress, <span class="keyword">const</span> std::string&amp; text) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(state_mutex_);</div>
<div class="line">        <span class="keyword">auto</span>&amp; state = active_actions_[goal_id];</div>
<div class="line">        state.progress_percent = progress;</div>
<div class="line">        state.last_feedback_time = getCurrentTimeUs();</div>
<div class="line">        strncpy(state.status_text, text.c_str(), 255);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// è‡ªå‹•çš„ãªå®Œäº†æ™‚é–“æ¨å®š</span></div>
<div class="line">        <span class="keywordflow">if</span> (progress &gt; 0.0f) {</div>
<div class="line">            uint64_t elapsed = state.last_feedback_time - state.start_time;</div>
<div class="line">            state.estimated_duration_ms = (elapsed / progress) * (100.0f - progress) / 1000;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>3. é«˜åº¦ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ç®¡ç†</b> </p><div class="fragment"><div class="line"><span class="comment">// è¤‡æ•°ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ä¸¦åˆ—å®Ÿè¡Œ</span></div>
<div class="line"><span class="keyword">class </span>ParallelActionManager {</div>
<div class="line">    std::vector&lt;ActionClient&lt;GoalType, ResultType, FeedbackType&gt;&gt; clients_;</div>
<div class="line">    std::vector&lt;uint64_t&gt; active_goals_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> executeParallelActions(<span class="keyword">const</span> std::vector&lt;GoalType&gt;&amp; goals) {</div>
<div class="line">        active_goals_.clear();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã™ã¹ã¦ã®ã‚´ãƒ¼ãƒ«ã‚’ä¸¦åˆ—é€ä¿¡</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; goals.size(); ++i) {</div>
<div class="line">            uint64_t goal_id = clients_[i].sendGoal(goals[i]);</div>
<div class="line">            active_goals_.push_back(goal_id);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// å®Œäº†ç›£è¦–</span></div>
<div class="line">        <span class="keywordflow">while</span> (!active_goals_.empty()) {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = active_goals_.begin(); it != active_goals_.end();) {</div>
<div class="line">                <span class="keywordtype">size_t</span> client_index = it - active_goals_.begin();</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (clients_[client_index].isComplete(*it)) {</div>
<div class="line">                    <span class="keyword">auto</span> result = clients_[client_index].getResult(*it);</div>
<div class="line">                    processResult(result);</div>
<div class="line">                    it = active_goals_.erase(it);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å‡¦ç†</span></div>
<div class="line">                    FeedbackType feedback;</div>
<div class="line">                    <span class="keywordflow">if</span> (clients_[client_index].getFeedback(*it, feedback)) {</div>
<div class="line">                        updateProgressDisplay(client_index, feedback);</div>
<div class="line">                    }</div>
<div class="line">                    ++it;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md229"></a>
ğŸš€ åŸºæœ¬çš„ãªä½¿ã„æ–¹</h1>
<h2><a class="anchor" id="autotoc_md230"></a>
1. ç°¡å˜ãªãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚´ãƒ¼ãƒ«</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> output_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> operation[64];      <span class="comment">// &quot;compress&quot;, &quot;encrypt&quot;, &quot;convert&quot;</span></div>
<div class="line">    <span class="keywordtype">float</span> quality;           <span class="comment">// å“è³ªè¨­å®š (0.0 - 1.0)</span></div>
<div class="line">    <span class="keywordtype">bool</span> preserve_metadata;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†çµæœ</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint64_t input_size;</div>
<div class="line">    uint64_t output_size;</div>
<div class="line">    uint32_t processing_time_ms;</div>
<div class="line">    <span class="keywordtype">float</span> compression_ratio;</div>
<div class="line">    <span class="keywordtype">char</span> error_message[256];</div>
<div class="line">    <span class="keywordtype">char</span> final_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessFeedback {</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint64_t bytes_processed;</div>
<div class="line">    uint64_t bytes_remaining;</div>
<div class="line">    uint32_t estimated_time_remaining_ms;</div>
<div class="line">    <span class="keywordtype">char</span> current_stage[128];</div>
<div class="line">    <span class="keywordtype">float</span> current_speed_mbps;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚µãƒ¼ãƒãƒ¼</span></div>
<div class="line"><span class="keyword">class </span>FileProcessingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;FileProcessGoal, FileProcessResult, FileProcessFeedback&gt; server_;</div>
<div class="line">    std::thread processing_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingServer() : server_(<span class="stringliteral">&quot;file_processor&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        processing_thread_ = std::thread(&amp;FileProcessingServer::processLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚µãƒ¼ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (processing_thread_.joinable()) {</div>
<div class="line">            processing_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                FileProcessGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†é–‹å§‹: &quot;</span> &lt;&lt; goal.input_path </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; goal.output_path &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// éåŒæœŸã§ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚’å®Ÿè¡Œ</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal, start_time]() {</div>
<div class="line">                    processFile(goal_id, goal, start_time);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processFile(uint64_t goal_id, <span class="keyword">const</span> FileProcessGoal&amp; goal, </div>
<div class="line">                    std::chrono::high_resolution_clock::time_point start_time) {</div>
<div class="line">        FileProcessResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.input_size = 0;</div>
<div class="line">        result.output_size = 0;</div>
<div class="line">        result.compression_ratio = 1.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå–å¾—</span></div>
<div class="line">            std::ifstream input(goal.input_path, std::ios::binary | std::ios::ate);</div>
<div class="line">            <span class="keywordflow">if</span> (!input.is_open()) {</div>
<div class="line">                strncpy(result.error_message, <span class="stringliteral">&quot;å…¥åŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã‘ã¾ã›ã‚“&quot;</span>, 255);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            result.input_size = input.tellg();</div>
<div class="line">            input.seekg(0, std::ios::beg);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«æº–å‚™</span></div>
<div class="line">            std::ofstream output(goal.output_path, std::ios::binary);</div>
<div class="line">            <span class="keywordflow">if</span> (!output.is_open()) {</div>
<div class="line">                strncpy(result.error_message, <span class="stringliteral">&quot;å‡ºåŠ›ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã§ãã¾ã›ã‚“&quot;</span>, 255);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Ÿè¡Œ</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> BUFFER_SIZE = 64 * 1024;  <span class="comment">// 64KB buffer</span></div>
<div class="line">            std::vector&lt;char&gt; buffer(BUFFER_SIZE);</div>
<div class="line">            uint64_t total_processed = 0;</div>
<div class="line">            </div>
<div class="line">            FileProcessFeedback feedback;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (input.read(buffer.data(), BUFFER_SIZE) || input.gcount() &gt; 0) {</div>
<div class="line">                <span class="comment">// ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç¢ºèª</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    result.success = <span class="keyword">false</span>;</div>
<div class="line">                    strncpy(result.error_message, <span class="stringliteral">&quot;å‡¦ç†ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ&quot;</span>, 255);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    input.close();</div>
<div class="line">                    output.close();</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keywordtype">size_t</span> bytes_read = input.gcount();</div>
<div class="line">                total_processed += bytes_read;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã®å‡¦ç†ã«ç½®ãæ›ãˆï¼‰</span></div>
<div class="line">                processData(buffer.data(), bytes_read, goal.operation, goal.quality);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// å‡¦ç†ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿</span></div>
<div class="line">                output.write(buffer.data(), bytes_read);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ›´æ–°</span></div>
<div class="line">                feedback.progress_percent = (float)total_processed / result.input_size * 100.0f;</div>
<div class="line">                feedback.bytes_processed = total_processed;</div>
<div class="line">                feedback.bytes_remaining = result.input_size - total_processed;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    current_time - start_time);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (elapsed.count() &gt; 0 &amp;&amp; total_processed &gt; 0) {</div>
<div class="line">                    feedback.current_speed_mbps = (float)total_processed / elapsed.count() / 1024.0f;</div>
<div class="line">                    <span class="keywordflow">if</span> (feedback.progress_percent &gt; 0) {</div>
<div class="line">                        feedback.estimated_time_remaining_ms = </div>
<div class="line">                            elapsed.count() * (100.0f - feedback.progress_percent) / feedback.progress_percent;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                snprintf(feedback.current_stage, 127, <span class="stringliteral">&quot;%så‡¦ç†ä¸­&quot;</span>, goal.operation);</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// å‡¦ç†é€Ÿåº¦èª¿æ•´ï¼ˆå®Ÿéš›ã®å‡¦ç†è² è·ã«å¿œã˜ã¦ï¼‰</span></div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            input.close();</div>
<div class="line">            output.close();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// çµæœè¨­å®š</span></div>
<div class="line">            std::ifstream output_check(goal.output_path, std::ios::binary | std::ios::ate);</div>
<div class="line">            result.output_size = output_check.tellg();</div>
<div class="line">            output_check.close();</div>
<div class="line">            </div>
<div class="line">            result.compression_ratio = (float)result.output_size / result.input_size;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.processing_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            strncpy(result.final_path, goal.output_path, 511);</div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">            </div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Œäº†: &quot;</span> &lt;&lt; result.processing_time_ms &lt;&lt; <span class="stringliteral">&quot;ms, &quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;åœ§ç¸®ç‡: &quot;</span> &lt;&lt; result.compression_ratio &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(result.error_message, e.what(), 255);</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processData(<span class="keywordtype">char</span>* data, <span class="keywordtype">size_t</span> size, <span class="keyword">const</span> <span class="keywordtype">char</span>* operation, <span class="keywordtype">float</span> quality) {</div>
<div class="line">        <span class="comment">// å®Ÿéš›ã®ãƒ‡ãƒ¼ã‚¿å‡¦ç†ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </span></div>
<div class="line">        <span class="comment">// ã“ã®ä¾‹ã§ã¯ç°¡å˜ãªå¤‰æ›ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (strcmp(operation, <span class="stringliteral">&quot;encrypt&quot;</span>) == 0) {</div>
<div class="line">            <span class="comment">// ç°¡å˜ãªæš—å·åŒ–ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; size; ++i) {</div>
<div class="line">                data[i] ^= 0x55;  <span class="comment">// XORæš—å·åŒ–</span></div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(operation, <span class="stringliteral">&quot;compress&quot;</span>) == 0) {</div>
<div class="line">            <span class="comment">// åœ§ç¸®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå®Ÿéš›ã«ã¯zlibç­‰ã‚’ä½¿ç”¨ï¼‰</span></div>
<div class="line">            <span class="comment">// qualityå€¤ã«åŸºã¥ã„ã¦å‡¦ç†æ™‚é–“ã‚’èª¿æ•´</span></div>
<div class="line">            <span class="keyword">auto</span> delay = std::chrono::microseconds((<span class="keywordtype">int</span>)(100 * quality));</div>
<div class="line">            std::this_thread::sleep_for(delay);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ</span></div>
<div class="line"><span class="keyword">class </span>FileProcessingClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionClient&lt;FileProcessGoal, FileProcessResult, FileProcessFeedback&gt; client_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingClient() : client_(<span class="stringliteral">&quot;file_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> processFile(<span class="keyword">const</span> std::string&amp; input_path, <span class="keyword">const</span> std::string&amp; output_path,</div>
<div class="line">                    <span class="keyword">const</span> std::string&amp; operation, <span class="keywordtype">float</span> quality = 0.8f) {</div>
<div class="line">        FileProcessGoal goal;</div>
<div class="line">        strncpy(goal.input_path, input_path.c_str(), 511);</div>
<div class="line">        strncpy(goal.output_path, output_path.c_str(), 511);</div>
<div class="line">        strncpy(goal.operation, operation.c_str(), 63);</div>
<div class="line">        goal.quality = quality;</div>
<div class="line">        goal.preserve_metadata = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†è¦æ±‚é€ä¿¡...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        uint64_t goal_id = client_.sendGoal(goal);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// é€²æ—ç›£è¦–</span></div>
<div class="line">        <span class="keywordflow">while</span> (!client_.isComplete(goal_id)) {</div>
<div class="line">            FileProcessFeedback feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client_.getFeedback(goal_id, feedback)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;\ré€²æ—: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) </div>
<div class="line">                          &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;% (&quot;</span></div>
<div class="line">                          &lt;&lt; feedback.current_stage &lt;&lt; <span class="stringliteral">&quot;, &quot;</span></div>
<div class="line">                          &lt;&lt; feedback.current_speed_mbps &lt;&lt; <span class="stringliteral">&quot; MB/s, &quot;</span></div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;æ®‹ã‚Š: &quot;</span> &lt;&lt; feedback.estimated_time_remaining_ms / 1000 &lt;&lt; <span class="stringliteral">&quot;s)&quot;</span></div>
<div class="line">                          &lt;&lt; std::flush;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(200));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// çµæœå–å¾—</span></div>
<div class="line">        <span class="keywordflow">if</span> (client_.getState(goal_id) == ActionStatus::SUCCEEDED) {</div>
<div class="line">            FileProcessResult result = client_.getResult(goal_id);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;å‡¦ç†å®Œäº†!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  å…¥åŠ›ã‚µã‚¤ã‚º: &quot;</span> &lt;&lt; result.input_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  å‡ºåŠ›ã‚µã‚¤ã‚º: &quot;</span> &lt;&lt; result.output_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  å‡¦ç†æ™‚é–“: &quot;</span> &lt;&lt; result.processing_time_ms &lt;&lt; <span class="stringliteral">&quot; ms&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  åœ§ç¸®ç‡: &quot;</span> &lt;&lt; result.compression_ratio &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            FileProcessResult result = client_.getResult(goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;å‡¦ç†å¤±æ•—: &quot;</span> &lt;&lt; result.error_message &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> cancelProcessing(uint64_t goal_id) {</div>
<div class="line">        client_.cancelGoal(goal_id);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;å‡¦ç†ã‚­ãƒ£ãƒ³ã‚»ãƒ«è¦æ±‚ã‚’é€ä¿¡ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ä½¿ç”¨ä¾‹</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// ã‚µãƒ¼ãƒãƒ¼é–‹å§‹</span></div>
<div class="line">        FileProcessingServer server;</div>
<div class="line">        server.start();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        FileProcessingClient client;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Ÿè¡Œ</span></div>
<div class="line">        <span class="keywordtype">bool</span> success = client.processFile(</div>
<div class="line">            <span class="stringliteral">&quot;/tmp/input.txt&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;/tmp/output.enc&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;encrypt&quot;</span>,</div>
<div class="line">            0.9f</div>
<div class="line">        );</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (success) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ãŒæˆåŠŸã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚µãƒ¼ãƒãƒ¼åœæ­¢</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">        server.stop();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ashm__action_8hpp_html"><div class="ttname"><a href="shm__action_8hpp.html">shm_action.hpp</a></div><div class="ttdoc">ãƒ¡ãƒ¢ãƒªã®æ ¼ç´æ–¹æ³•ã‚’è¦å®šã™ã‚‹ã‚¯ãƒ©ã‚¹ã®å®šç¾©</div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md231"></a>
2. æ©Ÿæ¢°å­¦ç¿’è¨“ç·´ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</h2>
<div class="fragment"><div class="line"><span class="comment">// æ©Ÿæ¢°å­¦ç¿’è¨“ç·´ã®ãƒ‡ãƒ¼ã‚¿æ§‹é€ </span></div>
<div class="line"><span class="keyword">struct </span>MLTrainingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> dataset_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> model_type[64];         <span class="comment">// &quot;neural_network&quot;, &quot;svm&quot;, &quot;random_forest&quot;</span></div>
<div class="line">    <span class="keywordtype">char</span> output_model_path[512];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ãƒã‚¤ãƒ‘ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</span></div>
<div class="line">    <span class="keywordtype">float</span> learning_rate;</div>
<div class="line">    <span class="keywordtype">int</span> epochs;</div>
<div class="line">    <span class="keywordtype">int</span> batch_size;</div>
<div class="line">    <span class="keywordtype">float</span> validation_split;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// è¨­å®šãƒ•ãƒ©ã‚°</span></div>
<div class="line">    <span class="keywordtype">bool</span> use_gpu;</div>
<div class="line">    <span class="keywordtype">bool</span> early_stopping;</div>
<div class="line">    <span class="keywordtype">int</span> max_training_time_minutes;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">float</span> final_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> final_loss;</div>
<div class="line">    <span class="keywordtype">int</span> epochs_completed;</div>
<div class="line">    uint32_t training_time_ms;</div>
<div class="line">    uint64_t model_size_bytes;</div>
<div class="line">    <span class="keywordtype">char</span> model_path[512];</div>
<div class="line">    <span class="keywordtype">char</span> error_details[512];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// è©³ç´°ãƒ¡ãƒˆãƒªã‚¯ã‚¹</span></div>
<div class="line">    <span class="keywordtype">float</span> validation_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> validation_loss;</div>
<div class="line">    <span class="keywordtype">float</span> overfitting_score;</div>
<div class="line">    <span class="keywordtype">char</span> best_checkpoint_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingFeedback {</div>
<div class="line">    <span class="keywordtype">int</span> current_epoch;</div>
<div class="line">    <span class="keywordtype">int</span> total_epochs;</div>
<div class="line">    <span class="keywordtype">float</span> current_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> current_loss;</div>
<div class="line">    <span class="keywordtype">float</span> validation_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> validation_loss;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// é€²æ—æƒ…å ±</span></div>
<div class="line">    <span class="keywordtype">float</span> epoch_progress_percent;</div>
<div class="line">    <span class="keywordtype">float</span> overall_progress_percent;</div>
<div class="line">    uint32_t epoch_time_ms;</div>
<div class="line">    uint32_t estimated_remaining_ms;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çµ±è¨ˆ</span></div>
<div class="line">    <span class="keywordtype">float</span> samples_per_second;</div>
<div class="line">    <span class="keywordtype">char</span> current_phase[64];      <span class="comment">// &quot;training&quot;, &quot;validation&quot;, &quot;checkpointing&quot;</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_improving;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// æ©Ÿæ¢°å­¦ç¿’è¨“ç·´ã‚µãƒ¼ãƒãƒ¼</span></div>
<div class="line"><span class="keyword">class </span>MLTrainingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;MLTrainingGoal, MLTrainingResult, MLTrainingFeedback&gt; server_;</div>
<div class="line">    std::thread training_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MLTrainingServer() : server_(<span class="stringliteral">&quot;ml_trainer&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        training_thread_ = std::thread(&amp;MLTrainingServer::trainingLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;æ©Ÿæ¢°å­¦ç¿’è¨“ç·´ã‚µãƒ¼ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (training_thread_.joinable()) {</div>
<div class="line">            training_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;æ©Ÿæ¢°å­¦ç¿’è¨“ç·´ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> trainingLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                MLTrainingGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;è¨“ç·´é–‹å§‹: &quot;</span> &lt;&lt; goal.model_type </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ: &quot;</span> &lt;&lt; goal.dataset_path &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// è¨“ç·´ã‚’éåŒæœŸã§å®Ÿè¡Œ</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal]() {</div>
<div class="line">                    trainModel(goal_id, goal);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> trainModel(uint64_t goal_id, <span class="keyword">const</span> MLTrainingGoal&amp; goal) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        MLTrainingResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.epochs_completed = 0;</div>
<div class="line">        result.final_accuracy = 0.0f;</div>
<div class="line">        result.final_loss = std::numeric_limits&lt;float&gt;::max();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿</span></div>
<div class="line">            <span class="keywordflow">if</span> (!loadDataset(goal.dataset_path)) {</div>
<div class="line">                strncpy(result.error_details, <span class="stringliteral">&quot;ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆã®èª­ã¿è¾¼ã¿ã«å¤±æ•—&quot;</span>, 511);</div>
<div class="line">                server_.setAborted(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–</span></div>
<div class="line">            MLModel model = initializeModel(goal.model_type, goal);</div>
<div class="line">            </div>
<div class="line">            MLTrainingFeedback feedback;</div>
<div class="line">            <span class="keywordtype">float</span> best_accuracy = 0.0f;</div>
<div class="line">            <span class="keywordtype">int</span> epochs_without_improvement = 0;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ã‚¨ãƒãƒƒã‚¯ãƒ«ãƒ¼ãƒ—</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> epoch = 0; epoch &lt; goal.epochs; ++epoch) {</div>
<div class="line">                <span class="comment">// ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç¢ºèª</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    strncpy(result.error_details, <span class="stringliteral">&quot;è¨“ç·´ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ&quot;</span>, 511);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> epoch_start = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// è¨“ç·´ãƒ•ã‚§ãƒ¼ã‚º</span></div>
<div class="line">                feedback.current_epoch = epoch + 1;</div>
<div class="line">                feedback.total_epochs = goal.epochs;</div>
<div class="line">                strcpy(feedback.current_phase, <span class="stringliteral">&quot;training&quot;</span>);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordtype">float</span> epoch_loss = 0.0f;</div>
<div class="line">                <span class="keywordtype">float</span> epoch_accuracy = 0.0f;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ãƒãƒƒãƒå‡¦ç†ãƒ«ãƒ¼ãƒ—</span></div>
<div class="line">                <span class="keywordtype">int</span> total_batches = getDatasetSize() / goal.batch_size;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> batch = 0; batch &lt; total_batches; ++batch) {</div>
<div class="line">                    <span class="comment">// ãƒãƒƒãƒãƒ‡ãƒ¼ã‚¿å–å¾—</span></div>
<div class="line">                    <span class="keyword">auto</span> batch_data = getBatch(batch, goal.batch_size);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒ•ã‚©ãƒ¯ãƒ¼ãƒ‰ãƒ‘ã‚¹</span></div>
<div class="line">                    <span class="keyword">auto</span> predictions = model.forward(batch_data.inputs);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// æå¤±è¨ˆç®—</span></div>
<div class="line">                    <span class="keywordtype">float</span> batch_loss = calculateLoss(predictions, batch_data.targets);</div>
<div class="line">                    epoch_loss += batch_loss;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒãƒƒã‚¯ãƒ—ãƒ­ãƒ‘ã‚²ãƒ¼ã‚·ãƒ§ãƒ³</span></div>
<div class="line">                    model.backward(batch_loss, goal.learning_rate);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ç²¾åº¦è¨ˆç®—</span></div>
<div class="line">                    <span class="keywordtype">float</span> batch_accuracy = calculateAccuracy(predictions, batch_data.targets);</div>
<div class="line">                    epoch_accuracy += batch_accuracy;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒãƒƒãƒãƒ¬ãƒ™ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯</span></div>
<div class="line">                    feedback.epoch_progress_percent = (float)(batch + 1) / total_batches * 100.0f;</div>
<div class="line">                    feedback.overall_progress_percent = </div>
<div class="line">                        ((float)epoch + feedback.epoch_progress_percent / 100.0f) / goal.epochs * 100.0f;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                    <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                        current_time - epoch_start);</div>
<div class="line">                    feedback.samples_per_second = (float)(batch + 1) * goal.batch_size / </div>
<div class="line">                                                 (elapsed.count() / 1000.0f);</div>
<div class="line">                    </div>
<div class="line">                    server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// é©åº¦ãªé–“éš”ã§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡ï¼ˆCPUè² è·è»½æ¸›ï¼‰</span></div>
<div class="line">                    <span class="keywordflow">if</span> (batch % 10 == 0) {</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                epoch_loss /= total_batches;</div>
<div class="line">                epoch_accuracy /= total_batches;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// æ¤œè¨¼ãƒ•ã‚§ãƒ¼ã‚º</span></div>
<div class="line">                strcpy(feedback.current_phase, <span class="stringliteral">&quot;validation&quot;</span>);</div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> validation_result = validateModel(model, goal.validation_split);</div>
<div class="line">                </div>
<div class="line">                feedback.current_accuracy = epoch_accuracy;</div>
<div class="line">                feedback.current_loss = epoch_loss;</div>
<div class="line">                feedback.validation_accuracy = validation_result.accuracy;</div>
<div class="line">                feedback.validation_loss = validation_result.loss;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> epoch_end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                feedback.epoch_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    epoch_end - epoch_start).count();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// æ®‹ã‚Šæ™‚é–“æ¨å®š</span></div>
<div class="line">                <span class="keywordflow">if</span> (epoch &gt; 0) {</div>
<div class="line">                    feedback.estimated_remaining_ms = </div>
<div class="line">                        feedback.epoch_time_ms * (goal.epochs - epoch - 1);</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// æ”¹å–„åˆ¤å®š</span></div>
<div class="line">                feedback.is_improving = validation_result.accuracy &gt; best_accuracy;</div>
<div class="line">                <span class="keywordflow">if</span> (feedback.is_improving) {</div>
<div class="line">                    best_accuracy = validation_result.accuracy;</div>
<div class="line">                    epochs_without_improvement = 0;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒ™ã‚¹ãƒˆãƒ¢ãƒ‡ãƒ«ã‚’ä¿å­˜</span></div>
<div class="line">                    saveCheckpoint(model, goal.output_model_path, epoch);</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    epochs_without_improvement++;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// æ—©æœŸåœæ­¢ãƒã‚§ãƒƒã‚¯</span></div>
<div class="line">                <span class="keywordflow">if</span> (goal.early_stopping &amp;&amp; epochs_without_improvement &gt;= 10) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;æ—©æœŸåœæ­¢: &quot;</span> &lt;&lt; epochs_without_improvement </div>
<div class="line">                              &lt;&lt; <span class="stringliteral">&quot; ã‚¨ãƒãƒƒã‚¯æ”¹å–„ãªã—&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                result.epochs_completed = epoch + 1;</div>
<div class="line">                result.final_accuracy = validation_result.accuracy;</div>
<div class="line">                result.final_loss = validation_result.loss;</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¨ãƒãƒƒã‚¯ &quot;</span> &lt;&lt; (epoch + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; goal.epochs </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; - æå¤±: &quot;</span> &lt;&lt; epoch_loss &lt;&lt; <span class="stringliteral">&quot;, ç²¾åº¦: &quot;</span> &lt;&lt; epoch_accuracy</div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, æ¤œè¨¼ç²¾åº¦: &quot;</span> &lt;&lt; validation_result.accuracy &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// æœ€çµ‚çµæœè¨­å®š</span></div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.training_time_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// æœ€çµ‚ãƒ¢ãƒ‡ãƒ«ä¿å­˜</span></div>
<div class="line">            saveModel(model, goal.output_model_path);</div>
<div class="line">            result.model_size_bytes = getFileSize(goal.output_model_path);</div>
<div class="line">            strncpy(result.model_path, goal.output_model_path, 511);</div>
<div class="line">            </div>
<div class="line">            result.validation_accuracy = feedback.validation_accuracy;</div>
<div class="line">            result.validation_loss = feedback.validation_loss;</div>
<div class="line">            result.overfitting_score = calculateOverfittingScore(</div>
<div class="line">                feedback.current_accuracy, feedback.validation_accuracy);</div>
<div class="line">            </div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;è¨“ç·´å®Œäº†: &quot;</span> &lt;&lt; result.training_time_ms / 1000.0f &lt;&lt; <span class="stringliteral">&quot;ç§’, &quot;</span></div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;æœ€çµ‚ç²¾åº¦: &quot;</span> &lt;&lt; result.final_accuracy &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(result.error_details, e.what(), 511);</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;è¨“ç·´ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ç°¡ç•¥åŒ–ã•ã‚ŒãŸMLé–¢æ•°ç¾¤ï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯ã‚ˆã‚Šé«˜åº¦ãªå‡¦ç†ï¼‰</span></div>
<div class="line">    <span class="keywordtype">bool</span> loadDataset(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="comment">// ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆèª­ã¿è¾¼ã¿ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>MLModel {</div>
<div class="line">        <span class="keywordtype">void</span> forward(<span class="keyword">const</span> std::vector&lt;float&gt;&amp; inputs) { <span class="comment">/* ... */</span> }</div>
<div class="line">        <span class="keywordtype">void</span> backward(<span class="keywordtype">float</span> loss, <span class="keywordtype">float</span> learning_rate) { <span class="comment">/* ... */</span> }</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    MLModel initializeModel(<span class="keyword">const</span> std::string&amp; type, <span class="keyword">const</span> MLTrainingGoal&amp; goal) {</div>
<div class="line">        <span class="keywordflow">return</span> MLModel{};</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>ValidationResult {</div>
<div class="line">        <span class="keywordtype">float</span> accuracy;</div>
<div class="line">        <span class="keywordtype">float</span> loss;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    ValidationResult validateModel(<span class="keyword">const</span> MLModel&amp; model, <span class="keywordtype">float</span> validation_split) {</div>
<div class="line">        <span class="comment">// æ¤œè¨¼å‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ©ãƒ³ãƒ€ãƒ ãªçµæœç”Ÿæˆï¼ˆå®Ÿéš›ã®å®Ÿè£…ã§ã¯çœŸã®æ¤œè¨¼ï¼‰</span></div>
<div class="line">        ValidationResult result;</div>
<div class="line">        result.accuracy = 0.7f + (rand() % 300) / 1000.0f;  <span class="comment">// 0.7-1.0</span></div>
<div class="line">        result.loss = 1.0f - result.accuracy + (rand() % 100) / 1000.0f;</div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> saveCheckpoint(<span class="keyword">const</span> MLModel&amp; model, <span class="keyword">const</span> std::string&amp; path, <span class="keywordtype">int</span> epoch) {</div>
<div class="line">        <span class="comment">// ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¿å­˜</span></div>
<div class="line">        std::string checkpoint_path = path + <span class="stringliteral">&quot;_epoch_&quot;</span> + std::to_string(epoch);</div>
<div class="line">        <span class="comment">// å®Ÿéš›ã®ä¿å­˜å‡¦ç†...</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> saveModel(<span class="keyword">const</span> MLModel&amp; model, <span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="comment">// æœ€çµ‚ãƒ¢ãƒ‡ãƒ«ä¿å­˜</span></div>
<div class="line">        <span class="comment">// å®Ÿéš›ã®ä¿å­˜å‡¦ç†...</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">size_t</span> getFileSize(<span class="keyword">const</span> std::string&amp; path) {</div>
<div class="line">        <span class="keywordflow">return</span> 1024 * 1024;  <span class="comment">// 1MBï¼ˆä¾‹ï¼‰</span></div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> calculateOverfittingScore(<span class="keywordtype">float</span> train_acc, <span class="keywordtype">float</span> val_acc) {</div>
<div class="line">        <span class="keywordflow">return</span> std::max(0.0f, train_acc - val_acc);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md232"></a>
ğŸš€ å®Ÿè·µçš„ãªä½¿ç”¨ä¾‹</h1>
<h2><a class="anchor" id="autotoc_md233"></a>
1. å¤§å®¹é‡ãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;queue&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;future&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ‡ãƒ¼ã‚¿å¤‰æ›ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚´ãƒ¼ãƒ«</span></div>
<div class="line"><span class="keyword">struct </span>DataPipelineGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_directory[512];</div>
<div class="line">    <span class="keywordtype">char</span> output_directory[512];</div>
<div class="line">    <span class="keywordtype">char</span> pipeline_config[1024];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è¨­å®š</span></div>
<div class="line">    <span class="keywordtype">int</span> max_parallel_jobs;</div>
<div class="line">    <span class="keywordtype">int</span> batch_size;</div>
<div class="line">    <span class="keywordtype">float</span> quality_threshold;</div>
<div class="line">    <span class="keywordtype">bool</span> skip_existing;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°è¨­å®š</span></div>
<div class="line">    <span class="keywordtype">char</span> file_pattern[128];</div>
<div class="line">    uint64_t min_file_size;</div>
<div class="line">    uint64_t max_file_size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DataPipelineResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint32_t total_files;</div>
<div class="line">    uint32_t processed_files;</div>
<div class="line">    uint32_t failed_files;</div>
<div class="line">    uint32_t skipped_files;</div>
<div class="line">    </div>
<div class="line">    uint64_t total_input_size;</div>
<div class="line">    uint64_t total_output_size;</div>
<div class="line">    uint32_t total_processing_time_ms;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> average_processing_speed_mbps;</div>
<div class="line">    <span class="keywordtype">float</span> overall_compression_ratio;</div>
<div class="line">    <span class="keywordtype">char</span> summary_report[2048];</div>
<div class="line">    <span class="keywordtype">char</span> error_log_path[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DataPipelineFeedback {</div>
<div class="line">    uint32_t current_file_index;</div>
<div class="line">    uint32_t total_files;</div>
<div class="line">    <span class="keywordtype">char</span> current_file_name[256];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// å…¨ä½“é€²æ—</span></div>
<div class="line">    <span class="keywordtype">float</span> overall_progress_percent;</div>
<div class="line">    uint32_t files_completed;</div>
<div class="line">    uint32_t files_failed;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ç¾åœ¨ã®å‡¦ç†</span></div>
<div class="line">    <span class="keywordtype">float</span> current_file_progress;</div>
<div class="line">    <span class="keywordtype">char</span> current_stage[128];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆ</span></div>
<div class="line">    <span class="keywordtype">float</span> current_speed_mbps;</div>
<div class="line">    uint32_t estimated_remaining_ms;</div>
<div class="line">    uint32_t active_workers;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// å“è³ªçµ±è¨ˆ</span></div>
<div class="line">    <span class="keywordtype">float</span> average_quality_score;</div>
<div class="line">    uint32_t quality_failures;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// é«˜åº¦ãªãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³</span></div>
<div class="line"><span class="keyword">class </span>DataPipelineServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;DataPipelineGoal, DataPipelineResult, DataPipelineFeedback&gt; server_;</div>
<div class="line">    std::thread pipeline_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DataPipelineServer() : server_(<span class="stringliteral">&quot;data_pipeline&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        pipeline_thread_ = std::thread(&amp;DataPipelineServer::pipelineLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚µãƒ¼ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (pipeline_thread_.joinable()) {</div>
<div class="line">            pipeline_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> pipelineLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                uint64_t goal_id = server_.acceptGoal();</div>
<div class="line">                DataPipelineGoal goal = server_.getGoal(goal_id);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³é–‹å§‹: &quot;</span> &lt;&lt; goal.input_directory </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; -&gt; &quot;</span> &lt;&lt; goal.output_directory &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Ÿè¡Œã‚’éåŒæœŸã§é–‹å§‹</span></div>
<div class="line">                std::thread worker([<span class="keyword">this</span>, goal_id, goal]() {</div>
<div class="line">                    executePipeline(goal_id, goal);</div>
<div class="line">                });</div>
<div class="line">                worker.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> executePipeline(uint64_t goal_id, <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        DataPipelineResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.total_files = 0;</div>
<div class="line">        result.processed_files = 0;</div>
<div class="line">        result.failed_files = 0;</div>
<div class="line">        result.skipped_files = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«ãƒªã‚¹ãƒˆå–å¾—</span></div>
<div class="line">            std::vector&lt;std::string&gt; file_list = scanDirectory(goal.input_directory, goal);</div>
<div class="line">            result.total_files = file_list.size();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (file_list.empty()) {</div>
<div class="line">                strncpy(result.summary_report, <span class="stringliteral">&quot;å‡¦ç†å¯¾è±¡ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ&quot;</span>, 2047);</div>
<div class="line">                server_.setSucceeded(goal_id, result);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ä¸¦åˆ—å‡¦ç†ã®æº–å‚™</span></div>
<div class="line">            std::vector&lt;std::thread&gt; workers;</div>
<div class="line">            std::queue&lt;std::string&gt; file_queue;</div>
<div class="line">            std::mutex queue_mutex;</div>
<div class="line">            std::atomic&lt;uint32_t&gt; completed_files{0};</div>
<div class="line">            std::atomic&lt;uint32_t&gt; failed_files{0};</div>
<div class="line">            std::atomic&lt;uint64_t&gt; total_input_bytes{0};</div>
<div class="line">            std::atomic&lt;uint64_t&gt; total_output_bytes{0};</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ </span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; file : file_list) {</div>
<div class="line">                file_queue.push(file);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            DataPipelineFeedback feedback;</div>
<div class="line">            feedback.total_files = result.total_files;</div>
<div class="line">            feedback.active_workers = std::min((uint32_t)goal.max_parallel_jobs, result.total_files);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¹ãƒ¬ãƒƒãƒ‰é–‹å§‹</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; goal.max_parallel_jobs &amp;&amp; !file_queue.empty(); ++i) {</div>
<div class="line">                workers.emplace_back([&amp;, i]() {</div>
<div class="line">                    workerFunction(goal_id, goal, file_queue, queue_mutex, </div>
<div class="line">                                 completed_files, failed_files, </div>
<div class="line">                                 total_input_bytes, total_output_bytes, feedback);</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// é€²æ—ç›£è¦–</span></div>
<div class="line">            <span class="keywordflow">while</span> (completed_files + failed_files &lt; result.total_files) {</div>
<div class="line">                <span class="comment">// ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç¢ºèª</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isPreemptRequested(goal_id)) {</div>
<div class="line">                    <span class="comment">// ã™ã¹ã¦ã®ãƒ¯ãƒ¼ã‚«ãƒ¼ã«åœæ­¢ã‚·ã‚°ãƒŠãƒ«é€ä¿¡</span></div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers) {</div>
<div class="line">                        <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                            worker.join();</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    result.processed_files = completed_files;</div>
<div class="line">                    result.failed_files = failed_files;</div>
<div class="line">                    strncpy(result.summary_report, <span class="stringliteral">&quot;å‡¦ç†ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ&quot;</span>, 2047);</div>
<div class="line">                    server_.setPreempted(goal_id, result);</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ›´æ–°</span></div>
<div class="line">                feedback.files_completed = completed_files;</div>
<div class="line">                feedback.files_failed = failed_files;</div>
<div class="line">                feedback.overall_progress_percent = </div>
<div class="line">                    (float)(completed_files + failed_files) / result.total_files * 100.0f;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    current_time - start_time);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (elapsed.count() &gt; 0 &amp;&amp; completed_files &gt; 0) {</div>
<div class="line">                    feedback.current_speed_mbps = </div>
<div class="line">                        (float)total_input_bytes / elapsed.count() / 1024.0f;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (feedback.overall_progress_percent &gt; 0) {</div>
<div class="line">                        feedback.estimated_remaining_ms = </div>
<div class="line">                            elapsed.count() * (100.0f - feedback.overall_progress_percent) / </div>
<div class="line">                            feedback.overall_progress_percent;</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                server_.publishFeedback(goal_id, feedback);</div>
<div class="line">                </div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ¯ãƒ¼ã‚«ãƒ¼çµ‚äº†å¾…ã¡</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; worker : workers) {</div>
<div class="line">                <span class="keywordflow">if</span> (worker.joinable()) {</div>
<div class="line">                    worker.join();</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// æœ€çµ‚çµæœè¨­å®š</span></div>
<div class="line">            result.processed_files = completed_files;</div>
<div class="line">            result.failed_files = failed_files;</div>
<div class="line">            result.total_input_size = total_input_bytes;</div>
<div class="line">            result.total_output_size = total_output_bytes;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">            result.total_processing_time_ms = </div>
<div class="line">                std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    end_time - start_time).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result.total_processing_time_ms &gt; 0) {</div>
<div class="line">                result.average_processing_speed_mbps = </div>
<div class="line">                    (float)result.total_input_size / result.total_processing_time_ms / 1024.0f;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result.total_input_size &gt; 0) {</div>
<div class="line">                result.overall_compression_ratio = </div>
<div class="line">                    (float)result.total_output_size / result.total_input_size;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ã‚µãƒãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ</span></div>
<div class="line">            generateSummaryReport(result, goal);</div>
<div class="line">            </div>
<div class="line">            result.success = (result.failed_files == 0);</div>
<div class="line">            server_.setSucceeded(goal_id, result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å®Œäº†: &quot;</span> &lt;&lt; result.processed_files &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> </div>
<div class="line">                      &lt;&lt; result.total_files &lt;&lt; <span class="stringliteral">&quot; ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            snprintf(result.summary_report, 2047, <span class="stringliteral">&quot;ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: %s&quot;</span>, e.what());</div>
<div class="line">            server_.setAborted(goal_id, result);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> workerFunction(uint64_t goal_id, <span class="keyword">const</span> DataPipelineGoal&amp; goal,</div>
<div class="line">                       std::queue&lt;std::string&gt;&amp; file_queue, std::mutex&amp; queue_mutex,</div>
<div class="line">                       std::atomic&lt;uint32_t&gt;&amp; completed_files, std::atomic&lt;uint32_t&gt;&amp; failed_files,</div>
<div class="line">                       std::atomic&lt;uint64_t&gt;&amp; total_input_bytes, std::atomic&lt;uint64_t&gt;&amp; total_output_bytes,</div>
<div class="line">                       DataPipelineFeedback&amp; feedback) {</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            std::string current_file;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å–å¾—</span></div>
<div class="line">            {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(queue_mutex);</div>
<div class="line">                <span class="keywordflow">if</span> (file_queue.empty()) {</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                }</div>
<div class="line">                current_file = file_queue.front();</div>
<div class="line">                file_queue.pop();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†å®Ÿè¡Œ</span></div>
<div class="line">                <span class="keyword">auto</span> process_result = processFile(current_file, goal);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (process_result.success) {</div>
<div class="line">                    completed_files++;</div>
<div class="line">                    total_input_bytes += process_result.input_size;</div>
<div class="line">                    total_output_bytes += process_result.output_size;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    failed_files++;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// å€‹åˆ¥ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯æ›´æ–°</span></div>
<div class="line">                {</div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(queue_mutex);</div>
<div class="line">                    strncpy(feedback.current_file_name, </div>
<div class="line">                           extractFileName(current_file).c_str(), 255);</div>
<div class="line">                    feedback.current_file_index = completed_files + failed_files;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                failed_files++;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ã‚¨ãƒ©ãƒ¼ (&quot;</span> &lt;&lt; current_file &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> </div>
<div class="line">                          &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">struct </span>FileProcessResult {</div>
<div class="line">        <span class="keywordtype">bool</span> success;</div>
<div class="line">        uint64_t input_size;</div>
<div class="line">        uint64_t output_size;</div>
<div class="line">        uint32_t processing_time_ms;</div>
<div class="line">        <span class="keywordtype">float</span> quality_score;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    FileProcessResult processFile(<span class="keyword">const</span> std::string&amp; file_path, </div>
<div class="line">                                 <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        FileProcessResult result;</div>
<div class="line">        result.success = <span class="keyword">false</span>;</div>
<div class="line">        result.input_size = 0;</div>
<div class="line">        result.output_size = 0;</div>
<div class="line">        result.quality_score = 0.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºå–å¾—</span></div>
<div class="line">        result.input_size = getFileSize(file_path);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// å®Ÿéš›ã®ãƒ•ã‚¡ã‚¤ãƒ«å‡¦ç†ï¼ˆä¾‹ï¼šç”»åƒå¤‰æ›ã€ãƒ‡ãƒ¼ã‚¿åœ§ç¸®ç­‰ï¼‰</span></div>
<div class="line">        std::string output_path = generateOutputPath(file_path, goal.output_directory);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// å‡¦ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50 + rand() % 200));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// å“è³ªãƒã‚§ãƒƒã‚¯</span></div>
<div class="line">        result.quality_score = 0.8f + (rand() % 200) / 1000.0f;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (result.quality_score &gt;= goal.quality_threshold) {</div>
<div class="line">            result.output_size = result.input_size * 0.7f;  <span class="comment">// åœ§ç¸®ä¾‹</span></div>
<div class="line">            result.success = <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        result.processing_time_ms = </div>
<div class="line">            std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(end - start).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;std::string&gt; scanDirectory(<span class="keyword">const</span> std::string&amp; directory, </div>
<div class="line">                                          <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        <span class="comment">// ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªã‚¹ã‚­ãƒ£ãƒ³å®Ÿè£…</span></div>
<div class="line">        std::vector&lt;std::string&gt; files;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ä¾‹ï¼š100ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç”Ÿæˆ</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {</div>
<div class="line">            files.push_back(directory + <span class="stringliteral">&quot;/file_&quot;</span> + std::to_string(i) + <span class="stringliteral">&quot;.dat&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> files;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> generateSummaryReport(DataPipelineResult&amp; result, <span class="keyword">const</span> DataPipelineGoal&amp; goal) {</div>
<div class="line">        snprintf(result.summary_report, 2047,</div>
<div class="line">                <span class="stringliteral">&quot;ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³å‡¦ç†å®Œäº†\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;ç·ãƒ•ã‚¡ã‚¤ãƒ«æ•°: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;æˆåŠŸ: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;å¤±æ•—: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;ã‚¹ã‚­ãƒƒãƒ—: %u\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;å‡¦ç†æ™‚é–“: %.2fç§’\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;å¹³å‡é€Ÿåº¦: %.2f MB/s\n&quot;</span></div>
<div class="line">                <span class="stringliteral">&quot;åœ§ç¸®ç‡: %.2f\n&quot;</span>,</div>
<div class="line">                result.total_files,</div>
<div class="line">                result.processed_files,</div>
<div class="line">                result.failed_files,</div>
<div class="line">                result.skipped_files,</div>
<div class="line">                result.total_processing_time_ms / 1000.0f,</div>
<div class="line">                result.average_processing_speed_mbps,</div>
<div class="line">                result.overall_compression_ratio);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md234"></a>
ğŸ› ï¸ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯</h1>
<h2><a class="anchor" id="autotoc_md235"></a>
1. çŠ¶æ…‹ç®¡ç†ã®æœ€é©åŒ–</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// é«˜åŠ¹ç‡ãªçŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ </span></div>
<div class="line"><span class="keyword">class </span>OptimizedActionStateManager {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>ActionState {</div>
<div class="line">        std::atomic&lt;ActionStatus&gt; status;</div>
<div class="line">        std::atomic&lt;float&gt; progress;</div>
<div class="line">        std::atomic&lt;uint64_t&gt; last_update_time;</div>
<div class="line">        std::string status_text;</div>
<div class="line">        std::mutex text_mutex;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::unordered_map&lt;uint64_t, std::unique_ptr&lt;ActionState&gt;&gt; states_;</div>
<div class="line">    std::shared_mutex states_mutex_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// çŠ¶æ…‹å¤‰æ›´é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ </span></div>
<div class="line">    std::vector&lt;std::function&lt;void(uint64_t, ActionStatus)&gt;&gt; status_callbacks_;</div>
<div class="line">    std::mutex callbacks_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    uint64_t createAction(uint64_t goal_id) {</div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> state = std::make_unique&lt;ActionState&gt;();</div>
<div class="line">        state-&gt;status.store(ActionStatus::PENDING);</div>
<div class="line">        state-&gt;progress.store(0.0f);</div>
<div class="line">        state-&gt;last_update_time.store(getCurrentTimeUs());</div>
<div class="line">        </div>
<div class="line">        states_[goal_id] = std::move(state);</div>
<div class="line">        </div>
<div class="line">        notifyStatusChange(goal_id, ActionStatus::PENDING);</div>
<div class="line">        <span class="keywordflow">return</span> goal_id;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> updateProgress(uint64_t goal_id, <span class="keywordtype">float</span> progress, <span class="keyword">const</span> std::string&amp; text = <span class="stringliteral">&quot;&quot;</span>) {</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != states_.end()) {</div>
<div class="line">            it-&gt;second-&gt;progress.store(progress);</div>
<div class="line">            it-&gt;second-&gt;last_update_time.store(getCurrentTimeUs());</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!text.empty()) {</div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; text_lock(it-&gt;second-&gt;text_mutex);</div>
<div class="line">                it-&gt;second-&gt;status_text = text;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> setStatus(uint64_t goal_id, ActionStatus status) {</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != states_.end()) {</div>
<div class="line">            ActionStatus old_status = it-&gt;second-&gt;status.exchange(status);</div>
<div class="line">            <span class="keywordflow">if</span> (old_status != status) {</div>
<div class="line">                notifyStatusChange(goal_id, status);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ActionStatus getStatus(uint64_t goal_id)<span class="keyword"> const </span>{</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">return</span> (it != states_.end()) ? it-&gt;second-&gt;status.load() : ActionStatus::PENDING;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> getProgress(uint64_t goal_id)<span class="keyword"> const </span>{</div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = states_.find(goal_id);</div>
<div class="line">        <span class="keywordflow">return</span> (it != states_.end()) ? it-&gt;second-&gt;progress.load() : 0.0f;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> addStatusCallback(std::function&lt;<span class="keywordtype">void</span>(uint64_t, ActionStatus)&gt; callback) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(callbacks_mutex_);</div>
<div class="line">        status_callbacks_.push_back(callback);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// å¤ã„çŠ¶æ…‹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—</span></div>
<div class="line">    <span class="keywordtype">void</span> cleanupExpiredStates(uint64_t expiry_time_us) {</div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(states_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> current_time = getCurrentTimeUs();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = states_.begin(); it != states_.end();) {</div>
<div class="line">            <span class="keywordflow">if</span> (current_time - it-&gt;second-&gt;last_update_time.load() &gt; expiry_time_us) {</div>
<div class="line">                it = states_.erase(it);</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                ++it;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> notifyStatusChange(uint64_t goal_id, ActionStatus status) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(callbacks_mutex_);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; callback : status_callbacks_) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                callback(goal_id, status);</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;Status callback error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t getCurrentTimeUs()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now().time_since_epoch()).count();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md236"></a>
2. é«˜æ€§èƒ½ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é…ä¿¡</h2>
<div class="fragment"><div class="line"><span class="comment">// ãƒãƒƒãƒåŒ–ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚·ã‚¹ãƒ†ãƒ </span></div>
<div class="line"><span class="keyword">class </span>BatchedFeedbackSystem {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>FeedbackBatch {</div>
<div class="line">        std::vector&lt;uint64_t&gt; goal_ids;</div>
<div class="line">        std::vector&lt;std::string&gt; feedback_data;</div>
<div class="line">        uint64_t timestamp;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::queue&lt;FeedbackBatch&gt; pending_batches_;</div>
<div class="line">    std::mutex batch_mutex_;</div>
<div class="line">    std::condition_variable batch_cv_;</div>
<div class="line">    std::thread delivery_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// è¨­å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿</span></div>
<div class="line">    <span class="keywordtype">size_t</span> max_batch_size_;</div>
<div class="line">    uint32_t batch_timeout_ms_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    BatchedFeedbackSystem(<span class="keywordtype">size_t</span> max_batch_size = 100, uint32_t batch_timeout_ms = 50)</div>
<div class="line">        : max_batch_size_(max_batch_size), batch_timeout_ms_(batch_timeout_ms), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        delivery_thread_ = std::thread(&amp;BatchedFeedbackSystem::deliveryLoop, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        batch_cv_.notify_all();</div>
<div class="line">        <span class="keywordflow">if</span> (delivery_thread_.joinable()) {</div>
<div class="line">            delivery_thread_.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> addFeedback(uint64_t goal_id, <span class="keyword">const</span> std::string&amp; feedback) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(batch_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ç¾åœ¨ã®ãƒãƒƒãƒã«è¿½åŠ ã¾ãŸã¯æ–°ã—ã„ãƒãƒƒãƒä½œæˆ</span></div>
<div class="line">        <span class="keywordflow">if</span> (pending_batches_.empty() || </div>
<div class="line">            pending_batches_.back().goal_ids.size() &gt;= max_batch_size_) {</div>
<div class="line">            </div>
<div class="line">            FeedbackBatch new_batch;</div>
<div class="line">            new_batch.timestamp = getCurrentTimeMs();</div>
<div class="line">            pending_batches_.push(new_batch);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span>&amp; current_batch = pending_batches_.back();</div>
<div class="line">        current_batch.goal_ids.push_back(goal_id);</div>
<div class="line">        current_batch.feedback_data.push_back(feedback);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒãƒƒãƒãŒæº€æ¯ã«ãªã£ãŸã‚‰å³åº§ã«é…ä¿¡ãƒˆãƒªã‚¬ãƒ¼</span></div>
<div class="line">        <span class="keywordflow">if</span> (current_batch.goal_ids.size() &gt;= max_batch_size_) {</div>
<div class="line">            batch_cv_.notify_one();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> deliveryLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            std::unique_lock&lt;std::mutex&gt; lock(batch_mutex_);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ãŸã¯æ–°ã—ã„ãƒãƒƒãƒå¾…æ©Ÿ</span></div>
<div class="line">            batch_cv_.wait_for(lock, std::chrono::milliseconds(batch_timeout_ms_),</div>
<div class="line">                              [<span class="keyword">this</span>] { <span class="keywordflow">return</span> !pending_batches_.empty() || !running_; });</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!running_) <span class="keywordflow">break</span>;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// é…ä¿¡å¯¾è±¡ãƒãƒƒãƒã®åé›†</span></div>
<div class="line">            std::vector&lt;FeedbackBatch&gt; batches_to_deliver;</div>
<div class="line">            uint64_t current_time = getCurrentTimeMs();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (!pending_batches_.empty()) {</div>
<div class="line">                <span class="keyword">auto</span>&amp; batch = pending_batches_.front();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã¾ãŸã¯ã‚µã‚¤ã‚ºæ¡ä»¶ã§é…ä¿¡</span></div>
<div class="line">                <span class="keywordflow">if</span> (batch.goal_ids.size() &gt;= max_batch_size_ ||</div>
<div class="line">                    (current_time - batch.timestamp) &gt;= batch_timeout_ms_) {</div>
<div class="line">                    </div>
<div class="line">                    batches_to_deliver.push_back(std::move(batch));</div>
<div class="line">                    pending_batches_.pop();</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    <span class="keywordflow">break</span>;  <span class="comment">// ã¾ã é…ä¿¡æ™‚æœŸã§ã¯ãªã„</span></div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            lock.unlock();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ãƒãƒƒãƒé…ä¿¡å®Ÿè¡Œ</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; batch : batches_to_deliver) {</div>
<div class="line">                deliverBatch(batch);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> deliverBatch(<span class="keyword">const</span> FeedbackBatch&amp; batch) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// å®Ÿéš›ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é…ä¿¡å‡¦ç†</span></div>
<div class="line">            <span class="comment">// å…±æœ‰ãƒ¡ãƒ¢ãƒªã¸ã®ä¸€æ‹¬æ›¸ãè¾¼ã¿ç­‰</span></div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒãƒƒãƒé…ä¿¡: &quot;</span> &lt;&lt; batch.goal_ids.size() </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; items&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                      </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;Feedback delivery error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t getCurrentTimeMs()<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now().time_since_epoch()).count();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md237"></a>
ğŸ“Š ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šã¨ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</h1>
<h2><a class="anchor" id="autotoc_md238"></a>
è©³ç´°ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ActionPerformanceBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>BenchmarkResult {</div>
<div class="line">        std::vector&lt;double&gt; goal_submission_times;</div>
<div class="line">        std::vector&lt;double&gt; feedback_latencies;</div>
<div class="line">        std::vector&lt;double&gt; completion_times;</div>
<div class="line">        std::vector&lt;double&gt; throughput_measurements;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    BenchmarkResult results_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> runActionBenchmark() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== Actioné€šä¿¡ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯é–‹å§‹ ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 1. ã‚´ãƒ¼ãƒ«é€ä¿¡ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        measureGoalSubmissionLatency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é…ä¿¡ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        measureFeedbackLatency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. é•·æ™‚é–“ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        measureLongRunningActionThroughput();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 4. ä¸¦åˆ—ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†ãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        measureConcurrentActionProcessing();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 5. ãƒ¡ãƒ¢ãƒªåŠ¹ç‡ãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        measureMemoryEfficiency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// çµæœè§£æ</span></div>
<div class="line">        analyzeResults();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> measureGoalSubmissionLatency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚´ãƒ¼ãƒ«é€ä¿¡ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·æ¸¬å®šä¸­...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚µãƒ¼ãƒãƒ¼å´ã‚¹ãƒ¬ãƒƒãƒ‰</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// å³åº§ã«å®Œäº†</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal * 2);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        results_.goal_submission_times.clear();</div>
<div class="line">        results_.goal_submission_times.reserve(1000);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´æ¸¬å®š</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            uint64_t goal_id = client.sendGoal(i);</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            results_.goal_submission_times.push_back(duration);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// å®Œäº†å¾…ã¡</span></div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureFeedbackLatency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·æ¸¬å®šä¸­...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;feedback_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;feedback_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;bool&gt; measurement_complete{<span class="keyword">false</span>};</div>
<div class="line">        results_.feedback_latencies.clear();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚µãƒ¼ãƒãƒ¼å´ã‚¹ãƒ¬ãƒƒãƒ‰</span></div>
<div class="line">        std::thread server_thread([&amp;]() {</div>
<div class="line">            <span class="keywordflow">while</span> (!measurement_complete) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// å®šæœŸçš„ã«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡</span></div>
<div class="line">                    for (int i = 0; i &lt; 100; ++i) {</div>
<div class="line">                        auto start = std::chrono::high_resolution_clock::now();</div>
<div class="line">                        </div>
<div class="line">                        server.publishFeedback(goal_id, (float)i);</div>
<div class="line">                        </div>
<div class="line">                        auto end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                        auto duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                            end - start).count();</div>
<div class="line">                        </div>
<div class="line">                        {</div>
<div class="line">                            static std::mutex latency_mutex;</div>
<div class="line">                            std::lock_guard&lt;std::mutex&gt; lock(latency_mutex);</div>
<div class="line">                            results_.feedback_latencies.push_back(duration);</div>
<div class="line">                        }</div>
<div class="line">                        </div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    server.setSucceeded(goal_id, 100);</div>
<div class="line">                    measurement_complete = <span class="keyword">true</span>;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡</span></div>
<div class="line">        uint64_t goal_id = client.sendGoal(1);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">            <span class="keywordtype">float</span> feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">                <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡æ™‚åˆ»ã‚’è¨˜éŒ²ï¼ˆç°¡ç•¥åŒ–ï¼‰</span></div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureLongRunningActionThroughput() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;é•·æ™‚é–“ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆæ¸¬å®šä¸­...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_ACTIONS = 50;</div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> ACTION_DURATION_MS = 200;</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;int&gt; completed_actions{0};</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚µãƒ¼ãƒãƒ¼å´ã‚¹ãƒ¬ãƒƒãƒ‰</span></div>
<div class="line">        std::thread server_thread([&amp;]() {</div>
<div class="line">            <span class="keywordflow">while</span> (completed_actions &lt; NUM_ACTIONS) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// é•·æ™‚é–“å‡¦ç†ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ</span></div>
<div class="line">                    std::thread([&amp;, goal_id, goal]() {</div>
<div class="line">                        for (int i = 0; i &lt; 10; ++i) {</div>
<div class="line">                            server.publishFeedback(goal_id, (float)i * 10.0f);</div>
<div class="line">                            std::this_thread::sleep_for(</div>
<div class="line">                                std::chrono::milliseconds(ACTION_DURATION_MS / 10));</div>
<div class="line">                        }</div>
<div class="line">                        </div>
<div class="line">                        server.setSucceeded(goal_id, goal);</div>
<div class="line">                        completed_actions++;</div>
<div class="line">                    }).detach();</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// è¤‡æ•°ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¸¦åˆ—é€ä¿¡</span></div>
<div class="line">        std::vector&lt;uint64_t&gt; goal_ids;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; NUM_ACTIONS; ++i) {</div>
<div class="line">            goal_ids.push_back(client.sendGoal(i));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã™ã¹ã¦ã®å®Œäº†ã‚’å¾…æ©Ÿ</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint64_t goal_id : goal_ids) {</div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">auto</span> total_duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end_time - start_time);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> throughput = (double)NUM_ACTIONS / total_duration.count() * 1000.0;  <span class="comment">// actions/sec</span></div>
<div class="line">        results_.throughput_measurements.push_back(throughput);</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: &quot;</span> &lt;&lt; throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureConcurrentActionProcessing() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ä¸¦åˆ—ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å‡¦ç†æ€§èƒ½æ¸¬å®šä¸­...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;concurrent_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; client_counts = {1, 2, 4, 8, 16};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> client_count : client_counts) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            std::atomic&lt;int&gt; completed{0};</div>
<div class="line">            std::vector&lt;std::thread&gt; client_threads;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ã‚µãƒ¼ãƒãƒ¼å´ã‚¹ãƒ¬ãƒƒãƒ‰</span></div>
<div class="line">            std::thread server_thread([&amp;]() {</div>
<div class="line">                <span class="keywordflow">while</span> (completed &lt; client_count * 10) {</div>
<div class="line">                    <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                        uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                        int goal = server.getGoal(goal_id);</div>
<div class="line">                        </div>
<div class="line">                        <span class="comment">// è»½ã„å‡¦ç†</span></div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">                        server.setSucceeded(goal_id, goal);</div>
<div class="line">                        completed++;</div>
<div class="line">                    }</div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">                }</div>
<div class="line">            });</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// è¤‡æ•°ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; client_count; ++i) {</div>
<div class="line">                client_threads.emplace_back([i]() {</div>
<div class="line">                    ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;concurrent_test&quot;</span>);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 10; ++j) {</div>
<div class="line">                        uint64_t goal_id = client.sendGoal(i * 10 + j);</div>
<div class="line">                        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                            std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : client_threads) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            server_thread.join();</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> concurrent_throughput = (double)(client_count * 10) / duration * 1000.0;</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;åŒæ™‚ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆæ•° &quot;</span> &lt;&lt; client_count &lt;&lt; <span class="stringliteral">&quot;: &quot;</span></div>
<div class="line">                      &lt;&lt; concurrent_throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureMemoryEfficiency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ¡ãƒ¢ãƒªåŠ¹ç‡æ¸¬å®šä¸­...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¸¬å®šã®å®Ÿè£…ã¯ç’°å¢ƒä¾å­˜</span></div>
<div class="line">        <span class="comment">// ã“ã“ã§ã¯æ¦‚å¿µçš„ãªæ¸¬å®šã‚’ç¤ºã™</span></div>
<div class="line">        </div>
<div class="line">        ActionServer&lt;std::vector&lt;char&gt;, std::vector&lt;char&gt;, <span class="keywordtype">float</span>&gt; server(<span class="stringliteral">&quot;memory_test&quot;</span>);</div>
<div class="line">        ActionClient&lt;std::vector&lt;char&gt;, std::vector&lt;char&gt;, <span class="keywordtype">float</span>&gt; client(<span class="stringliteral">&quot;memory_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;size_t&gt; data_sizes = {1024, 10240, 102400, 1048576};  <span class="comment">// 1KB to 1MB</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> size : data_sizes) {</div>
<div class="line">            std::vector&lt;char&gt; large_data(size, <span class="charliteral">&#39;X&#39;</span>);</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            uint64_t goal_id = client.sendGoal(large_data);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ã‚µãƒ¼ãƒãƒ¼å´ã§å‡¦ç†</span></div>
<div class="line">            std::thread([&amp;]() {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    auto goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒ‡ãƒ¼ã‚¿ã‚’ãã®ã¾ã¾è¿”ã™</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal);</div>
<div class="line">                }</div>
<div class="line">            }).detach();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> bandwidth = (double)size / duration;  <span class="comment">// bytes/Î¼s = MB/s</span></div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ãƒ‡ãƒ¼ã‚¿ã‚µã‚¤ã‚º &quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot; bytes: &quot;</span></div>
<div class="line">                      &lt;&lt; bandwidth &lt;&lt; <span class="stringliteral">&quot; MB/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> analyzeResults() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n=== ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯çµæœè§£æ ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚´ãƒ¼ãƒ«é€ä¿¡ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·è§£æ</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.goal_submission_times.empty()) {</div>
<div class="line">            analyzeLatencyVector(results_.goal_submission_times, <span class="stringliteral">&quot;ã‚´ãƒ¼ãƒ«é€ä¿¡ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·è§£æ</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.feedback_latencies.empty()) {</div>
<div class="line">            analyzeLatencyVector(results_.feedback_latencies, <span class="stringliteral">&quot;ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆè§£æ</span></div>
<div class="line">        <span class="keywordflow">if</span> (!results_.throughput_measurements.empty()) {</div>
<div class="line">            <span class="keywordtype">double</span> avg_throughput = std::accumulate(</div>
<div class="line">                results_.throughput_measurements.begin(),</div>
<div class="line">                results_.throughput_measurements.end(), 0.0) / </div>
<div class="line">                results_.throughput_measurements.size();</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;å¹³å‡ã‚¹ãƒ«ãƒ¼ãƒ—ãƒƒãƒˆ: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(2)</div>
<div class="line">                      &lt;&lt; avg_throughput &lt;&lt; <span class="stringliteral">&quot; actions/sec&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> analyzeLatencyVector(<span class="keyword">const</span> std::vector&lt;double&gt;&amp; latencies, <span class="keyword">const</span> std::string&amp; name) {</div>
<div class="line">        <span class="keyword">auto</span> sorted_latencies = latencies;</div>
<div class="line">        std::sort(sorted_latencies.begin(), sorted_latencies.end());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> mean = std::accumulate(latencies.begin(), latencies.end(), 0.0) / latencies.size();</div>
<div class="line">        <span class="keywordtype">double</span> min_val = sorted_latencies.front();</div>
<div class="line">        <span class="keywordtype">double</span> max_val = sorted_latencies.back();</div>
<div class="line">        <span class="keywordtype">double</span> p50 = sorted_latencies[sorted_latencies.size() * 0.5];</div>
<div class="line">        <span class="keywordtype">double</span> p95 = sorted_latencies[sorted_latencies.size() * 0.95];</div>
<div class="line">        <span class="keywordtype">double</span> p99 = sorted_latencies[sorted_latencies.size() * 0.99];</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; (Î¼s):&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  å¹³å‡: &quot;</span> &lt;&lt; mean &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  æœ€å°: &quot;</span> &lt;&lt; min_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  æœ€å¤§: &quot;</span> &lt;&lt; max_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  50%ile: &quot;</span> &lt;&lt; p50 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  95%ile: &quot;</span> &lt;&lt; p95 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  99%ile: &quot;</span> &lt;&lt; p99 &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (p99 &lt; 1000.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  ğŸ† å„ªç§€: 99%ã®ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãŒ1msä»¥ä¸‹&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p99 &lt; 10000.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  ğŸ‘ è‰¯å¥½: 99%ã®ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãŒ10msä»¥ä¸‹&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  âš ï¸  è¦æ”¹å–„: ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãŒé«˜ã‚ã§ã™&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯å®Ÿè¡Œ</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        ActionPerformanceBenchmark benchmark;</div>
<div class="line">        benchmark.runActionBenchmark();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ãƒ™ãƒ³ãƒãƒãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md239"></a>
â“ ã‚ˆãã‚ã‚‹è³ªå•</h1>
<h2><a class="anchor" id="autotoc_md240"></a>
Q1. ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå®Œäº†ã—ãªã„å ´åˆã¯ã©ã†ã™ã‚Œã°ã‚ˆã„ã§ã™ã‹ï¼Ÿ</h2>
<p><b>A</b>: ä»¥ä¸‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ãã ã•ã„ï¼š</p><ul>
<li>ã‚µãƒ¼ãƒãƒ¼ãŒæ­£ã—ãå‹•ä½œã—ã€ã‚´ãƒ¼ãƒ«ã‚’å—ã‘ä»˜ã‘ã¦ã„ã‚‹ã‹</li>
<li>ã‚µãƒ¼ãƒãƒ¼å´ã§ä¾‹å¤–ã‚„ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ãŒç™ºç”Ÿã—ã¦ã„ãªã„ã‹</li>
<li>ã‚¢ã‚¯ã‚·ãƒ§ãƒ³å†…ã§ã‚­ãƒ£ãƒ³ã‚»ãƒ«ç¢ºèªã‚’å®šæœŸçš„ã«è¡Œã£ã¦ã„ã‚‹ã‹</li>
<li>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®šãŒé©åˆ‡ã‹</li>
</ul>
<h2><a class="anchor" id="autotoc_md241"></a>
Q2. ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ãŒå±Šã‹ãªã„å ´åˆã®åŸå› ã¯ï¼Ÿ</h2>
<p><b>A</b>: è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ï¼š</p><ul>
<li>ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡é–“éš”ãŒçŸ­ã™ãã‚‹ï¼ˆãƒãƒƒãƒ•ã‚¡ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ï¼‰</li>
<li>å…±æœ‰ãƒ¡ãƒ¢ãƒªã®ã‚µã‚¤ã‚ºä¸è¶³</li>
<li>ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯èª­ã¿å–ã‚ŠãŒé…ã„</li>
<li>ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯é…å»¶ï¼ˆãƒªãƒ¢ãƒ¼ãƒˆä½¿ç”¨æ™‚ï¼‰</li>
</ul>
<h2><a class="anchor" id="autotoc_md242"></a>
Q3. é•·æ™‚é–“ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®é€”ä¸­ã§ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã—ãŸå ´åˆã¯ï¼Ÿ</h2>
<p><b>A</b>: Actioné€šä¿¡ã§ã¯ä»¥ä¸‹ã®å¯¾ç­–ãŒã‚ã‚Šã¾ã™ï¼š</p><ul>
<li><b>ãƒã‚§ãƒƒã‚¯ãƒã‚¤ãƒ³ãƒˆä¿å­˜</b>: å®šæœŸçš„ã«é€²æ—ã‚’æ°¸ç¶šåŒ–</li>
<li><b>å†é–‹æ©Ÿèƒ½</b>: ä¸­æ–­ç‚¹ã‹ã‚‰ã®å¾©æ—§æ©Ÿèƒ½</li>
<li><b>çŠ¶æ…‹ç›£è¦–</b>: åˆ¥ãƒ—ãƒ­ã‚»ã‚¹ã§ã‚¢ã‚¯ã‚·ãƒ§ãƒ³çŠ¶æ…‹ã‚’ç›£è¦–</li>
<li><b>ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¨­å®š</b>: ç„¡å¿œç­”çŠ¶æ…‹ã®è‡ªå‹•æ¤œå‡º</li>
</ul>
<h2><a class="anchor" id="autotoc_md243"></a>
Q4. è¤‡æ•°ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä¸¦åˆ—å®Ÿè¡Œã™ã‚‹éš›ã®æ³¨æ„ç‚¹ã¯ï¼Ÿ</h2>
<p><b>A</b>: ä»¥ä¸‹ã«æ³¨æ„ã—ã¦ãã ã•ã„ï¼š</p><ul>
<li><b>ãƒªã‚½ãƒ¼ã‚¹ç«¶åˆ</b>: ãƒ•ã‚¡ã‚¤ãƒ«ã‚„ãƒ‡ãƒã‚¤ã‚¹ã®æ’ä»–åˆ¶å¾¡</li>
<li><b>ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡</b>: å„ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒ¡ãƒ¢ãƒªæ¶ˆè²»é‡ã‚’è€ƒæ…®</li>
<li><b>CPUè² è·</b>: é©åˆ‡ãªãƒ¯ãƒ¼ã‚«ãƒ¼æ•°ã®è¨­å®š</li>
<li><b>å„ªå…ˆåº¦åˆ¶å¾¡</b>: é‡è¦ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®å„ªå…ˆå®Ÿè¡Œ</li>
</ul>
<h1><a class="anchor" id="autotoc_md244"></a>
ğŸ”§ ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</h1>
<h2><a class="anchor" id="autotoc_md245"></a>
ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•</h2>
<div class="fragment"><div class="line"><span class="comment">// Actioné€šä¿¡è¨ºæ–­ãƒ„ãƒ¼ãƒ«</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> diagnose_action_communication() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;=== Actioné€šä¿¡è¨ºæ–­ ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// 1. ã‚µãƒ¼ãƒãƒ¼ä½œæˆãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        ActionServer&lt;int, int, float&gt; server(<span class="stringliteral">&quot;diagnostic_action&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… ã‚µãƒ¼ãƒãƒ¼ä½œæˆæˆåŠŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä½œæˆãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        ActionClient&lt;int, int, float&gt; client(<span class="stringliteral">&quot;diagnostic_action&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆä½œæˆæˆåŠŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. é€šä¿¡ãƒ†ã‚¹ãƒˆ</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordtype">int</span> test_count = 0;</div>
<div class="line">            <span class="keywordflow">while</span> (test_count &lt; 3) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasGoal()) {</div>
<div class="line">                    uint64_t goal_id = server.acceptGoal();</div>
<div class="line">                    int goal = server.getGoal(goal_id);</div>
<div class="line">                    </div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚µãƒ¼ãƒãƒ¼: ã‚´ãƒ¼ãƒ«å—ä¿¡ &quot;</span> &lt;&lt; goal &lt;&lt; std::endl;</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡</span></div>
<div class="line">                    for (int i = 0; i &lt; 5; ++i) {</div>
<div class="line">                        server.publishFeedback(goal_id, (float)i * 20.0f);</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚µãƒ¼ãƒãƒ¼: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯é€ä¿¡ &quot;</span> &lt;&lt; (i * 20) &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// çµæœé€ä¿¡</span></div>
<div class="line">                    server.setSucceeded(goal_id, goal * 2);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚µãƒ¼ãƒãƒ¼: çµæœé€ä¿¡ &quot;</span> &lt;&lt; (goal * 2) &lt;&lt; std::endl;</div>
<div class="line">                    test_count++;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ã‚´ãƒ¼ãƒ«é€ä¿¡</span></div>
<div class="line">        uint64_t goal_id = client.sendGoal(21);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ: ã‚´ãƒ¼ãƒ«é€ä¿¡ 21&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ç›£è¦–</span></div>
<div class="line">        <span class="keywordtype">bool</span> feedback_received = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">            <span class="keywordtype">float</span> feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ: ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡ &quot;</span> &lt;&lt; feedback &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                feedback_received = <span class="keyword">true</span>;</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// çµæœç¢ºèª</span></div>
<div class="line">        <span class="keywordflow">if</span> (client.getState(goal_id) == ActionStatus::SUCCEEDED) {</div>
<div class="line">            <span class="keywordtype">int</span> result = client.getResult(goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ: çµæœå—ä¿¡ &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (result == 42 &amp;&amp; feedback_received) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… é€šä¿¡ãƒ†ã‚¹ãƒˆæˆåŠŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ é€šä¿¡ãƒ†ã‚¹ãƒˆå¤±æ•—: æœŸå¾…å€¤42ã€å®Ÿéš›å€¤&quot;</span> &lt;&lt; result </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯å—ä¿¡: &quot;</span> &lt;&lt; (feedback_received ? <span class="stringliteral">&quot;â—‹&quot;</span> : <span class="stringliteral">&quot;Ã—&quot;</span>) &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ é€šä¿¡ãƒ†ã‚¹ãƒˆå¤±æ•—: ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå¤±æ•—&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ è¨ºæ–­ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ä»¥ä¸‹ã‚’ç¢ºèªã—ã¦ãã ã•ã„:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - å…±æœ‰ãƒ¡ãƒ¢ãƒªã®æ¨©é™è¨­å®š&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - ä»–ã®ãƒ—ãƒ­ã‚»ã‚¹ãŒã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ä¸­ã§ãªã„ã‹&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ã®ä¸è¶³&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - ãƒ¡ãƒ¢ãƒªã‚µã‚¤ã‚ºã®è¨­å®š&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// å …ç‰¢ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ä¾‹</span></div>
<div class="line"><span class="keyword">class </span>RobustActionClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionClient&lt;GoalType, ResultType, FeedbackType&gt; client_;</div>
<div class="line">    std::string action_name_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RobustActionClient(<span class="keyword">const</span> std::string&amp; action_name) </div>
<div class="line">        : client_(action_name), action_name_(action_name) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> executeGoalWithRetry(<span class="keyword">const</span> GoalType&amp; goal, ResultType&amp; result, </div>
<div class="line">                             <span class="keywordtype">int</span> max_retries = 3, <span class="keywordtype">int</span> timeout_ms = 30000) {</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> retry = 0; retry &lt; max_retries; ++retry) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚´ãƒ¼ãƒ«å®Ÿè¡Œ (è©¦è¡Œ &quot;</span> &lt;&lt; (retry + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; max_retries &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                uint64_t goal_id = client_.sendGoal(goal);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆä»˜ãå®Œäº†å¾…æ©Ÿ</span></div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">while</span> (!client_.isComplete(goal_id)) {</div>
<div class="line">                    <span class="keyword">auto</span> current_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                    <span class="keyword">auto</span> elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                        current_time - start_time);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (elapsed.count() &gt; timeout_ms) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ: ã‚´ãƒ¼ãƒ«ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã™...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        client_.cancelGoal(goal_id);</div>
<div class="line">                        <span class="keywordflow">break</span>;</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤º</span></div>
<div class="line">                    FeedbackType feedback;</div>
<div class="line">                    <span class="keywordflow">if</span> (client_.getFeedback(goal_id, feedback)) {</div>
<div class="line">                        displayFeedback(feedback);</div>
<div class="line">                    }</div>
<div class="line">                    </div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// çµæœç¢ºèª</span></div>
<div class="line">                ActionStatus status = client_.getState(goal_id);</div>
<div class="line">                <span class="keywordflow">if</span> (status == ActionStatus::SUCCEEDED) {</div>
<div class="line">                    result = client_.getResult(goal_id);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;æˆåŠŸ: ã‚´ãƒ¼ãƒ«å®Œäº†&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;å¤±æ•—: &quot;</span> &lt;&lt; actionStatusToString(status) &lt;&lt; std::endl;</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">if</span> (retry &lt; max_retries - 1) {</div>
<div class="line">                        std::cout &lt;&lt; <span class="stringliteral">&quot;å†è©¦è¡Œã—ã¾ã™...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ã‚¨ãƒ©ãƒ¼: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (retry &lt; max_retries - 1) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;å†è©¦è¡Œã—ã¾ã™...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;æœ€å¤§å†è©¦è¡Œå›æ•°ã«é”ã—ã¾ã—ãŸ&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    <span class="keywordflow">throw</span>;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> displayFeedback(<span class="keyword">const</span> FeedbackType&amp; feedback) {</div>
<div class="line">        <span class="comment">// ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯è¡¨ç¤ºã®å®Ÿè£…</span></div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;é€²æ—æ›´æ–°...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::string actionStatusToString(ActionStatus status) {</div>
<div class="line">        <span class="keywordflow">switch</span> (status) {</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::PENDING: <span class="keywordflow">return</span> <span class="stringliteral">&quot;å¾…æ©Ÿä¸­&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::ACTIVE: <span class="keywordflow">return</span> <span class="stringliteral">&quot;å®Ÿè¡Œä¸­&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::PREEMPTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;ä¸­æ–­&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::SUCCEEDED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;æˆåŠŸ&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::ABORTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;ç•°å¸¸çµ‚äº†&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::REJECTED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;æ‹’å¦&quot;</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionStatus::RECALLED: <span class="keywordflow">return</span> <span class="stringliteral">&quot;å–ã‚Šæ¶ˆã—&quot;</span>;</div>
<div class="line">            <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="stringliteral">&quot;ä¸æ˜&quot;</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md246"></a>
ğŸ“š æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—</h1>
<p>Actioné€šä¿¡ã‚’ãƒã‚¹ã‚¿ãƒ¼ã—ãŸã‚‰ã€ä»¥ä¸‹ã®é«˜åº¦ãªãƒˆãƒ”ãƒƒã‚¯ã«æŒ‘æˆ¦ã—ã¦ã¿ã¾ã—ã‚‡ã†ï¼š</p>
<ol type="1">
<li><b><a class="el" href="md_manual_tutorials_shm_pub_sub_jp.html">ğŸ“¡ Pub/Subé€šä¿¡</a></b> - é«˜é€Ÿãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆé€šä¿¡</li>
<li><b><a class="el" href="md_manual_tutorials_shm_service_jp.html">ğŸ¤ Serviceé€šä¿¡</a></b> - ç¢ºå®Ÿãªè¦æ±‚å¿œç­”é€šä¿¡</li>
<li><b><a class="el" href="md_manual_tutorials_python_jp.html">ğŸ Pythoné€£æº</a></b> - Pythonã§Actioné€šä¿¡</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md248"></a>
ğŸ“„ ãƒ©ã‚¤ã‚»ãƒ³ã‚¹æƒ…å ±</h1>
<p>æœ¬ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã§ç´¹ä»‹ã—ã¦ã„ã‚‹ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã¯ã€shared-memory-based-handy-communication-manager ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¸€éƒ¨ã¨ã—ã¦ <b>Apache License 2.0</b> ã®ä¸‹ã§æä¾›ã•ã‚Œã¦ã„ã¾ã™ã€‚</p>
<ul>
<li>âœ… <b>å•†ç”¨åˆ©ç”¨å¯èƒ½</b>: ã‚µãƒ³ãƒ—ãƒ«ã‚³ãƒ¼ãƒ‰ã‚’å•†æ¥­ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§è‡ªç”±ã«ä½¿ç”¨</li>
<li>âœ… <b>æ”¹å¤‰å¯èƒ½</b>: ãƒ‹ãƒ¼ã‚ºã«åˆã‚ã›ã¦ã‚³ãƒ¼ãƒ‰ã‚’ä¿®æ­£ãƒ»æ‹¡å¼µ</li>
<li>âœ… <b>å†é…å¸ƒå¯èƒ½</b>: ãƒ©ã‚¤ã‚»ãƒ³ã‚¹è¡¨ç¤ºã‚’ä¿æŒã—ã¦å†é…å¸ƒ</li>
</ul>
<p>è©³ç´°ã¯<a href="../LICENSE">LICENSEãƒ•ã‚¡ã‚¤ãƒ«</a>ã‚’ã”ç¢ºèªãã ã•ã„ã€‚</p>
<hr  />
<p>ã“ã®å®Œå…¨ã‚¬ã‚¤ãƒ‰ã§ã€Actioné€šä¿¡ã®çœŸã®åŠ›ã‚’å¼•ãå‡ºã—ã€æ¬¡ä¸–ä»£ã®é«˜åº¦ãªéåŒæœŸå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã—ã‚‡ã†ï¼ ğŸš€âœ¨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 5 2025 13:54:48 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
