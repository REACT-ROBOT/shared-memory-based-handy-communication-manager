<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: 📡 Pub/Sub通信完全ガイド - 超高速ブロードキャスト通信をマスターしよう</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">共有メモリを用いた高速で扱いやすいプロセス間通信マネージャ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">📡 Pub/Sub通信完全ガイド - 超高速ブロードキャスト通信をマスターしよう </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../md_manual_tutorials_shm_pub_sub_en.html">English</a> | 日本語]</p>
<h1><a class="anchor" id="autotoc_md251"></a>
🎯 このガイドで学べること</h1>
<ul>
<li><b>Pub/Sub通信の深い理解</b>: 設計思想から実装詳細まで</li>
<li><b>高頻度通信の実現</b>: 1kHz以上のリアルタイム通信</li>
<li><b>メモリ効率化</b>: 大容量データの高速転送テクニック</li>
<li><b>実践的な応用例</b>: ロボット制御、画像処理、センサーネットワーク</li>
</ul>
<h1><a class="anchor" id="autotoc_md252"></a>
🧠 Pub/Sub通信の深い理解</h1>
<h2><a class="anchor" id="autotoc_md253"></a>
🏗️ アーキテクチャ解説</h2>
<div class="fragment"><div class="line"><span class="comment">// 内部構造の概念図</span></div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                   共有メモリ空間                              │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              リングバッファ                          │    │</div>
<div class="line">│  │ [Data 0][Data 1][Data 2]...[Data N-1]              │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  読取位置                    書込位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  ヘッダー情報:                                               │</div>
<div class="line">│  - シーケンス番号 (データの順序管理)                          │</div>
<div class="line">│  - タイムスタンプ (データの新鮮度)                           │</div>
<div class="line">│  - データサイズ (可変長データ対応)                           │</div>
<div class="line">│  - CRC32チェック (データ整合性)                              │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Multiple Subscribers ← [shared memory] ← Single Publisher</div>
<div class="line">      │                                        │</div>
<div class="line">   受信プロセス1                           送信プロセス</div>
<div class="line">   受信プロセス2                              │</div>
<div class="line">   受信プロセス3                        ゼロコピー高速書込</div>
<div class="line">      │</div>
<div class="line">   並列データ処理</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md254"></a>
⚡ なぜ超高速なのか？</h2>
<p><b>1. ゼロコピー設計</b> </p><div class="fragment"><div class="line"><span class="comment">// ❌ 従来の方法: データコピーが発生</span></div>
<div class="line"><span class="keywordtype">char</span> buffer[1024];</div>
<div class="line">read(socket_fd, buffer, 1024);    <span class="comment">// カーネル→ユーザー空間コピー</span></div>
<div class="line">memcpy(data_ptr, buffer, 1024);   <span class="comment">// バッファ→データ構造コピー</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ✅ 共有メモリ: 直接アクセス</span></div>
<div class="line">Publisher&lt;SensorData&gt; pub(<span class="stringliteral">&quot;sensors&quot;</span>);</div>
<div class="line">pub.publish(sensor_data);  <span class="comment">// メモリに直接書込、コピーなし</span></div>
</div><!-- fragment --><p><b>2. 効率的なリングバッファ</b> </p><div class="fragment"><div class="line"><span class="comment">// リングバッファの利点</span></div>
<div class="line"><span class="keyword">class </span>RingBuffer {</div>
<div class="line">    atomic&lt;size_t&gt; write_index;  <span class="comment">// 原子操作で高速</span></div>
<div class="line">    atomic&lt;size_t&gt; read_index;   <span class="comment">// ロックフリー設計</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 書込み: O(1)の一定時間</span></div>
<div class="line">    <span class="keywordtype">bool</span> write(<span class="keyword">const</span> T&amp; data) {</div>
<div class="line">        <span class="keywordtype">size_t</span> next = (write_index + 1) % buffer_size;</div>
<div class="line">        <span class="keywordflow">if</span> (next != read_index) {  <span class="comment">// オーバーフロー検出</span></div>
<div class="line">            buffer[write_index] = data;</div>
<div class="line">            write_index = next;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;  <span class="comment">// バッファフル</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>3. CPUキャッシュ最適化</b> </p><div class="fragment"><div class="line"><span class="comment">// メモリアクセスパターンの最適化</span></div>
<div class="line"><span class="keyword">struct </span><span class="keyword">alignas</span>(64) CacheOptimizedData {  <span class="comment">// キャッシュライン境界</span></div>
<div class="line">    atomic&lt;uint64_t&gt; sequence;</div>
<div class="line">    uint64_t timestamp;</div>
<div class="line">    uint32_t data_size;</div>
<div class="line">    uint32_t checksum;</div>
<div class="line">    <span class="keywordtype">char</span> data[MAX_DATA_SIZE];</div>
<div class="line">} __attribute__((packed));</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md255"></a>
🚀 基本的な使い方</h1>
<h2><a class="anchor" id="autotoc_md256"></a>
1. 簡単な整数データ通信</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__pub__sub_8hpp.html">shm_pub_sub.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 送信プログラム</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// &quot;test_topic&quot;という名前でint型のPublisherを作成</span></div>
<div class="line">    Publisher&lt;int&gt; pub(<span class="stringliteral">&quot;test_topic&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;データを送信中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">        pub.publish(i);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;送信: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ashm__pub__sub_8hpp_html"><div class="ttname"><a href="shm__pub__sub_8hpp.html">shm_pub_sub.hpp</a></div><div class="ttdoc">出版/購読モデルによるトピック通信を規定するクラスの定義</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// 受信プログラム</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// &quot;test_topic&quot;という名前でint型のSubscriberを作成</span></div>
<div class="line">    Subscriber&lt;int&gt; sub(<span class="stringliteral">&quot;test_topic&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;データを待機中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordtype">bool</span> state;</div>
<div class="line">        <span class="keywordtype">int</span> data = sub.subscribe(&amp;state);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (state) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;受信: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md257"></a>
2. カスタム構造体の通信</h2>
<div class="fragment"><div class="line"><span class="comment">// カスタムデータ構造の定義</span></div>
<div class="line"><span class="keyword">struct </span>SensorData {</div>
<div class="line">    <span class="keywordtype">float</span> temperature;    <span class="comment">// 温度</span></div>
<div class="line">    <span class="keywordtype">float</span> humidity;       <span class="comment">// 湿度</span></div>
<div class="line">    <span class="keywordtype">float</span> pressure;       <span class="comment">// 気圧</span></div>
<div class="line">    uint64_t timestamp;   <span class="comment">// タイムスタンプ</span></div>
<div class="line">    <span class="keywordtype">int</span> sensor_id;        <span class="comment">// センサーID</span></div>
<div class="line">    <span class="keywordtype">bool</span> is_valid;        <span class="comment">// データ有効性</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 送信側</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Publisher&lt;SensorData&gt; sensor_pub(<span class="stringliteral">&quot;weather_data&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        SensorData data;</div>
<div class="line">        data.temperature = 25.5f;</div>
<div class="line">        data.humidity = 60.0f;</div>
<div class="line">        data.pressure = 1013.25f;</div>
<div class="line">        data.timestamp = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now().time_since_epoch()).count();</div>
<div class="line">        data.sensor_id = 1;</div>
<div class="line">        data.is_valid = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        sensor_pub.publish(data);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;センサーデータ送信: 温度=&quot;</span> &lt;&lt; data.temperature &lt;&lt; <span class="stringliteral">&quot;℃&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 受信側</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    Subscriber&lt;SensorData&gt; sensor_sub(<span class="stringliteral">&quot;weather_data&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordtype">bool</span> state;</div>
<div class="line">        SensorData data = sensor_sub.subscribe(&amp;state);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (state &amp;&amp; data.is_valid) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;受信データ:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  温度: &quot;</span> &lt;&lt; data.temperature &lt;&lt; <span class="stringliteral">&quot;℃&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  湿度: &quot;</span> &lt;&lt; data.humidity &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  気圧: &quot;</span> &lt;&lt; data.pressure &lt;&lt; <span class="stringliteral">&quot;hPa&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  センサーID: &quot;</span> &lt;&lt; data.sensor_id &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md258"></a>
🚀 実践的な使用例</h1>
<h2><a class="anchor" id="autotoc_md259"></a>
1. 高頻度センサーデータ配信 (1kHz)</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__pub__sub_8hpp.html">shm_pub_sub.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 高解像度センサーデータ構造</span></div>
<div class="line"><span class="keyword">struct </span>HighFreqSensorData {</div>
<div class="line">    uint64_t timestamp_us;      <span class="comment">// マイクロ秒タイムスタンプ</span></div>
<div class="line">    <span class="keywordtype">float</span> position[3];          <span class="comment">// X, Y, Z位置</span></div>
<div class="line">    <span class="keywordtype">float</span> velocity[3];          <span class="comment">// X, Y, Z速度</span></div>
<div class="line">    <span class="keywordtype">float</span> acceleration[3];      <span class="comment">// X, Y, Z加速度</span></div>
<div class="line">    <span class="keywordtype">float</span> quaternion[4];        <span class="comment">// 姿勢（クォータニオン）</span></div>
<div class="line">    uint32_t sequence_number;   <span class="comment">// シーケンス番号</span></div>
<div class="line">    uint8_t sensor_status;      <span class="comment">// センサー状態</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>HighFrequencyPublisher {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classirlab_1_1shm_1_1_publisher.html">irlab::shm::Publisher&lt;HighFreqSensorData&gt;</a> publisher_;</div>
<div class="line">    std::thread publishing_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HighFrequencyPublisher(<span class="keyword">const</span> std::string&amp; topic) </div>
<div class="line">        : publisher_(topic), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> startPublishing() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        publishing_thread_ = std::thread(&amp;HighFrequencyPublisher::publishLoop, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stopPublishing() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (publishing_thread_.joinable()) {</div>
<div class="line">            publishing_thread_.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> publishLoop() {</div>
<div class="line">        uint32_t sequence = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 1kHz = 1000回/秒 = 1ms間隔</span></div>
<div class="line">        <span class="keyword">auto</span> next_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> interval = std::chrono::microseconds(1000);  <span class="comment">// 1ms</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            HighFreqSensorData data;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 高精度タイムスタンプ</span></div>
<div class="line">            <span class="keyword">auto</span> now = std::chrono::high_resolution_clock::now();</div>
<div class="line">            data.timestamp_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                now.time_since_epoch()).count();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// センサーデータ読取（実際のセンサーAPIに置き換え）</span></div>
<div class="line">            readSensorData(data);</div>
<div class="line">            data.sequence_number = sequence++;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 超高速送信（通常1-2マイクロ秒）</span></div>
<div class="line">            publisher_.<a class="code" href="classirlab_1_1shm_1_1_publisher.html#abaac5554b1e838c1069858ca3ca0fde0">publish</a>(data);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 精密なタイミング制御</span></div>
<div class="line">            next_time += interval;</div>
<div class="line">            std::this_thread::sleep_until(next_time);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> readSensorData(HighFreqSensorData&amp; data) {</div>
<div class="line">        <span class="comment">// 実際のセンサーからデータを読取</span></div>
<div class="line">        <span class="comment">// この部分は使用するセンサーAPIに依存</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ダミーデータ例</span></div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">float</span> t = 0.0f;</div>
<div class="line">        t += 0.001f;  <span class="comment">// 1ms刻み</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サイン波のモーションシミュレーション</span></div>
<div class="line">        data.position[0] = std::sin(t);</div>
<div class="line">        data.position[1] = std::cos(t);</div>
<div class="line">        data.position[2] = std::sin(t * 2.0f) * 0.5f;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 速度（位置の微分）</span></div>
<div class="line">        data.velocity[0] = std::cos(t);</div>
<div class="line">        data.velocity[1] = -std::sin(t);</div>
<div class="line">        data.velocity[2] = std::cos(t * 2.0f);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 加速度（速度の微分）</span></div>
<div class="line">        data.acceleration[0] = -std::sin(t);</div>
<div class="line">        data.acceleration[1] = -std::cos(t);</div>
<div class="line">        data.acceleration[2] = -2.0f * std::sin(t * 2.0f);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クォータニオン（単位クォータニオン）</span></div>
<div class="line">        data.quaternion[0] = std::cos(t * 0.5f);  <span class="comment">// w</span></div>
<div class="line">        data.quaternion[1] = std::sin(t * 0.5f);  <span class="comment">// x</span></div>
<div class="line">        data.quaternion[2] = 0.0f;                <span class="comment">// y</span></div>
<div class="line">        data.quaternion[3] = 0.0f;                <span class="comment">// z</span></div>
<div class="line">        </div>
<div class="line">        data.sensor_status = 0x01;  <span class="comment">// 正常状態</span></div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 高頻度受信と処理</span></div>
<div class="line"><span class="keyword">class </span>HighFrequencySubscriber {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <a class="code" href="classirlab_1_1shm_1_1_subscriber.html">irlab::shm::Subscriber&lt;HighFreqSensorData&gt;</a> subscriber_;</div>
<div class="line">    std::thread processing_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// パフォーマンス統計</span></div>
<div class="line">    std::atomic&lt;uint64_t&gt; total_received_;</div>
<div class="line">    std::atomic&lt;uint64_t&gt; missed_packets_;</div>
<div class="line">    uint32_t last_sequence_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HighFrequencySubscriber(<span class="keyword">const</span> std::string&amp; topic)</div>
<div class="line">        : subscriber_(topic), running_(false), </div>
<div class="line">          total_received_(0), missed_packets_(0), last_sequence_(0) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> startProcessing() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        processing_thread_ = std::thread(&amp;HighFrequencySubscriber::processLoop, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stopProcessing() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (processing_thread_.joinable()) {</div>
<div class="line">            processing_thread_.join();</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> printStatistics() {</div>
<div class="line">        uint64_t received = total_received_.load();</div>
<div class="line">        uint64_t missed = missed_packets_.load();</div>
<div class="line">        <span class="keywordtype">double</span> packet_loss = received &gt; 0 ? (double)missed / received * 100.0 : 0.0;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== 受信統計 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;総受信数: &quot;</span> &lt;&lt; received &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;欠損数: &quot;</span> &lt;&lt; missed &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;パケット欠損率: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) </div>
<div class="line">                  &lt;&lt; packet_loss &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordtype">bool</span> state;</div>
<div class="line">            HighFreqSensorData data = subscriber_.<a class="code" href="classirlab_1_1shm_1_1_subscriber.html#a30f69a6ad1aeb201e9035727bc5920cf">subscribe</a>(&amp;state);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (state) {</div>
<div class="line">                total_received_++;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// シーケンス番号でパケット欠損検出</span></div>
<div class="line">                <span class="keywordflow">if</span> (total_received_ &gt; 1) {</div>
<div class="line">                    uint32_t expected = last_sequence_ + 1;</div>
<div class="line">                    <span class="keywordflow">if</span> (data.sequence_number != expected) {</div>
<div class="line">                        missed_packets_ += (data.sequence_number - expected);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">                last_sequence_ = data.sequence_number;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 遅延測定</span></div>
<div class="line">                <span class="keyword">auto</span> now = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> now_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                    now.time_since_epoch()).count();</div>
<div class="line">                int64_t latency = now_us - data.timestamp_us;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// リアルタイム処理（例：制御計算）</span></div>
<div class="line">                processRealtimeControl(data, latency);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 統計情報表示（低頻度）</span></div>
<div class="line">                <span class="keywordflow">if</span> (total_received_ % 1000 == 0) {  <span class="comment">// 1秒毎</span></div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;レイテンシ: &quot;</span> &lt;&lt; latency &lt;&lt; <span class="stringliteral">&quot;μs, &quot;</span></div>
<div class="line">                              &lt;&lt; <span class="stringliteral">&quot;シーケンス: &quot;</span> &lt;&lt; data.sequence_number &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 高頻度処理のため最小限の待機</span></div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processRealtimeControl(<span class="keyword">const</span> HighFreqSensorData&amp; data, int64_t latency) {</div>
<div class="line">        <span class="comment">// リアルタイム制御処理の例</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 低遅延要求：10ms以下</span></div>
<div class="line">        <span class="keywordflow">if</span> (latency &gt; 10000) {  <span class="comment">// 10ms = 10,000μs</span></div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;⚠️ 高遅延検出: &quot;</span> &lt;&lt; latency &lt;&lt; <span class="stringliteral">&quot;μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 実際の制御計算（例：PID制御）</span></div>
<div class="line">        <span class="comment">// この部分で制御アルゴリズムを実装</span></div>
<div class="line">        calculatePIDControl(data.position, data.velocity);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> calculatePIDControl(<span class="keyword">const</span> <span class="keywordtype">float</span> position[3], <span class="keyword">const</span> <span class="keywordtype">float</span> velocity[3]) {</div>
<div class="line">        <span class="comment">// PID制御計算の例（簡略化）</span></div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">float</span> integral[3] = {0, 0, 0};</div>
<div class="line">        <span class="keyword">static</span> <span class="keywordtype">float</span> last_error[3] = {0, 0, 0};</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> target[3] = {1.0f, 0.0f, 0.5f};  <span class="comment">// 目標位置</span></div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> kp = 2.0f, ki = 0.1f, kd = 0.05f;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; i++) {</div>
<div class="line">            <span class="keywordtype">float</span> error = target[i] - position[i];</div>
<div class="line">            integral[i] += error * 0.001f;  <span class="comment">// 1ms間隔</span></div>
<div class="line">            <span class="keywordtype">float</span> derivative = (error - last_error[i]) / 0.001f;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">float</span> control_output = kp * error + ki * integral[i] + kd * derivative;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 制御出力の適用（実際のアクチュエータに送信）</span></div>
<div class="line">            <span class="comment">// sendControlCommand(i, control_output);</span></div>
<div class="line">            </div>
<div class="line">            last_error[i] = error;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用例</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// 高頻度パブリッシャー開始</span></div>
<div class="line">        HighFrequencyPublisher publisher(<span class="stringliteral">&quot;high_freq_sensors&quot;</span>);</div>
<div class="line">        publisher.startPublishing();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 複数のサブスクライバー（並列処理）</span></div>
<div class="line">        std::vector&lt;std::unique_ptr&lt;HighFrequencySubscriber&gt;&gt; subscribers;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 制御用サブスクライバー</span></div>
<div class="line">        subscribers.push_back(std::make_unique&lt;HighFrequencySubscriber&gt;(<span class="stringliteral">&quot;high_freq_sensors&quot;</span>));</div>
<div class="line">        subscribers.back()-&gt;startProcessing();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ログ記録用サブスクライバー</span></div>
<div class="line">        subscribers.push_back(std::make_unique&lt;HighFrequencySubscriber&gt;(<span class="stringliteral">&quot;high_freq_sensors&quot;</span>));</div>
<div class="line">        subscribers.back()-&gt;startProcessing();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 10秒間実行</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 停止と統計表示</span></div>
<div class="line">        publisher.stopPublishing();</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; sub : subscribers) {</div>
<div class="line">            sub-&gt;stopProcessing();</div>
<div class="line">            sub-&gt;printStatistics();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="aclassirlab_1_1shm_1_1_publisher_html"><div class="ttname"><a href="classirlab_1_1shm_1_1_publisher.html">irlab::shm::Publisher</a></div><div class="ttdoc">共有メモリにトピックを出力する出版者を表現するクラス</div><div class="ttdef"><b>Definition:</b> <a href="shm__pub__sub_8hpp_source.html#l00059">shm_pub_sub.hpp:60</a></div></div>
<div class="ttc" id="aclassirlab_1_1shm_1_1_publisher_html_abaac5554b1e838c1069858ca3ca0fde0"><div class="ttname"><a href="classirlab_1_1shm_1_1_publisher.html#abaac5554b1e838c1069858ca3ca0fde0">irlab::shm::Publisher::publish</a></div><div class="ttdeci">void publish(const T &amp;data)</div><div class="ttdoc">トピックの書き込み</div><div class="ttdef"><b>Definition:</b> <a href="shm__pub__sub_8hpp_source.html#l00183">shm_pub_sub.hpp:183</a></div></div>
<div class="ttc" id="aclassirlab_1_1shm_1_1_subscriber_html"><div class="ttname"><a href="classirlab_1_1shm_1_1_subscriber.html">irlab::shm::Subscriber</a></div><div class="ttdoc">共有メモリからトピックを取得する購読者を表現するクラス</div><div class="ttdef"><b>Definition:</b> <a href="shm__pub__sub_8hpp_source.html#l00094">shm_pub_sub.hpp:95</a></div></div>
<div class="ttc" id="aclassirlab_1_1shm_1_1_subscriber_html_a30f69a6ad1aeb201e9035727bc5920cf"><div class="ttname"><a href="classirlab_1_1shm_1_1_subscriber.html#a30f69a6ad1aeb201e9035727bc5920cf">irlab::shm::Subscriber::subscribe</a></div><div class="ttdeci">const T subscribe(bool *state)</div><div class="ttdoc">トピックを読み込む</div><div class="ttdef"><b>Definition:</b> <a href="shm__pub__sub_8hpp_source.html#l00251">shm_pub_sub.hpp:251</a></div></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md260"></a>
2. ベクトルデータの通信</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__pub__sub_8hpp.html">shm_pub_sub.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;shm_pub_sub_vector.hpp&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ベクトルデータの送信</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    Publisher&lt;std::vector&lt;float&gt;&gt; vector_pub(<span class="stringliteral">&quot;vector_data&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="comment">// 動的サイズのベクトルデータ</span></div>
<div class="line">        std::vector&lt;float&gt; sensor_array;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 複数センサーの値を収集</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {</div>
<div class="line">            <span class="keywordtype">float</span> value = std::sin(i * 0.1f) * 100.0f;</div>
<div class="line">            sensor_array.push_back(value);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        vector_pub.publish(sensor_array);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ベクトルデータ送信: &quot;</span> &lt;&lt; sensor_array.size() &lt;&lt; <span class="stringliteral">&quot;要素&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ベクトルデータの受信</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    Subscriber&lt;std::vector&lt;float&gt;&gt; vector_sub(<span class="stringliteral">&quot;vector_data&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordtype">bool</span> state;</div>
<div class="line">        std::vector&lt;float&gt; data = vector_sub.subscribe(&amp;state);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (state) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;受信ベクトル (&quot;</span> &lt;&lt; data.size() &lt;&lt; <span class="stringliteral">&quot;要素): &quot;</span>;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; std::min(data.size(), (<span class="keywordtype">size_t</span>)5); ++i) {</div>
<div class="line">                std::cout &lt;&lt; data[i] &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">if</span> (data.size() &gt; 5) std::cout &lt;&lt; <span class="stringliteral">&quot;...&quot;</span>;</div>
<div class="line">            std::cout &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md261"></a>
🛠️ パフォーマンス最適化テクニック</h1>
<h2><a class="anchor" id="autotoc_md262"></a>
1. CPU親和性設定</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pthread.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sched.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>OptimizedPublisher {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> setCPUAffinity(<span class="keywordtype">int</span> cpu_core) {</div>
<div class="line">        cpu_set_t cpuset;</div>
<div class="line">        CPU_ZERO(&amp;cpuset);</div>
<div class="line">        CPU_SET(cpu_core, &amp;cpuset);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">int</span> result = pthread_setaffinity_np(pthread_self(), <span class="keyword">sizeof</span>(cpu_set_t), &amp;cpuset);</div>
<div class="line">        <span class="keywordflow">if</span> (result != 0) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;CPU親和性設定に失敗&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;CPU&quot;</span> &lt;&lt; cpu_core &lt;&lt; <span class="stringliteral">&quot;に固定しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> setRealtimePriority() {</div>
<div class="line">        <span class="keyword">struct </span>sched_param param;</div>
<div class="line">        param.sched_priority = 99;  <span class="comment">// 最高優先度</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">int</span> result = pthread_setschedparam(pthread_self(), SCHED_FIFO, &amp;param);</div>
<div class="line">        <span class="keywordflow">if</span> (result != 0) {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;リアルタイム優先度設定に失敗 (要root権限)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md263"></a>
2. メモリプール最適化</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;memory_resource&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MemoryOptimizedPublisher {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// メモリプールでアロケーション最適化</span></div>
<div class="line">    std::array&lt;std::byte, 64 * 1024&gt; buffer_;  <span class="comment">// 64KB固定プール</span></div>
<div class="line">    std::pmr::monotonic_buffer_resource pool_{buffer_.data(), buffer_.size()};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// カスタムアロケータ使用のコンテナ</span></div>
<div class="line">    std::pmr::vector&lt;uint8_t&gt; reusable_buffer_{&amp;pool_};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> optimizedPublish() {</div>
<div class="line">        <span class="comment">// メモリ確保が超高速（プールから切り出し）</span></div>
<div class="line">        reusable_buffer_.resize(1024);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// データ準備</span></div>
<div class="line">        fillData(reusable_buffer_);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 送信</span></div>
<div class="line">        publisher_.<a class="code" href="classirlab_1_1shm_1_1_publisher.html#abaac5554b1e838c1069858ca3ca0fde0">publish</a>(reusable_buffer_.data(), reusable_buffer_.size());</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// メモリ再利用のためクリア</span></div>
<div class="line">        reusable_buffer_.clear();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md264"></a>
📊 パフォーマンス測定とベンチマーク</h1>
<h2><a class="anchor" id="autotoc_md265"></a>
詳細ベンチマーク</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PerformanceBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;double&gt; latencies_;</div>
<div class="line">    std::vector&lt;double&gt; throughputs_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> runLatencyBenchmark() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== レイテンシベンチマーク開始 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <a class="code" href="classirlab_1_1shm_1_1_publisher.html">irlab::shm::Publisher&lt;uint64_t&gt;</a> pub(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        <a class="code" href="classirlab_1_1shm_1_1_subscriber.html">irlab::shm::Subscriber&lt;uint64_t&gt;</a> sub(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = 10000;</div>
<div class="line">        latencies_.reserve(iterations);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// タイムスタンプ送信</span></div>
<div class="line">            <span class="keyword">auto</span> timestamp = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(</div>
<div class="line">                start.time_since_epoch()).count();</div>
<div class="line">            pub.publish(timestamp);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 受信待ち</span></div>
<div class="line">            <span class="keywordtype">bool</span> state;</div>
<div class="line">            uint64_t received_timestamp;</div>
<div class="line">            <span class="keywordflow">do</span> {</div>
<div class="line">                received_timestamp = sub.subscribe(&amp;state);</div>
<div class="line">            } <span class="keywordflow">while</span> (!state);</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// レイテンシ計算（ナノ秒）</span></div>
<div class="line">            <span class="keyword">auto</span> latency_ns = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            latencies_.push_back(latency_ns / 1000.0);  <span class="comment">// マイクロ秒に変換</span></div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        analyzeLatency();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> runThroughputBenchmark() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== スループットベンチマーク開始 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 様々なデータサイズでテスト</span></div>
<div class="line">        std::vector&lt;size_t&gt; data_sizes = {64, 256, 1024, 4096, 16384, 65536};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> size : data_sizes) {</div>
<div class="line">            measureThroughput(size);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> analyzeLatency() {</div>
<div class="line">        <span class="keywordflow">if</span> (latencies_.empty()) <span class="keywordflow">return</span>;</div>
<div class="line">        </div>
<div class="line">        std::sort(latencies_.begin(), latencies_.end());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> mean = std::accumulate(latencies_.begin(), latencies_.end(), 0.0) / latencies_.size();</div>
<div class="line">        <span class="keywordtype">double</span> min_val = latencies_.front();</div>
<div class="line">        <span class="keywordtype">double</span> max_val = latencies_.back();</div>
<div class="line">        <span class="keywordtype">double</span> p50 = latencies_[latencies_.size() * 0.5];</div>
<div class="line">        <span class="keywordtype">double</span> p95 = latencies_[latencies_.size() * 0.95];</div>
<div class="line">        <span class="keywordtype">double</span> p99 = latencies_[latencies_.size() * 0.99];</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 分散計算</span></div>
<div class="line">        <span class="keywordtype">double</span> variance = 0.0;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">double</span> latency : latencies_) {</div>
<div class="line">            variance += (latency - mean) * (latency - mean);</div>
<div class="line">        }</div>
<div class="line">        variance /= latencies_.size();</div>
<div class="line">        <span class="keywordtype">double</span> stddev = std::sqrt(variance);</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== レイテンシ統計 (μs) ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;平均: &quot;</span> &lt;&lt; mean &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;最小: &quot;</span> &lt;&lt; min_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;最大: &quot;</span> &lt;&lt; max_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;標準偏差: &quot;</span> &lt;&lt; stddev &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;50%ile: &quot;</span> &lt;&lt; p50 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;95%ile: &quot;</span> &lt;&lt; p95 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;99%ile: &quot;</span> &lt;&lt; p99 &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// パフォーマンス判定</span></div>
<div class="line">        <span class="keywordflow">if</span> (p99 &lt; 10.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;🏆 優秀: 99%のレイテンシが10μs以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p99 &lt; 100.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;👍 良好: 99%のレイテンシが100μs以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;⚠️  要改善: レイテンシが高めです&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureThroughput(<span class="keywordtype">size_t</span> data_size) {</div>
<div class="line">        std::vector&lt;uint8_t&gt; test_data(data_size, 0x55);  <span class="comment">// テストパターン</span></div>
<div class="line">        </div>
<div class="line">        <a class="code" href="classirlab_1_1shm_1_1_publisher.html">irlab::shm::Publisher&lt;std::vector&lt;uint8_t&gt;</a>&gt; pub(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        <a class="code" href="classirlab_1_1shm_1_1_subscriber.html">irlab::shm::Subscriber&lt;std::vector&lt;uint8_t&gt;</a>&gt; sub(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = 1000;</div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 送信側スレッド</span></div>
<div class="line">        std::thread sender([&amp;]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">                pub.publish(test_data);</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 受信側カウント</span></div>
<div class="line">        <span class="keywordtype">int</span> received_count = 0;</div>
<div class="line">        <span class="keywordflow">while</span> (received_count &lt; iterations) {</div>
<div class="line">            <span class="keywordtype">bool</span> state;</div>
<div class="line">            <span class="keyword">auto</span> data = sub.subscribe(&amp;state);</div>
<div class="line">            <span class="keywordflow">if</span> (state) {</div>
<div class="line">                received_count++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        sender.join();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// スループット計算</span></div>
<div class="line">        <span class="keyword">auto</span> duration_ms = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end - start).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> throughput_mbps = (double)(iterations * data_size) / duration_ms / 1024.0;  <span class="comment">// MB/s</span></div>
<div class="line">        <span class="keywordtype">double</span> message_rate = (double)iterations / duration_ms * 1000.0;  <span class="comment">// msg/s</span></div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データサイズ &quot;</span> &lt;&lt; data_size &lt;&lt; <span class="stringliteral">&quot; bytes:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  スループット: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) </div>
<div class="line">                  &lt;&lt; throughput_mbps &lt;&lt; <span class="stringliteral">&quot; MB/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  メッセージレート: &quot;</span> &lt;&lt; std::setprecision(0) </div>
<div class="line">                  &lt;&lt; message_rate &lt;&lt; <span class="stringliteral">&quot; msg/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ベンチマーク実行</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        PerformanceBenchmark benchmark;</div>
<div class="line">        </div>
<div class="line">        benchmark.runLatencyBenchmark();</div>
<div class="line">        std::cout &lt;&lt; std::endl;</div>
<div class="line">        benchmark.runThroughputBenchmark();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ベンチマークエラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md266"></a>
❓ よくある質問</h1>
<h2><a class="anchor" id="autotoc_md267"></a>
Q1. 同時に接続できるSubscriberの数に制限はありますか？</h2>
<p><b>A</b>: 基本的に制限はありません。共有メモリの読み取りは複数プロセスから同時に行えます。ただし、システムのメモリ量やプロセス数の制限に依存します。</p>
<h2><a class="anchor" id="autotoc_md268"></a>
Q2. データの順序は保証されますか？</h2>
<p><b>A</b>: 同一Publisher内では順序が保証されます。ただし、複数のPublisherがある場合や、ネットワーク遅延がある場合は順序が前後する可能性があります。</p>
<h2><a class="anchor" id="autotoc_md269"></a>
Q3. プロセスがクラッシュした場合はどうなりますか？</h2>
<p><b>A</b>:</p><ul>
<li><b>Publisher</b>: 他のSubscriberに影響なし</li>
<li><b>Subscriber</b>: 他のプロセスに影響なし</li>
<li><b>共有メモリ</b>: システム再起動まで残存（手動削除可能）</li>
</ul>
<h1><a class="anchor" id="autotoc_md270"></a>
🔧 トラブルシューティング</h1>
<h2><a class="anchor" id="autotoc_md271"></a>
よくある問題と解決法</h2>
<div class="fragment"><div class="line"><span class="comment">// デバッグ用の診断コード</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__pub__sub_8hpp.html">shm_pub_sub.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> diagnose_pub_sub_communication() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;=== Pub/Sub通信診断 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// 1. Publisher作成テスト</span></div>
<div class="line">        Publisher&lt;int&gt; pub(<span class="stringliteral">&quot;debug_topic&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ Publisher作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        pub.publish(42);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ データ送信成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. Subscriber作成テスト</span></div>
<div class="line">        Subscriber&lt;int&gt; sub(<span class="stringliteral">&quot;debug_topic&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ Subscriber作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">bool</span> state;</div>
<div class="line">        <span class="keywordtype">int</span> data = sub.subscribe(&amp;state);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;受信結果: state=&quot;</span> &lt;&lt; state &lt;&lt; <span class="stringliteral">&quot;, data=&quot;</span> &lt;&lt; data &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (!state) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;❌ データが無効 - 以下を確認:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;   - 送信プログラムが動作中か？&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;   - トピック名が一致しているか？&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;❌ エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md272"></a>
📚 次のステップ</h1>
<p>Pub/Sub通信をマスターしたら、以下の高度なトピックに挑戦してみましょう：</p>
<ol type="1">
<li><b><a class="el" href="md_manual_tutorials_shm_service_jp.html">🤝 Service通信</a></b> - 確実な要求応答通信</li>
<li><b><a class="el" href="md_manual_tutorials_shm_action_jp.html">⚡ Action通信</a></b> - 長時間非同期処理</li>
<li><b><a class="el" href="md_manual_tutorials_python_jp.html">🐍 Python連携</a></b> - PythonでPub/Sub通信</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md274"></a>
📄 ライセンス情報</h1>
<p>本ドキュメントで紹介しているサンプルコードは、shared-memory-based-handy-communication-manager プロジェクトの一部として <b>Apache License 2.0</b> の下で提供されています。</p>
<ul>
<li>✅ <b>商用利用可能</b>: サンプルコードを商業プロジェクトで自由に使用</li>
<li>✅ <b>改変可能</b>: ニーズに合わせてコードを修正・拡張</li>
<li>✅ <b>再配布可能</b>: ライセンス表示を保持して再配布</li>
</ul>
<p>詳細は<a href="../LICENSE">LICENSEファイル</a>をご確認ください。</p>
<hr  />
<p>この完全ガイドで、Pub/Sub通信の真の力を引き出し、次世代の高性能アプリケーションを構築しましょう！ 🚀✨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2025 14:47:59 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
