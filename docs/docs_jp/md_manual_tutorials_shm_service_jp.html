<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: 🤝 Service通信完全ガイド - 確実な要求応答通信をマスターしよう</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">共有メモリを用いた高速で扱いやすいプロセス間通信マネージャ</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">🤝 Service通信完全ガイド - 確実な要求応答通信をマスターしよう </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[<a href="../md_manual_tutorials_shm_service_en.html">English</a> | 日本語]</p>
<h1><a class="anchor" id="autotoc_md295"></a>
🎯 このガイドで学べること</h1>
<ul>
<li><b>Service通信の深い理解</b>: 要求応答パターンの設計思想から実装詳細まで</li>
<li><b>信頼性の高いデータ交換</b>: タイムアウト、エラーハンドリング、再試行機構</li>
<li><b>高性能サーバー設計</b>: 並行処理、負荷分散、メモリ効率化</li>
<li><b>実践的な応用例</b>: データベース操作、計算サービス、設定管理</li>
</ul>
<h1><a class="anchor" id="autotoc_md296"></a>
🧠 Service通信の深い理解</h1>
<h2><a class="anchor" id="autotoc_md297"></a>
🏗️ アーキテクチャ解説</h2>
<div class="fragment"><div class="line"><span class="comment">// Service通信の内部構造</span></div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                   共有メモリ空間                              │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              要求キュー                             │    │</div>
<div class="line">│  │ [Req 0][Req 1][Req 2]...[Req N-1]                 │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  処理位置                    追加位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              応答キュー                             │    │</div>
<div class="line">│  │ [Res 0][Res 1][Res 2]...[Res N-1]                 │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  読取位置                    書込位置                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  要求応答マッピング:                                         │</div>
<div class="line">│  - 要求ID (一意識別子)                                       │</div>
<div class="line">│  - タイムスタンプ (タイムアウト管理)                          │</div>
<div class="line">│  - 処理状態 (待機/処理中/完了)                               │</div>
<div class="line">│  - エラーコード (障害時の詳細情報)                           │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Multiple Clients ← [shared memory] → Single Server</div>
<div class="line">      │                                        │</div>
<div class="line">   要求送信                                処理エンジン</div>
<div class="line">   応答受信                                   │</div>
<div class="line">      │                                   並列処理</div>
<div class="line">   タイムアウト管理                        結果生成</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md298"></a>
⚡ なぜ確実で高速なのか？</h2>
<p><b>1. 同期・非同期両対応</b> </p><div class="fragment"><div class="line"><span class="comment">// 同期通信（簡単）</span></div>
<div class="line">ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;calc_service&quot;</span>);</div>
<div class="line">client.sendRequest(42);</div>
<div class="line"><span class="keywordflow">if</span> (client.waitForResponse(5000000)) {  <span class="comment">// 5秒タイムアウト</span></div>
<div class="line">    <span class="keywordtype">int</span> result = client.getResponse();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;結果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 非同期通信（高性能）</span></div>
<div class="line">client.sendRequestAsync(42);</div>
<div class="line"><span class="comment">// 他の処理を実行...</span></div>
<div class="line"><span class="keywordflow">if</span> (client.checkResponse()) {</div>
<div class="line">    <span class="keywordtype">int</span> result = client.getResponse();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;結果: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. 確実な要求応答マッピング</b> </p><div class="fragment"><div class="line"><span class="comment">// 内部的な要求管理</span></div>
<div class="line"><span class="keyword">struct </span>RequestHeader {</div>
<div class="line">    uint64_t request_id;        <span class="comment">// 一意の要求ID</span></div>
<div class="line">    uint64_t timestamp_us;      <span class="comment">// 送信時刻</span></div>
<div class="line">    uint32_t timeout_ms;        <span class="comment">// タイムアウト時間</span></div>
<div class="line">    uint32_t retry_count;       <span class="comment">// 再試行回数</span></div>
<div class="line">    uint32_t priority;          <span class="comment">// 優先度</span></div>
<div class="line">    RequestStatus status;       <span class="comment">// 処理状態</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 要求と応答の確実な対応付け</span></div>
<div class="line"><span class="keyword">class </span>RequestTracker {</div>
<div class="line">    std::unordered_map&lt;uint64_t, RequestInfo&gt; pending_requests_;</div>
<div class="line">    std::mutex requests_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    uint64_t addRequest(<span class="keyword">const</span> RequestInfo&amp; info) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        uint64_t <span class="keywordtype">id</span> = generateUniqueId();</div>
<div class="line">        pending_requests_[id] = info;</div>
<div class="line">        <span class="keywordflow">return</span> id;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> checkResponse(uint64_t request_id, ResponseInfo&amp; response) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        <span class="keyword">auto</span> it = pending_requests_.find(request_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != pending_requests_.end() &amp;&amp; it-&gt;second.status == COMPLETED) {</div>
<div class="line">            response = it-&gt;second.response;</div>
<div class="line">            pending_requests_.erase(it);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>3. 高効率な並行処理</b> </p><div class="fragment"><div class="line"><span class="comment">// サーバー側の並行要求処理</span></div>
<div class="line"><span class="keyword">class </span>ConcurrentServiceServer {</div>
<div class="line">    std::vector&lt;std::thread&gt; worker_threads_;</div>
<div class="line">    std::queue&lt;RequestInfo&gt; request_queue_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable queue_cv_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> startWorkers(<span class="keywordtype">int</span> num_workers) {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_workers; ++i) {</div>
<div class="line">            worker_threads_.emplace_back(&amp;ConcurrentServiceServer::workerLoop, <span class="keyword">this</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> workerLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            RequestInfo request;</div>
<div class="line">            {</div>
<div class="line">                std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">                queue_cv_.wait(lock, [<span class="keyword">this</span>] { <span class="keywordflow">return</span> !request_queue_.empty() || !running_; });</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (!running_) <span class="keywordflow">break</span>;</div>
<div class="line">                </div>
<div class="line">                request = request_queue_.front();</div>
<div class="line">                request_queue_.pop();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 要求を並列処理</span></div>
<div class="line">            processRequest(request);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md299"></a>
🚀 基本的な使い方</h1>
<h2><a class="anchor" id="autotoc_md300"></a>
1. 簡単な計算サービス</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__service_8hpp.html">shm_service.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 計算要求データ</span></div>
<div class="line"><span class="keyword">struct </span>CalcRequest {</div>
<div class="line">    <span class="keywordtype">int</span> a, b;</div>
<div class="line">    <span class="keywordtype">char</span> operation;  <span class="comment">// &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 計算結果データ</span></div>
<div class="line"><span class="keyword">struct </span>CalcResponse {</div>
<div class="line">    <span class="keywordtype">double</span> result;</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">char</span> error_message[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// サーバー側プログラム</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ServiceServer&lt;CalcRequest, CalcResponse&gt; server(<span class="stringliteral">&quot;calculator&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;計算サーバーを開始しました...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">            CalcRequest request = server.getRequest();</div>
<div class="line">            CalcResponse response;</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;要求受信: &quot;</span> &lt;&lt; request.a &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; request.operation </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; request.b &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 計算処理</span></div>
<div class="line">            <span class="keywordflow">switch</span> (request.operation) {</div>
<div class="line">                <span class="keywordflow">case</span> <span class="charliteral">&#39;+&#39;</span>:</div>
<div class="line">                    response.result = request.a + request.b;</div>
<div class="line">                    response.success = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <span class="charliteral">&#39;-&#39;</span>:</div>
<div class="line">                    response.result = request.a - request.b;</div>
<div class="line">                    response.success = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <span class="charliteral">&#39;*&#39;</span>:</div>
<div class="line">                    response.result = request.a * request.b;</div>
<div class="line">                    response.success = <span class="keyword">true</span>;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> <span class="charliteral">&#39;/&#39;</span>:</div>
<div class="line">                    <span class="keywordflow">if</span> (request.b != 0) {</div>
<div class="line">                        response.result = (double)request.a / request.b;</div>
<div class="line">                        response.success = <span class="keyword">true</span>;</div>
<div class="line">                    } <span class="keywordflow">else</span> {</div>
<div class="line">                        response.success = <span class="keyword">false</span>;</div>
<div class="line">                        strncpy(response.error_message, <span class="stringliteral">&quot;Division by zero&quot;</span>, 255);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    response.success = <span class="keyword">false</span>;</div>
<div class="line">                    strncpy(response.error_message, <span class="stringliteral">&quot;Unknown operation&quot;</span>, 255);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            server.sendResponse(response);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (response.success) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;結果送信: &quot;</span> &lt;&lt; response.result &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;エラー送信: &quot;</span> &lt;&lt; response.error_message &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ashm__service_8hpp_html"><div class="ttname"><a href="shm__service_8hpp.html">shm_service.hpp</a></div><div class="ttdoc">メモリの格納方法を規定するクラスの定義</div></div>
</div><!-- fragment --><div class="fragment"><div class="line"><span class="comment">// クライアント側プログラム</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ServiceClient&lt;CalcRequest, CalcResponse&gt; client(<span class="stringliteral">&quot;calculator&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;計算クライアントを開始しました...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        CalcRequest request;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;数値1を入力: &quot;</span>;</div>
<div class="line">        std::cin &gt;&gt; request.a;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;演算子を入力 (+, -, *, /): &quot;</span>;</div>
<div class="line">        std::cin &gt;&gt; request.operation;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;数値2を入力: &quot;</span>;</div>
<div class="line">        std::cin &gt;&gt; request.b;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 要求送信</span></div>
<div class="line">        client.sendRequest(request);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;要求送信完了...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 応答待機（最大5秒）</span></div>
<div class="line">        <span class="keywordflow">if</span> (client.waitForResponse(5000000)) {  <span class="comment">// 5秒 = 5,000,000マイクロ秒</span></div>
<div class="line">            CalcResponse response = client.getResponse();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (response.success) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;計算結果: &quot;</span> &lt;&lt; response.result &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; response.error_message &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;タイムアウト: サーバーが応答しませんでした&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;続行しますか？ (y/n): &quot;</span>;</div>
<div class="line">        <span class="keywordtype">char</span> cont;</div>
<div class="line">        std::cin &gt;&gt; cont;</div>
<div class="line">        <span class="keywordflow">if</span> (cont != <span class="charliteral">&#39;y&#39;</span> &amp;&amp; cont != <span class="charliteral">&#39;Y&#39;</span>) <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md301"></a>
2. 複合データ型の通信</h2>
<div class="fragment"><div class="line"><span class="comment">// 複雑なデータ構造の例</span></div>
<div class="line"><span class="keyword">struct </span>ImageProcessRequest {</div>
<div class="line">    uint32_t width, height;</div>
<div class="line">    uint8_t format;           <span class="comment">// 0=RGB, 1=RGBA, 2=GRAY</span></div>
<div class="line">    uint32_t data_size;</div>
<div class="line">    <span class="keywordtype">char</span> image_data[1024*1024];  <span class="comment">// 最大1MB</span></div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 処理パラメータ</span></div>
<div class="line">    <span class="keywordtype">float</span> brightness;</div>
<div class="line">    <span class="keywordtype">float</span> contrast;</div>
<div class="line">    <span class="keywordtype">float</span> saturation;</div>
<div class="line">    <span class="keywordtype">bool</span> apply_blur;</div>
<div class="line">    <span class="keywordtype">float</span> blur_radius;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>ImageProcessResponse {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint32_t processed_size;</div>
<div class="line">    <span class="keywordtype">char</span> processed_data[1024*1024];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 処理結果情報</span></div>
<div class="line">    uint32_t processing_time_ms;</div>
<div class="line">    <span class="keywordtype">char</span> algorithm_used[128];</div>
<div class="line">    <span class="keywordtype">float</span> quality_score;</div>
<div class="line">    <span class="keywordtype">char</span> error_details[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 画像処理サーバー</span></div>
<div class="line"><span class="keyword">class </span>ImageProcessingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceServer&lt;ImageProcessRequest, ImageProcessResponse&gt; server_;</div>
<div class="line">    std::thread processing_thread_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ImageProcessingServer() : server_(<span class="stringliteral">&quot;image_processor&quot;</span>), running_(false) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start() {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        processing_thread_ = std::thread(&amp;ImageProcessingServer::processLoop, <span class="keyword">this</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;画像処理サーバーを開始しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">if</span> (processing_thread_.joinable()) {</div>
<div class="line">            processing_thread_.join();</div>
<div class="line">        }</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;画像処理サーバーを停止しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasRequest()) {</div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                ImageProcessRequest request = server_.getRequest();</div>
<div class="line">                ImageProcessResponse response;</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;画像処理要求受信: &quot;</span> &lt;&lt; request.width &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; request.height</div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, サイズ: &quot;</span> &lt;&lt; request.data_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 画像処理実行</span></div>
<div class="line">                <span class="keywordtype">bool</span> success = processImage(request, response);</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                    end_time - start_time);</div>
<div class="line">                </div>
<div class="line">                response.processing_time_ms = duration.count();</div>
<div class="line">                response.success = success;</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (success) {</div>
<div class="line">                    strncpy(response.algorithm_used, <span class="stringliteral">&quot;Advanced Filter v2.1&quot;</span>, 127);</div>
<div class="line">                    response.quality_score = calculateQualityScore(response);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;処理完了: &quot;</span> &lt;&lt; response.processing_time_ms &lt;&lt; <span class="stringliteral">&quot;ms, &quot;</span></div>
<div class="line">                              &lt;&lt; <span class="stringliteral">&quot;品質スコア: &quot;</span> &lt;&lt; response.quality_score &lt;&lt; std::endl;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    strncpy(response.error_details, <span class="stringliteral">&quot;画像処理に失敗しました&quot;</span>, 511);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;処理失敗: &quot;</span> &lt;&lt; response.error_details &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                server_.sendResponse(response);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(5));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> processImage(<span class="keyword">const</span> ImageProcessRequest&amp; request, ImageProcessResponse&amp; response) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// 入力検証</span></div>
<div class="line">            <span class="keywordflow">if</span> (request.data_size == 0 || request.width == 0 || request.height == 0) {</div>
<div class="line">                strncpy(response.error_details, <span class="stringliteral">&quot;無効な画像データ&quot;</span>, 511);</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 実際の画像処理アルゴリズム</span></div>
<div class="line">            <span class="comment">// この例では簡単な処理をシミュレート</span></div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 明度調整</span></div>
<div class="line">            <span class="keywordtype">float</span> brightness_factor = 1.0f + request.brightness;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// コントラスト調整</span></div>
<div class="line">            <span class="keywordtype">float</span> contrast_factor = request.contrast;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// 色の処理（この例では単純化）</span></div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; request.data_size; ++i) {</div>
<div class="line">                uint8_t pixel = request.image_data[i];</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 明度調整</span></div>
<div class="line">                <span class="keywordtype">float</span> adjusted = pixel * brightness_factor;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// コントラスト調整</span></div>
<div class="line">                adjusted = (adjusted - 128.0f) * contrast_factor + 128.0f;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 範囲クリッピング</span></div>
<div class="line">                adjusted = std::max(0.0f, std::min(255.0f, adjusted));</div>
<div class="line">                </div>
<div class="line">                response.processed_data[i] = <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(adjusted);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            response.processed_size = request.data_size;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// ブラー処理（要求があれば）</span></div>
<div class="line">            <span class="keywordflow">if</span> (request.apply_blur) {</div>
<div class="line">                applyBlur(response.processed_data, request.width, request.height, </div>
<div class="line">                         request.blur_radius);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(response.error_details, e.what(), 511);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> applyBlur(<span class="keywordtype">char</span>* data, uint32_t width, uint32_t height, <span class="keywordtype">float</span> radius) {</div>
<div class="line">        <span class="comment">// 簡単なボックスブラーの実装</span></div>
<div class="line">        <span class="comment">// 実際の実装ではより高度なアルゴリズムを使用</span></div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">int</span> blur_size = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(radius);</div>
<div class="line">        <span class="keywordflow">if</span> (blur_size &lt;= 0) <span class="keywordflow">return</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 水平方向のブラー</span></div>
<div class="line">        <span class="keywordflow">for</span> (uint32_t y = 0; y &lt; height; ++y) {</div>
<div class="line">            <span class="keywordflow">for</span> (uint32_t x = blur_size; x &lt; width - blur_size; ++x) {</div>
<div class="line">                <span class="keywordtype">int</span> sum = 0;</div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> dx = -blur_size; dx &lt;= blur_size; ++dx) {</div>
<div class="line">                    sum += <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(data[y * width + x + dx]);</div>
<div class="line">                }</div>
<div class="line">                data[y * width + x] = sum / (2 * blur_size + 1);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">float</span> calculateQualityScore(<span class="keyword">const</span> ImageProcessResponse&amp; response) {</div>
<div class="line">        <span class="comment">// 品質スコアの計算（簡略化）</span></div>
<div class="line">        <span class="keywordtype">float</span> score = 0.8f + (response.processing_time_ms &lt; 100 ? 0.2f : 0.1f);</div>
<div class="line">        <span class="keywordflow">return</span> std::min(1.0f, score);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用例</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ImageProcessingServer server;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        server.start();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバーを10秒間実行</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(10));</div>
<div class="line">        </div>
<div class="line">        server.stop();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md302"></a>
🚀 実践的な使用例</h1>
<h2><a class="anchor" id="autotoc_md303"></a>
1. 高性能データベースサービス</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__service_8hpp.html">shm_service.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;shared_mutex&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// データベース操作の定義</span></div>
<div class="line"><span class="keyword">enum class</span> DbOperation {</div>
<div class="line">    INSERT,</div>
<div class="line">    SELECT,</div>
<div class="line">    UPDATE,</div>
<div class="line">    DELETE,</div>
<div class="line">    CREATE_TABLE,</div>
<div class="line">    DROP_TABLE</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// データベース要求</span></div>
<div class="line"><span class="keyword">struct </span>DatabaseRequest {</div>
<div class="line">    DbOperation operation;</div>
<div class="line">    <span class="keywordtype">char</span> table_name[64];</div>
<div class="line">    <span class="keywordtype">char</span> key[128];</div>
<div class="line">    <span class="keywordtype">char</span> value[1024];</div>
<div class="line">    <span class="keywordtype">char</span> condition[256];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// メタデータ</span></div>
<div class="line">    uint64_t client_id;</div>
<div class="line">    uint32_t priority;</div>
<div class="line">    <span class="keywordtype">bool</span> require_transaction;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// データベース応答</span></div>
<div class="line"><span class="keyword">struct </span>DatabaseResponse {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint32_t affected_rows;</div>
<div class="line">    <span class="keywordtype">char</span> result_data[2048];</div>
<div class="line">    <span class="keywordtype">char</span> error_message[512];</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// パフォーマンス情報</span></div>
<div class="line">    uint64_t execution_time_us;</div>
<div class="line">    uint32_t memory_used;</div>
<div class="line">    uint32_t disk_reads;</div>
<div class="line">    uint32_t disk_writes;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 高性能インメモリデータベース</span></div>
<div class="line"><span class="keyword">class </span>HighPerformanceDatabase {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="comment">// データストレージ</span></div>
<div class="line">    std::unordered_map&lt;std::string, std::unordered_map&lt;std::string, std::string&gt;&gt; tables_;</div>
<div class="line">    std::shared_mutex data_mutex_;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// パフォーマンス監視</span></div>
<div class="line">    std::atomic&lt;uint64_t&gt; total_requests_{0};</div>
<div class="line">    std::atomic&lt;uint64_t&gt; total_execution_time_{0};</div>
<div class="line">    std::atomic&lt;uint32_t&gt; active_connections_{0};</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// サービス管理</span></div>
<div class="line">    ServiceServer&lt;DatabaseRequest, DatabaseResponse&gt; server_;</div>
<div class="line">    std::vector&lt;std::thread&gt; worker_threads_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_{<span class="keyword">false</span>};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    HighPerformanceDatabase() : server_(<span class="stringliteral">&quot;database_service&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> start(<span class="keywordtype">int</span> num_workers = 4) {</div>
<div class="line">        running_ = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// ワーカースレッドを開始</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_workers; ++i) {</div>
<div class="line">            worker_threads_.emplace_back(&amp;HighPerformanceDatabase::workerLoop, <span class="keyword">this</span>, i);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データベースサービスを開始しました (&quot;</span> &lt;&lt; num_workers &lt;&lt; <span class="stringliteral">&quot; workers)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 統計情報スレッドを開始</span></div>
<div class="line">        worker_threads_.emplace_back(&amp;HighPerformanceDatabase::statisticsLoop, <span class="keyword">this</span>);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> stop() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : worker_threads_) {</div>
<div class="line">            <span class="keywordflow">if</span> (thread.joinable()) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データベースサービスを停止しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> workerLoop(<span class="keywordtype">int</span> worker_id) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="stringliteral">&quot; を開始しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasRequest()) {</div>
<div class="line">                active_connections_++;</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> start_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                </div>
<div class="line">                DatabaseRequest request = server_.getRequest();</div>
<div class="line">                DatabaseResponse response = processRequest(request);</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> end_time = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                    end_time - start_time);</div>
<div class="line">                </div>
<div class="line">                response.execution_time_us = duration.count();</div>
<div class="line">                </div>
<div class="line">                server_.sendResponse(response);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 統計情報更新</span></div>
<div class="line">                total_requests_++;</div>
<div class="line">                total_execution_time_ += duration.count();</div>
<div class="line">                active_connections_--;</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="stringliteral">&quot; 処理完了: &quot;</span> </div>
<div class="line">                          &lt;&lt; response.execution_time_us &lt;&lt; <span class="stringliteral">&quot;μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse processRequest(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        response.success = <span class="keyword">false</span>;</div>
<div class="line">        response.affected_rows = 0;</div>
<div class="line">        response.memory_used = 0;</div>
<div class="line">        response.disk_reads = 0;</div>
<div class="line">        response.disk_writes = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">switch</span> (request.operation) {</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::CREATE_TABLE:</div>
<div class="line">                    response = createTable(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::INSERT:</div>
<div class="line">                    response = insertData(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::SELECT:</div>
<div class="line">                    response = selectData(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::UPDATE:</div>
<div class="line">                    response = updateData(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::DELETE:</div>
<div class="line">                    response = deleteData(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> DbOperation::DROP_TABLE:</div>
<div class="line">                    response = dropTable(request);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    strncpy(response.error_message, <span class="stringliteral">&quot;未知の操作&quot;</span>, 511);</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            strncpy(response.error_message, e.what(), 511);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse createTable(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (tables_.find(table_name) != tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが既に存在します&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        tables_[table_name] = std::unordered_map&lt;std::string, std::string&gt;();</div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.affected_rows = 1;</div>
<div class="line">        response.disk_writes = 1;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;テーブル作成: &quot;</span> &lt;&lt; table_name &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse insertData(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        std::string key = request.key;</div>
<div class="line">        std::string value = request.value;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> table_it = tables_.find(table_name);</div>
<div class="line">        <span class="keywordflow">if</span> (table_it == tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが存在しません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        table_it-&gt;second[key] = value;</div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.affected_rows = 1;</div>
<div class="line">        response.disk_writes = 1;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse selectData(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::shared_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        std::string key = request.key;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> table_it = tables_.find(table_name);</div>
<div class="line">        <span class="keywordflow">if</span> (table_it == tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが存在しません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (key.empty()) {</div>
<div class="line">            <span class="comment">// 全レコード取得</span></div>
<div class="line">            std::string result;</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; pair : table_it-&gt;second) {</div>
<div class="line">                result += pair.first + <span class="stringliteral">&quot;=&quot;</span> + pair.second + <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">            }</div>
<div class="line">            strncpy(response.result_data, result.c_str(), 2047);</div>
<div class="line">            response.affected_rows = table_it-&gt;second.size();</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            <span class="comment">// 特定キーの取得</span></div>
<div class="line">            <span class="keyword">auto</span> data_it = table_it-&gt;second.find(key);</div>
<div class="line">            <span class="keywordflow">if</span> (data_it != table_it-&gt;second.end()) {</div>
<div class="line">                strncpy(response.result_data, data_it-&gt;second.c_str(), 2047);</div>
<div class="line">                response.affected_rows = 1;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                strncpy(response.error_message, <span class="stringliteral">&quot;キーが見つかりません&quot;</span>, 511);</div>
<div class="line">                <span class="keywordflow">return</span> response;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.disk_reads = 1;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse updateData(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        std::string key = request.key;</div>
<div class="line">        std::string value = request.value;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> table_it = tables_.find(table_name);</div>
<div class="line">        <span class="keywordflow">if</span> (table_it == tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが存在しません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> data_it = table_it-&gt;second.find(key);</div>
<div class="line">        <span class="keywordflow">if</span> (data_it == table_it-&gt;second.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;キーが見つかりません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        data_it-&gt;second = value;</div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.affected_rows = 1;</div>
<div class="line">        response.disk_writes = 1;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse deleteData(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        std::string key = request.key;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> table_it = tables_.find(table_name);</div>
<div class="line">        <span class="keywordflow">if</span> (table_it == tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが存在しません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> data_it = table_it-&gt;second.find(key);</div>
<div class="line">        <span class="keywordflow">if</span> (data_it == table_it-&gt;second.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;キーが見つかりません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        table_it-&gt;second.erase(data_it);</div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.affected_rows = 1;</div>
<div class="line">        response.disk_writes = 1;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    DatabaseResponse dropTable(<span class="keyword">const</span> DatabaseRequest&amp; request) {</div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        </div>
<div class="line">        std::unique_lock&lt;std::shared_mutex&gt; lock(data_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::string table_name = request.table_name;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> table_it = tables_.find(table_name);</div>
<div class="line">        <span class="keywordflow">if</span> (table_it == tables_.end()) {</div>
<div class="line">            strncpy(response.error_message, <span class="stringliteral">&quot;テーブルが存在しません&quot;</span>, 511);</div>
<div class="line">            <span class="keywordflow">return</span> response;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        tables_.erase(table_it);</div>
<div class="line">        response.success = <span class="keyword">true</span>;</div>
<div class="line">        response.affected_rows = 1;</div>
<div class="line">        response.disk_writes = 1;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> response;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> statisticsLoop() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::seconds(5));</div>
<div class="line">            </div>
<div class="line">            uint64_t total_reqs = total_requests_.load();</div>
<div class="line">            uint64_t total_time = total_execution_time_.load();</div>
<div class="line">            uint32_t active_conns = active_connections_.load();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (total_reqs &gt; 0) {</div>
<div class="line">                <span class="keywordtype">double</span> avg_time = (double)total_time / total_reqs;</div>
<div class="line">                <span class="keywordtype">double</span> reqs_per_sec = total_reqs / 5.0;  <span class="comment">// 5秒間隔</span></div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;=== データベース統計 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;総要求数: &quot;</span> &lt;&lt; total_reqs &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;平均処理時間: &quot;</span> &lt;&lt; avg_time &lt;&lt; <span class="stringliteral">&quot;μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;要求/秒: &quot;</span> &lt;&lt; reqs_per_sec &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;アクティブ接続: &quot;</span> &lt;&lt; active_conns &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;テーブル数: &quot;</span> &lt;&lt; tables_.size() &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// 統計リセット</span></div>
<div class="line">                total_requests_ = 0;</div>
<div class="line">                total_execution_time_ = 0;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// データベースクライアント</span></div>
<div class="line"><span class="keyword">class </span>DatabaseClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceClient&lt;DatabaseRequest, DatabaseResponse&gt; client_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DatabaseClient() : client_(<span class="stringliteral">&quot;database_service&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> createTable(<span class="keyword">const</span> std::string&amp; table_name) {</div>
<div class="line">        DatabaseRequest request;</div>
<div class="line">        request.operation = DbOperation::CREATE_TABLE;</div>
<div class="line">        strncpy(request.table_name, table_name.c_str(), 63);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> executeRequest(request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> insert(<span class="keyword">const</span> std::string&amp; table, <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value) {</div>
<div class="line">        DatabaseRequest request;</div>
<div class="line">        request.operation = DbOperation::INSERT;</div>
<div class="line">        strncpy(request.table_name, table.c_str(), 63);</div>
<div class="line">        strncpy(request.key, key.c_str(), 127);</div>
<div class="line">        strncpy(request.value, value.c_str(), 1023);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> executeRequest(request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::string select(<span class="keyword">const</span> std::string&amp; table, <span class="keyword">const</span> std::string&amp; key = <span class="stringliteral">&quot;&quot;</span>) {</div>
<div class="line">        DatabaseRequest request;</div>
<div class="line">        request.operation = DbOperation::SELECT;</div>
<div class="line">        strncpy(request.table_name, table.c_str(), 63);</div>
<div class="line">        strncpy(request.key, key.c_str(), 127);</div>
<div class="line">        </div>
<div class="line">        DatabaseResponse response;</div>
<div class="line">        <span class="keywordflow">if</span> (executeRequest(request, &amp;response)) {</div>
<div class="line">            <span class="keywordflow">return</span> std::string(response.result_data);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> update(<span class="keyword">const</span> std::string&amp; table, <span class="keyword">const</span> std::string&amp; key, <span class="keyword">const</span> std::string&amp; value) {</div>
<div class="line">        DatabaseRequest request;</div>
<div class="line">        request.operation = DbOperation::UPDATE;</div>
<div class="line">        strncpy(request.table_name, table.c_str(), 63);</div>
<div class="line">        strncpy(request.key, key.c_str(), 127);</div>
<div class="line">        strncpy(request.value, value.c_str(), 1023);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> executeRequest(request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> deleteRecord(<span class="keyword">const</span> std::string&amp; table, <span class="keyword">const</span> std::string&amp; key) {</div>
<div class="line">        DatabaseRequest request;</div>
<div class="line">        request.operation = DbOperation::DELETE;</div>
<div class="line">        strncpy(request.table_name, table.c_str(), 63);</div>
<div class="line">        strncpy(request.key, key.c_str(), 127);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> executeRequest(request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> executeRequest(<span class="keyword">const</span> DatabaseRequest&amp; request, DatabaseResponse* response = <span class="keyword">nullptr</span>) {</div>
<div class="line">        client_.sendRequest(request);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (client_.waitForResponse(10000000)) {  <span class="comment">// 10秒タイムアウト</span></div>
<div class="line">            DatabaseResponse resp = client_.getResponse();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (response) {</div>
<div class="line">                *response = resp;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!resp.success) {</div>
<div class="line">                std::cerr &lt;&lt; <span class="stringliteral">&quot;データベースエラー: &quot;</span> &lt;&lt; resp.error_message &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">return</span> resp.success;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cerr &lt;&lt; <span class="stringliteral">&quot;データベースタイムアウト&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 使用例</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// データベースサーバーを開始</span></div>
<div class="line">        HighPerformanceDatabase db;</div>
<div class="line">        db.start(4);  <span class="comment">// 4ワーカー</span></div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアントテスト</span></div>
<div class="line">        DatabaseClient client;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// テーブル作成</span></div>
<div class="line">        <span class="keywordflow">if</span> (client.createTable(<span class="stringliteral">&quot;users&quot;</span>)) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;テーブル作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// データ挿入</span></div>
<div class="line">        client.insert(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user1&quot;</span>, <span class="stringliteral">&quot;Alice&quot;</span>);</div>
<div class="line">        client.insert(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user2&quot;</span>, <span class="stringliteral">&quot;Bob&quot;</span>);</div>
<div class="line">        client.insert(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user3&quot;</span>, <span class="stringliteral">&quot;Charlie&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// データ取得</span></div>
<div class="line">        std::string result = client.select(<span class="stringliteral">&quot;users&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;全ユーザー:\n&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 特定データ取得</span></div>
<div class="line">        std::string alice = client.select(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user1&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;user1: &quot;</span> &lt;&lt; alice &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// データ更新</span></div>
<div class="line">        client.update(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user1&quot;</span>, <span class="stringliteral">&quot;Alice Smith&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// データ削除</span></div>
<div class="line">        client.deleteRecord(<span class="stringliteral">&quot;users&quot;</span>, <span class="stringliteral">&quot;user3&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 最終結果確認</span></div>
<div class="line">        result = client.select(<span class="stringliteral">&quot;users&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;最終結果:\n&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー停止</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(2));</div>
<div class="line">        db.stop();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md304"></a>
🛠️ パフォーマンス最適化テクニック</h1>
<h2><a class="anchor" id="autotoc_md305"></a>
1. 非同期処理とタイムアウト管理</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;future&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AsyncServiceClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceClient&lt;RequestType, ResponseType&gt; client_;</div>
<div class="line">    std::unordered_map&lt;uint64_t, std::future&lt;ResponseType&gt;&gt; pending_requests_;</div>
<div class="line">    std::mutex requests_mutex_;</div>
<div class="line">    std::atomic&lt;uint64_t&gt; request_counter_{0};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    AsyncServiceClient(<span class="keyword">const</span> std::string&amp; service_name) : client_(service_name) {}</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 非同期要求送信</span></div>
<div class="line">    uint64_t sendRequestAsync(<span class="keyword">const</span> RequestType&amp; request) {</div>
<div class="line">        uint64_t request_id = request_counter_++;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 非同期タスクを作成</span></div>
<div class="line">        <span class="keyword">auto</span> future = std::async(std::launch::async, [<span class="keyword">this</span>, request]() {</div>
<div class="line">            client_.sendRequest(request);</div>
<div class="line">            <span class="keywordflow">if</span> (client_.waitForResponse(5000000)) {  <span class="comment">// 5秒タイムアウト</span></div>
<div class="line">                return client_.getResponse();</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Request timeout&quot;</span>);</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        {</div>
<div class="line">            std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">            pending_requests_[request_id] = std::move(future);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> request_id;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 応答確認（ノンブロッキング）</span></div>
<div class="line">    <span class="keywordtype">bool</span> checkResponse(uint64_t request_id, ResponseType&amp; response) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = pending_requests_.find(request_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it == pending_requests_.end()) {</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 完了確認</span></div>
<div class="line">        <span class="keywordflow">if</span> (it-&gt;second.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                response = it-&gt;second.get();</div>
<div class="line">                pending_requests_.erase(it);</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                pending_requests_.erase(it);</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 応答待機（ブロッキング）</span></div>
<div class="line">    ResponseType waitForResponse(uint64_t request_id, </div>
<div class="line">                                std::chrono::milliseconds timeout = std::chrono::milliseconds(5000)) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = pending_requests_.find(request_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it == pending_requests_.end()) {</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Request not found&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// タイムアウト付き待機</span></div>
<div class="line">        <span class="keywordflow">if</span> (it-&gt;second.wait_for(timeout) == std::future_status::ready) {</div>
<div class="line">            <span class="keywordflow">try</span> {</div>
<div class="line">                ResponseType response = it-&gt;second.get();</div>
<div class="line">                pending_requests_.erase(it);</div>
<div class="line">                <span class="keywordflow">return</span> response;</div>
<div class="line">            } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">                pending_requests_.erase(it);</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            pending_requests_.erase(it);</div>
<div class="line">            <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Request timeout&quot;</span>);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 一括要求送信</span></div>
<div class="line">    std::vector&lt;uint64_t&gt; sendBatchRequests(<span class="keyword">const</span> std::vector&lt;RequestType&gt;&amp; requests) {</div>
<div class="line">        std::vector&lt;uint64_t&gt; request_ids;</div>
<div class="line">        request_ids.reserve(requests.size());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; request : requests) {</div>
<div class="line">            request_ids.push_back(sendRequestAsync(request));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> request_ids;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 一括応答受信</span></div>
<div class="line">    std::vector&lt;ResponseType&gt; waitForBatchResponses(<span class="keyword">const</span> std::vector&lt;uint64_t&gt;&amp; request_ids,</div>
<div class="line">                                                   std::chrono::milliseconds timeout = std::chrono::milliseconds(5000)) {</div>
<div class="line">        std::vector&lt;ResponseType&gt; responses;</div>
<div class="line">        responses.reserve(request_ids.size());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (uint64_t request_id : request_ids) {</div>
<div class="line">            responses.push_back(waitForResponse(request_id, timeout));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> responses;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 保留中の要求数</span></div>
<div class="line">    <span class="keywordtype">size_t</span> getPendingRequestCount()<span class="keyword"> const </span>{</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        <span class="keywordflow">return</span> pending_requests_.size();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md306"></a>
2. 接続プールとロードバランシング</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ServiceConnectionPool {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;ServiceClient&lt;RequestType, ResponseType&gt;&gt;&gt; clients_;</div>
<div class="line">    std::atomic&lt;size_t&gt; round_robin_index_{0};</div>
<div class="line">    std::mutex pool_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ServiceConnectionPool(<span class="keyword">const</span> std::string&amp; service_name, <span class="keywordtype">size_t</span> pool_size = 4) {</div>
<div class="line">        clients_.reserve(pool_size);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; pool_size; ++i) {</div>
<div class="line">            clients_.push_back(std::make_unique&lt;ServiceClient&lt;RequestType, ResponseType&gt;&gt;(service_name));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ラウンドロビン方式でクライアント選択</span></div>
<div class="line">    ResponseType sendRequestRoundRobin(<span class="keyword">const</span> RequestType&amp; request) {</div>
<div class="line">        <span class="keywordtype">size_t</span> index = round_robin_index_++ % clients_.size();</div>
<div class="line">        <span class="keywordflow">return</span> sendRequestToClient(index, request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 最も負荷の少ないクライアントを選択</span></div>
<div class="line">    ResponseType sendRequestLeastLoaded(<span class="keyword">const</span> RequestType&amp; request) {</div>
<div class="line">        <span class="comment">// 実装では各クライアントの負荷を監視</span></div>
<div class="line">        <span class="comment">// この例では簡略化してランダム選択</span></div>
<div class="line">        <span class="keywordtype">size_t</span> index = rand() % clients_.size();</div>
<div class="line">        <span class="keywordflow">return</span> sendRequestToClient(index, request);</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// 並列要求処理</span></div>
<div class="line">    std::vector&lt;ResponseType&gt; sendParallelRequests(<span class="keyword">const</span> std::vector&lt;RequestType&gt;&amp; requests) {</div>
<div class="line">        std::vector&lt;std::future&lt;ResponseType&gt;&gt; futures;</div>
<div class="line">        futures.reserve(requests.size());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; requests.size(); ++i) {</div>
<div class="line">            <span class="keywordtype">size_t</span> client_index = i % clients_.size();</div>
<div class="line">            </div>
<div class="line">            futures.push_back(std::async(std::launch::async, [<span class="keyword">this</span>, client_index, &amp;requests, i]() {</div>
<div class="line">                <span class="keywordflow">return</span> sendRequestToClient(client_index, requests[i]);</div>
<div class="line">            }));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;ResponseType&gt; responses;</div>
<div class="line">        responses.reserve(requests.size());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; future : futures) {</div>
<div class="line">            responses.push_back(future.get());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> responses;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ResponseType sendRequestToClient(<span class="keywordtype">size_t</span> client_index, <span class="keyword">const</span> RequestType&amp; request) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(pool_mutex_);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span>&amp; client = clients_[client_index];</div>
<div class="line">        client-&gt;sendRequest(request);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (client-&gt;waitForResponse(5000000)) {  <span class="comment">// 5秒タイムアウト</span></div>
<div class="line">            <span class="keywordflow">return</span> client-&gt;getResponse();</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Service request timeout&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md307"></a>
📊 パフォーマンス測定とベンチマーク</h1>
<h2><a class="anchor" id="autotoc_md308"></a>
詳細ベンチマーク</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;numeric&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iomanip&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ServicePerformanceBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    std::vector&lt;double&gt; latencies_;</div>
<div class="line">    std::vector&lt;double&gt; throughputs_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> runServiceBenchmark() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== Service通信ベンチマーク開始 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 1. レイテンシテスト</span></div>
<div class="line">        measureLatency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. スループットテスト</span></div>
<div class="line">        measureThroughput();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. 同時接続テスト</span></div>
<div class="line">        measureConcurrency();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 4. 長時間ストレステスト</span></div>
<div class="line">        measureLongTermStability();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> measureLatency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;レイテンシ測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ServiceServer&lt;int, int&gt; server(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;latency_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">                    int request = server.getRequest();</div>
<div class="line">                    server.sendResponse(request * 2);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        latencies_.clear();</div>
<div class="line">        latencies_.reserve(1000);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアント側測定</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            client.sendRequest(i);</div>
<div class="line">            <span class="keywordflow">if</span> (client.waitForResponse(1000000)) {  <span class="comment">// 1秒タイムアウト</span></div>
<div class="line">                <span class="keywordtype">int</span> response = client.getResponse();</div>
<div class="line">                </div>
<div class="line">                <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> latency = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">                    end - start).count();</div>
<div class="line">                </div>
<div class="line">                latencies_.push_back(latency);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        analyzeLatency();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureThroughput() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;スループット測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ServiceServer&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; server(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        ServiceClient&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt; client(<span class="stringliteral">&quot;throughput_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;size_t&gt; data_sizes = {10, 100, 1000, 10000};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> size : data_sizes) {</div>
<div class="line">            measureThroughputForSize(server, client, size);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureThroughputForSize(ServiceServer&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt;&amp; server,</div>
<div class="line">                                 ServiceClient&lt;std::vector&lt;int&gt;, std::vector&lt;int&gt;&gt;&amp; client,</div>
<div class="line">                                 <span class="keywordtype">size_t</span> data_size) {</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; test_data(data_size);</div>
<div class="line">        std::iota(test_data.begin(), test_data.end(), 1);</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">const</span> <span class="keywordtype">int</span> iterations = 100;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;server, iterations]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">                    auto request = server.getRequest();</div>
<div class="line">                    <span class="comment">// 簡単な処理（要素の2倍）</span></div>
<div class="line">                    for (auto&amp; val : request) {</div>
<div class="line">                        val *= 2;</div>
<div class="line">                    }</div>
<div class="line">                    server.sendResponse(request);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアント側測定</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iterations; ++i) {</div>
<div class="line">            client.sendRequest(test_data);</div>
<div class="line">            <span class="keywordflow">if</span> (client.waitForResponse(5000000)) {  <span class="comment">// 5秒タイムアウト</span></div>
<div class="line">                <span class="keyword">auto</span> response = client.getResponse();</div>
<div class="line">                <span class="comment">// 応答確認</span></div>
<div class="line">                assert(response.size() == data_size);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">            end - start).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> throughput = (double)(iterations * data_size * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)) / duration / 1024.0;  <span class="comment">// KB/s</span></div>
<div class="line">        <span class="keywordtype">double</span> message_rate = (double)iterations / duration * 1000.0;  <span class="comment">// msg/s</span></div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;データサイズ &quot;</span> &lt;&lt; data_size &lt;&lt; <span class="stringliteral">&quot; 要素:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  スループット: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) </div>
<div class="line">                  &lt;&lt; throughput &lt;&lt; <span class="stringliteral">&quot; KB/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  メッセージレート: &quot;</span> &lt;&lt; std::setprecision(0) </div>
<div class="line">                  &lt;&lt; message_rate &lt;&lt; <span class="stringliteral">&quot; msg/s&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureConcurrency() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;同時接続性能測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ServiceServer&lt;int, int&gt; server(<span class="stringliteral">&quot;concurrency_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 1000; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">                    int request = server.getRequest();</div>
<div class="line">                    <span class="comment">// 計算負荷のシミュレート</span></div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">                    server.sendResponse(request + 1);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        std::vector&lt;int&gt; client_counts = {1, 2, 4, 8, 16};</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> client_count : client_counts) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            std::vector&lt;std::thread&gt; client_threads;</div>
<div class="line">            std::atomic&lt;int&gt; completed_requests{0};</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; client_count; ++i) {</div>
<div class="line">                client_threads.emplace_back([&amp;completed_requests, i]() {</div>
<div class="line">                    ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;concurrency_test&quot;</span>);</div>
<div class="line">                    </div>
<div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 10; ++j) {</div>
<div class="line">                        client.sendRequest(i * 10 + j);</div>
<div class="line">                        <span class="keywordflow">if</span> (client.waitForResponse(2000000)) {  <span class="comment">// 2秒タイムアウト</span></div>
<div class="line">                            completed_requests++;</div>
<div class="line">                        }</div>
<div class="line">                    }</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : client_threads) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">            <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(</div>
<div class="line">                end - start).count();</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">double</span> reqs_per_sec = (double)completed_requests / duration * 1000.0;</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;同時クライアント数 &quot;</span> &lt;&lt; client_count &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  完了要求数: &quot;</span> &lt;&lt; completed_requests &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  要求/秒: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(1) </div>
<div class="line">                      &lt;&lt; reqs_per_sec &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> measureLongTermStability() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;長期安定性測定中...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        ServiceServer&lt;int, int&gt; server(<span class="stringliteral">&quot;stability_test&quot;</span>);</div>
<div class="line">        ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;stability_test&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        std::atomic&lt;bool&gt; running{<span class="keyword">true</span>};</div>
<div class="line">        std::atomic&lt;int&gt; success_count{0};</div>
<div class="line">        std::atomic&lt;int&gt; failure_count{0};</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// サーバー側スレッド</span></div>
<div class="line">        std::thread server_thread([&amp;server, &amp;running]() {</div>
<div class="line">            <span class="keywordflow">while</span> (running) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">                    int request = server.getRequest();</div>
<div class="line">                    server.sendResponse(request);</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// クライアント側スレッド</span></div>
<div class="line">        std::thread client_thread([&amp;client, &amp;running, &amp;success_count, &amp;failure_count]() {</div>
<div class="line">            <span class="keywordtype">int</span> request_id = 0;</div>
<div class="line">            <span class="keywordflow">while</span> (running) {</div>
<div class="line">                client.sendRequest(request_id++);</div>
<div class="line">                <span class="keywordflow">if</span> (client.waitForResponse(1000000)) {  <span class="comment">// 1秒タイムアウト</span></div>
<div class="line">                    success_count++;</div>
<div class="line">                } <span class="keywordflow">else</span> {</div>
<div class="line">                    failure_count++;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 30秒間実行</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::seconds(30));</div>
<div class="line">        running = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        client_thread.join();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">int</span> total_requests = success_count + failure_count;</div>
<div class="line">        <span class="keywordtype">double</span> success_rate = (double)success_count / total_requests * 100.0;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;長期安定性結果:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  総要求数: &quot;</span> &lt;&lt; total_requests &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  成功数: &quot;</span> &lt;&lt; success_count &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  失敗数: &quot;</span> &lt;&lt; failure_count &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  成功率: &quot;</span> &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) </div>
<div class="line">                  &lt;&lt; success_rate &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> analyzeLatency() {</div>
<div class="line">        <span class="keywordflow">if</span> (latencies_.empty()) <span class="keywordflow">return</span>;</div>
<div class="line">        </div>
<div class="line">        std::sort(latencies_.begin(), latencies_.end());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> mean = std::accumulate(latencies_.begin(), latencies_.end(), 0.0) / latencies_.size();</div>
<div class="line">        <span class="keywordtype">double</span> min_val = latencies_.front();</div>
<div class="line">        <span class="keywordtype">double</span> max_val = latencies_.back();</div>
<div class="line">        <span class="keywordtype">double</span> p50 = latencies_[latencies_.size() * 0.5];</div>
<div class="line">        <span class="keywordtype">double</span> p95 = latencies_[latencies_.size() * 0.95];</div>
<div class="line">        <span class="keywordtype">double</span> p99 = latencies_[latencies_.size() * 0.99];</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;=== Service通信レイテンシ統計 (μs) ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;平均: &quot;</span> &lt;&lt; mean &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;最小: &quot;</span> &lt;&lt; min_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;最大: &quot;</span> &lt;&lt; max_val &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;50%ile: &quot;</span> &lt;&lt; p50 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;95%ile: &quot;</span> &lt;&lt; p95 &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;99%ile: &quot;</span> &lt;&lt; p99 &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (p99 &lt; 100.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;🏆 優秀: 99%のレイテンシが100μs以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p99 &lt; 1000.0) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;👍 良好: 99%のレイテンシが1ms以下&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;⚠️  要改善: レイテンシが高めです&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ベンチマーク実行</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        ServicePerformanceBenchmark benchmark;</div>
<div class="line">        benchmark.runServiceBenchmark();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cerr &lt;&lt; <span class="stringliteral">&quot;ベンチマークエラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md309"></a>
❓ よくある質問</h1>
<h2><a class="anchor" id="autotoc_md310"></a>
Q1. 要求に対する応答が返ってこない場合はどうすればよいですか？</h2>
<p><b>A</b>: 以下をチェックしてください：</p><ul>
<li>サーバーが正しく動作しているか</li>
<li>タイムアウト時間が適切か</li>
<li>サーバー側で例外が発生していないか</li>
<li>トピック名が一致しているか</li>
</ul>
<h2><a class="anchor" id="autotoc_md311"></a>
Q2. 複数のクライアントが同時に要求した場合の処理順序は？</h2>
<p><b>A</b>: 基本的にFIFO（先入れ先出し）で処理されますが、サーバーの実装によって異なります。優先度が必要な場合は、カスタムキューを実装してください。</p>
<h2><a class="anchor" id="autotoc_md312"></a>
Q3. サーバーがクラッシュした場合、クライアントはどうなりますか？</h2>
<p><b>A</b>: クライアントはタイムアウトエラーを受け取ります。再接続機能を実装することで、自動的に復旧できます。</p>
<h2><a class="anchor" id="autotoc_md313"></a>
Q4. 大きなデータの送受信は可能ですか？</h2>
<p><b>A</b>: 可能ですが、共有メモリのサイズ制限があります。大きなデータは分割して送信するか、ファイルパスを送信してファイル経由で交換することをお勧めします。</p>
<h1><a class="anchor" id="autotoc_md314"></a>
🔧 トラブルシューティング</h1>
<h2><a class="anchor" id="autotoc_md315"></a>
よくある問題と解決法</h2>
<div class="fragment"><div class="line"><span class="comment">// Service通信診断ツール</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__service_8hpp.html">shm_service.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> diagnose_service_communication() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;=== Service通信診断 ===&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        <span class="comment">// 1. サーバー作成テスト</span></div>
<div class="line">        ServiceServer&lt;int, int&gt; server(<span class="stringliteral">&quot;diagnostic_service&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ サーバー作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 2. クライアント作成テスト</span></div>
<div class="line">        ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;diagnostic_service&quot;</span>);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;✅ クライアント作成成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// 3. 通信テスト</span></div>
<div class="line">        std::thread server_thread([&amp;server]() {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {</div>
<div class="line">                <span class="keywordflow">if</span> (server.hasRequest()) {</div>
<div class="line">                    int request = server.getRequest();</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;サーバー: 要求受信 &quot;</span> &lt;&lt; request &lt;&lt; std::endl;</div>
<div class="line">                    server.sendResponse(request * 2);</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;サーバー: 応答送信 &quot;</span> &lt;&lt; (request * 2) &lt;&lt; std::endl;</div>
<div class="line">                }</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            }</div>
<div class="line">        });</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(50));</div>
<div class="line">        </div>
<div class="line">        client.sendRequest(21);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;クライアント: 要求送信 21&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (client.waitForResponse(2000000)) {  <span class="comment">// 2秒タイムアウト</span></div>
<div class="line">            <span class="keywordtype">int</span> response = client.getResponse();</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;クライアント: 応答受信 &quot;</span> &lt;&lt; response &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (response == 42) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;✅ 通信テスト成功&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 通信テスト失敗: 期待値42、実際値&quot;</span> &lt;&lt; response &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 通信テスト失敗: タイムアウト&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_thread.join();</div>
<div class="line">        </div>
<div class="line">    } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;❌ 診断エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;以下を確認してください:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - 共有メモリの権限設定&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - 他のプロセスがサービスを使用中でないか&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  - システムリソースの不足&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// エラー処理パターン</span></div>
<div class="line"><span class="keywordtype">void</span> robust_service_client_example() {</div>
<div class="line">    <span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line">    </div>
<div class="line">    ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;robust_service&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_RETRIES = 3;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> TIMEOUT_MS = 5000;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> retry = 0; retry &lt; MAX_RETRIES; ++retry) {</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;要求送信 (試行 &quot;</span> &lt;&lt; (retry + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; MAX_RETRIES &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            client.sendRequest(42);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (client.waitForResponse(TIMEOUT_MS * 1000)) {  <span class="comment">// マイクロ秒に変換</span></div>
<div class="line">                <span class="keywordtype">int</span> response = client.getResponse();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;成功: 応答受信 &quot;</span> &lt;&lt; response &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span>;  <span class="comment">// 成功</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;タイムアウト: 再試行します...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;エラー: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (retry &lt; MAX_RETRIES - 1) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;再試行します...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::seconds(1));</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;最大再試行回数に達しました&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">throw</span>;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md316"></a>
📚 次のステップ</h1>
<p>Service通信をマスターしたら、以下の高度なトピックに挑戦してみましょう：</p>
<ol type="1">
<li><b><a class="el" href="md_manual_tutorials_shm_pub_sub_jp.html">📡 Pub/Sub通信</a></b> - 高速ブロードキャスト通信</li>
<li><b><a class="el" href="md_manual_tutorials_shm_action_jp.html">⚡ Action通信</a></b> - 長時間非同期処理</li>
<li><b><a class="el" href="md_manual_tutorials_python_jp.html">🐍 Python連携</a></b> - PythonでService通信</li>
</ol>
<hr  />
<h1><a class="anchor" id="autotoc_md318"></a>
📄 ライセンス情報</h1>
<p>本ドキュメントで紹介しているサンプルコードは、shared-memory-based-handy-communication-manager プロジェクトの一部として <b>Apache License 2.0</b> の下で提供されています。</p>
<ul>
<li>✅ <b>商用利用可能</b>: サンプルコードを商業プロジェクトで自由に使用</li>
<li>✅ <b>改変可能</b>: ニーズに合わせてコードを修正・拡張</li>
<li>✅ <b>再配布可能</b>: ライセンス表示を保持して再配布</li>
</ul>
<p>詳細は<a href="../LICENSE">LICENSEファイル</a>をご確認ください。</p>
<hr  />
<p>この完全ガイドで、Service通信の力を最大限に活用し、信頼性の高い分散システムを構築しましょう！ 🚀✨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Jul 5 2025 13:54:48 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
