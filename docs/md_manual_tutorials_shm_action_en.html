<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: âš¡ Action Communication Complete Guide - Master Long-Running Asynchronous Processing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">Shared-memory based Handy-communication Manager</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">âš¡ Action Communication Complete Guide - Master Long-Running Asynchronous Processing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[English | <a href="docs_jp/md_manual_tutorials_shm_action_jp.html">æ—¥æœ¬èª</a>]</p>
<h1><a class="anchor" id="autotoc_md264"></a>
ğŸ¯ What You'll Learn in This Guide</h1>
<ul>
<li><b>Deep Understanding of Action Communication</b>: From design philosophy to implementation details of asynchronous processing patterns</li>
<li><b>Long-Running Process Management</b>: Progress monitoring, cancellation functionality, error handling</li>
<li><b>Advanced Workflow Design</b>: Parallel processing, task chains, state management</li>
<li><b>Practical Applications</b>: File processing, machine learning, large-scale data transformation</li>
</ul>
<h1><a class="anchor" id="autotoc_md265"></a>
ğŸ§  Deep Understanding of Action Communication</h1>
<h2><a class="anchor" id="autotoc_md266"></a>
ğŸ—ï¸ Architecture Overview</h2>
<div class="fragment"><div class="line"><span class="comment">// Action communication internal structure</span></div>
<div class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</div>
<div class="line">â”‚                   Shared Memory Space                        â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              Action Queue                           â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [Goal 0][Goal 1][Goal 2]...[Goal N-1]             â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  Execute Pos                 Add Pos                â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              Feedback Queue                         â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [FB 0][FB 1][FB 2]...[FB N-1]                     â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  Read Pos                   Write Pos               â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚</div>
<div class="line">â”‚  â”‚              Result Queue                           â”‚    â”‚</div>
<div class="line">â”‚  â”‚ [Result 0][Result 1]...[Result N-1]               â”‚    â”‚</div>
<div class="line">â”‚  â”‚    â†‘                           â†‘                    â”‚    â”‚</div>
<div class="line">â”‚  â”‚  Read Pos                   Write Pos               â”‚    â”‚</div>
<div class="line">â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚</div>
<div class="line">â”‚                                                             â”‚</div>
<div class="line">â”‚  Action State Management:                                   â”‚</div>
<div class="line">â”‚  - Goal ID (unique identifier)                             â”‚</div>
<div class="line">â”‚  - Execution State (waiting/active/completed/cancelled/error) â”‚</div>
<div class="line">â”‚  - Progress Info (completion rate, remaining time, details) â”‚</div>
<div class="line">â”‚  - Cancel Flag (asynchronous cancellation request)         â”‚</div>
<div class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</div>
<div class="line"> </div>
<div class="line">Multiple Clients â† [shared memory] â†’ Single Server</div>
<div class="line">      â”‚                                        â”‚</div>
<div class="line">   Send Goal                          Action Execution Engine</div>
<div class="line">   Receive Feedback                           â”‚</div>
<div class="line">   Receive Result                         Long-Running Processing</div>
<div class="line">   Cancel Request                         Progress Reporting</div>
<div class="line">      â”‚                                   Result Generation</div>
<div class="line">   Asynchronous Monitoring</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md267"></a>
âš¡ Why is it Optimal for Long-Running Processes?</h2>
<p><b>1. Asynchronous Execution and Feedback</b> </p><div class="fragment"><div class="line"><span class="comment">// Basic action pattern</span></div>
<div class="line">ActionClient&lt;GoalType, ResultType, FeedbackType&gt; client(<span class="stringliteral">&quot;action_server&quot;</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Send goal (non-blocking)</span></div>
<div class="line">uint64_t goal_id = client.sendGoal(goal_data);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Continue other processing...</span></div>
<div class="line"><span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="comment">// Check feedback</span></div>
<div class="line">    FeedbackType feedback;</div>
<div class="line">    <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Progress: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Check completion</span></div>
<div class="line">    <span class="keywordflow">if</span> (client.isComplete(goal_id)) {</div>
<div class="line">        ResultType result = client.getResult(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Cancel if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> (user_cancel_request) {</div>
<div class="line">        client.cancelGoal(goal_id);</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. State Management and Progress Monitoring</b> </p><div class="fragment"><div class="line"><span class="comment">// Internal state management</span></div>
<div class="line"><span class="keyword">enum class</span> ActionStatus {</div>
<div class="line">    PENDING,        <span class="comment">// Waiting</span></div>
<div class="line">    ACTIVE,         <span class="comment">// Executing</span></div>
<div class="line">    PREEMPTED,      <span class="comment">// Interrupted</span></div>
<div class="line">    SUCCEEDED,      <span class="comment">// Successfully completed</span></div>
<div class="line">    ABORTED,        <span class="comment">// Abnormally terminated</span></div>
<div class="line">    REJECTED,       <span class="comment">// Rejected</span></div>
<div class="line">    PREEMPTING,     <span class="comment">// Cancellation in progress</span></div>
<div class="line">    RECALLING       <span class="comment">// Goal recall in progress</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Progress tracking structure</span></div>
<div class="line"><span class="keyword">struct </span>ActionProgress {</div>
<div class="line">    uint64_t goal_id;</div>
<div class="line">    ActionStatus status;</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint64_t estimated_remaining_time_us;</div>
<div class="line">    std::string status_message;</div>
<div class="line">    uint64_t last_update_time_us;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// State transition management</span></div>
<div class="line"><span class="keyword">class </span>ActionStateMachine {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> transitionTo(ActionStatus new_status) {</div>
<div class="line">        <span class="comment">// Validate state transitions</span></div>
<div class="line">        <span class="keywordflow">if</span> (isValidTransition(current_status_, new_status)) {</div>
<div class="line">            current_status_ = new_status;</div>
<div class="line">            last_update_time_ = getCurrentTimeUs();</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">bool</span> isValidTransition(ActionStatus from, ActionStatus to) {</div>
<div class="line">        <span class="comment">// Define valid state transitions</span></div>
<div class="line">        <span class="keyword">static</span> <span class="keyword">const</span> std::map&lt;ActionStatus, std::set&lt;ActionStatus&gt;&gt; valid_transitions = {</div>
<div class="line">            {PENDING, {ACTIVE, REJECTED, PREEMPTING}},</div>
<div class="line">            {ACTIVE, {SUCCEEDED, ABORTED, PREEMPTING}},</div>
<div class="line">            {PREEMPTING, {PREEMPTED}},</div>
<div class="line">            <span class="comment">// ... other transitions</span></div>
<div class="line">        };</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> it = valid_transitions.find(from);</div>
<div class="line">        <span class="keywordflow">return</span> it != valid_transitions.end() &amp;&amp; </div>
<div class="line">               it-&gt;second.find(to) != it-&gt;second.end();</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md268"></a>
ğŸš€ Basic Usage Examples</h1>
<h2><a class="anchor" id="autotoc_md269"></a>
1. File Processing Action</h2>
<p><b>Server Side:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define action data structures</span></div>
<div class="line"><span class="keyword">struct </span>FileProcessingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_filename[256];</div>
<div class="line">    <span class="keywordtype">char</span> output_filename[256];</div>
<div class="line">    <span class="keywordtype">int</span> processing_type;  <span class="comment">// 0: compress, 1: encrypt, 2: convert</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FileProcessingResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    uint64_t input_file_size;</div>
<div class="line">    uint64_t output_file_size;</div>
<div class="line">    uint64_t processing_time_us;</div>
<div class="line">    <span class="keywordtype">char</span> error_message[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>FileProcessingFeedback {</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint64_t bytes_processed;</div>
<div class="line">    uint64_t estimated_remaining_time_us;</div>
<div class="line">    <span class="keywordtype">char</span> current_operation[128];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>FileProcessingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;FileProcessingGoal, FileProcessingResult, FileProcessingFeedback&gt; server_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingServer() : server_(<span class="stringliteral">&quot;file_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“ File Processing Action Server started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                FileProcessingGoal goal = server_.getGoal();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“¥ New goal: Process &quot;</span> &lt;&lt; goal.input_filename &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Start processing in separate thread</span></div>
<div class="line">                std::thread processing_thread([<span class="keyword">this</span>, goal]() {</div>
<div class="line">                    processFile(goal);</div>
<div class="line">                });</div>
<div class="line">                processing_thread.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processFile(<span class="keyword">const</span> FileProcessingGoal&amp; goal) {</div>
<div class="line">        FileProcessingResult result;</div>
<div class="line">        result.success = <span class="keyword">true</span>;</div>
<div class="line">        result.processing_time_us = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::steady_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// Simulate file processing with progress updates</span></div>
<div class="line">            std::ifstream input(goal.input_filename, std::ios::binary | std::ios::ate);</div>
<div class="line">            <span class="keywordflow">if</span> (!input.is_open()) {</div>
<div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Cannot open input file&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            result.input_file_size = input.tellg();</div>
<div class="line">            input.seekg(0);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Process file in chunks with progress reporting</span></div>
<div class="line">            <span class="keyword">const</span> <span class="keywordtype">size_t</span> chunk_size = 1024 * 1024;  <span class="comment">// 1MB chunks</span></div>
<div class="line">            std::vector&lt;char&gt; buffer(chunk_size);</div>
<div class="line">            <span class="keywordtype">size_t</span> total_processed = 0;</div>
<div class="line">            </div>
<div class="line">            std::ofstream output(goal.output_filename, std::ios::binary);</div>
<div class="line">            <span class="keywordflow">if</span> (!output.is_open()) {</div>
<div class="line">                <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;Cannot create output file&quot;</span>);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">while</span> (total_processed &lt; result.input_file_size) {</div>
<div class="line">                <span class="comment">// Check for cancellation</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isCancellationRequested()) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš« Processing cancelled by client&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                    server_.setAborted();</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Read chunk</span></div>
<div class="line">                <span class="keywordtype">size_t</span> to_read = std::min(chunk_size, </div>
<div class="line">                                        result.input_file_size - total_processed);</div>
<div class="line">                input.read(buffer.data(), to_read);</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Simulate processing time</span></div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Write processed chunk</span></div>
<div class="line">                output.write(buffer.data(), to_read);</div>
<div class="line">                total_processed += to_read;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Send feedback</span></div>
<div class="line">                FileProcessingFeedback feedback;</div>
<div class="line">                feedback.progress_percent = (float)total_processed / result.input_file_size * 100.0f;</div>
<div class="line">                feedback.bytes_processed = total_processed;</div>
<div class="line">                feedback.estimated_remaining_time_us = </div>
<div class="line">                    calculateRemainingTime(total_processed, result.input_file_size, start_time);</div>
<div class="line">                strcpy(feedback.current_operation, <span class="stringliteral">&quot;Processing data chunk&quot;</span>);</div>
<div class="line">                </div>
<div class="line">                server_.sendFeedback(feedback);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“Š Progress: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            result.output_file_size = total_processed;</div>
<div class="line">            </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            result.success = <span class="keyword">false</span>;</div>
<div class="line">            strcpy(result.error_message, e.what());</div>
<div class="line">            server_.setAborted();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::steady_clock::now();</div>
<div class="line">        result.processing_time_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            end_time - start_time).count();</div>
<div class="line">        </div>
<div class="line">        server_.setSucceeded(result);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… File processing completed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    uint64_t calculateRemainingTime(<span class="keywordtype">size_t</span> processed, <span class="keywordtype">size_t</span> total, </div>
<div class="line">                                   std::chrono::steady_clock::time_point start_time) {</div>
<div class="line">        <span class="keyword">auto</span> elapsed = std::chrono::steady_clock::now() - start_time;</div>
<div class="line">        <span class="keyword">auto</span> elapsed_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (processed == 0) <span class="keywordflow">return</span> 0;</div>
<div class="line">        </div>
<div class="line">        uint64_t total_estimated_time = (elapsed_us * total) / processed;</div>
<div class="line">        <span class="keywordflow">return</span> total_estimated_time - elapsed_us;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="ttc" id="ashm__action_8hpp_html"><div class="ttname"><a href="shm__action_8hpp.html">shm_action.hpp</a></div><div class="ttdoc">ãƒ¡ãƒ¢ãƒªã®æ ¼ç´æ–¹æ³•ã‚’è¦å®šã™ã‚‹ã‚¯ãƒ©ã‚¹ã®å®šç¾©</div></div>
</div><!-- fragment --><p><b>Client Side:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>FileProcessingClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionClient&lt;FileProcessingGoal, FileProcessingResult, FileProcessingFeedback&gt; client_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    FileProcessingClient() : client_(<span class="stringliteral">&quot;file_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> processFileAsync(<span class="keyword">const</span> std::string&amp; input_file, <span class="keyword">const</span> std::string&amp; output_file, <span class="keywordtype">int</span> type) {</div>
<div class="line">        FileProcessingGoal goal;</div>
<div class="line">        strcpy(goal.input_filename, input_file.c_str());</div>
<div class="line">        strcpy(goal.output_filename, output_file.c_str());</div>
<div class="line">        goal.processing_type = type;</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš€ Sending file processing goal...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        uint64_t goal_id = client_.sendGoal(goal);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Monitor progress</span></div>
<div class="line">        <span class="keywordflow">while</span> (!client_.isComplete(goal_id)) {</div>
<div class="line">            FileProcessingFeedback feedback;</div>
<div class="line">            <span class="keywordflow">if</span> (client_.getFeedback(goal_id, feedback)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“ˆ Progress: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;% - &quot;</span></div>
<div class="line">                          &lt;&lt; feedback.current_operation &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“Š Processed: &quot;</span> &lt;&lt; feedback.bytes_processed &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;â±ï¸ Estimated remaining: &quot;</span> </div>
<div class="line">                          &lt;&lt; (feedback.estimated_remaining_time_us / 1000000.0) &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Check for user input to cancel</span></div>
<div class="line">            <span class="comment">// In real application, you&#39;d check for actual user input</span></div>
<div class="line">            <span class="keyword">static</span> <span class="keywordtype">int</span> counter = 0;</div>
<div class="line">            <span class="keywordflow">if</span> (++counter &gt; 50) {  <span class="comment">// Simulate cancel after 5 seconds</span></div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ User requested cancellation&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                client_.cancelGoal(goal_id);</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Get final result</span></div>
<div class="line">        <span class="keywordflow">if</span> (client_.getState(goal_id) == ActionState::SUCCEEDED) {</div>
<div class="line">            FileProcessingResult result = client_.getResult(goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ‰ File processing completed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“ Input size: &quot;</span> &lt;&lt; result.input_file_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“ Output size: &quot;</span> &lt;&lt; result.output_file_size &lt;&lt; <span class="stringliteral">&quot; bytes&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;â±ï¸ Processing time: &quot;</span> &lt;&lt; (result.processing_time_us / 1000000.0) &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ File processing failed or was cancelled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    FileProcessingClient client;</div>
<div class="line">    client.processFileAsync(<span class="stringliteral">&quot;input.txt&quot;</span>, <span class="stringliteral">&quot;output.txt&quot;</span>, 0);</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md270"></a>
2. Machine Learning Training Action</h2>
<div class="fragment"><div class="line"><span class="comment">// Advanced ML training example</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;random&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ML Training data structures</span></div>
<div class="line"><span class="keyword">struct </span>MLTrainingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> dataset_path[256];</div>
<div class="line">    <span class="keywordtype">char</span> model_type[64];</div>
<div class="line">    <span class="keywordtype">int</span> epochs;</div>
<div class="line">    <span class="keywordtype">float</span> learning_rate;</div>
<div class="line">    <span class="keywordtype">int</span> batch_size;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingResult {</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">float</span> final_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> final_loss;</div>
<div class="line">    uint64_t training_time_us;</div>
<div class="line">    <span class="keywordtype">char</span> model_save_path[256];</div>
<div class="line">    <span class="keywordtype">char</span> error_message[512];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MLTrainingFeedback {</div>
<div class="line">    <span class="keywordtype">int</span> current_epoch;</div>
<div class="line">    <span class="keywordtype">int</span> total_epochs;</div>
<div class="line">    <span class="keywordtype">float</span> current_accuracy;</div>
<div class="line">    <span class="keywordtype">float</span> current_loss;</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;</div>
<div class="line">    uint64_t estimated_remaining_time_us;</div>
<div class="line">    <span class="keywordtype">char</span> phase[64];  <span class="comment">// &quot;loading&quot;, &quot;training&quot;, &quot;validation&quot;, &quot;saving&quot;</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MLTrainingServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;MLTrainingGoal, MLTrainingResult, MLTrainingFeedback&gt; server_;</div>
<div class="line">    std::random_device rd_;</div>
<div class="line">    std::mt19937 gen_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    MLTrainingServer() : server_(<span class="stringliteral">&quot;ml_trainer&quot;</span>), gen_(rd_()) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ§  ML Training Action Server started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                MLTrainingGoal goal = server_.getGoal();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ¯ New training goal: &quot;</span> &lt;&lt; goal.model_type </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; for &quot;</span> &lt;&lt; goal.epochs &lt;&lt; <span class="stringliteral">&quot; epochs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                std::thread training_thread([<span class="keyword">this</span>, goal]() {</div>
<div class="line">                    trainModel(goal);</div>
<div class="line">                });</div>
<div class="line">                training_thread.detach();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> trainModel(<span class="keyword">const</span> MLTrainingGoal&amp; goal) {</div>
<div class="line">        MLTrainingResult result;</div>
<div class="line">        result.success = <span class="keyword">true</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> start_time = std::chrono::steady_clock::now();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// Phase 1: Data Loading</span></div>
<div class="line">            sendProgressUpdate(0, goal.epochs, 0.0f, 0.0f, 0.0f, <span class="stringliteral">&quot;loading&quot;</span>, start_time);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Phase 2: Training Loop</span></div>
<div class="line">            std::uniform_real_distribution&lt;&gt; accuracy_dist(0.1, 0.95);</div>
<div class="line">            std::uniform_real_distribution&lt;&gt; loss_dist(0.05, 2.0);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordtype">float</span> best_accuracy = 0.0f;</div>
<div class="line">            <span class="keywordtype">float</span> current_loss = 2.0f;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> epoch = 1; epoch &lt;= goal.epochs; ++epoch) {</div>
<div class="line">                <span class="comment">// Check for cancellation</span></div>
<div class="line">                <span class="keywordflow">if</span> (server_.isCancellationRequested()) {</div>
<div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš« Training cancelled at epoch &quot;</span> &lt;&lt; epoch &lt;&lt; std::endl;</div>
<div class="line">                    server_.setAborted();</div>
<div class="line">                    <span class="keywordflow">return</span>;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Simulate training progress</span></div>
<div class="line">                <span class="keywordtype">float</span> epoch_progress = (float)epoch / goal.epochs;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Simulate improving accuracy and decreasing loss</span></div>
<div class="line">                <span class="keywordtype">float</span> current_accuracy = accuracy_dist(gen_) * epoch_progress + 0.1f;</div>
<div class="line">                current_loss = loss_dist(gen_) * (1.0f - epoch_progress * 0.8f);</div>
<div class="line">                </div>
<div class="line">                <span class="keywordflow">if</span> (current_accuracy &gt; best_accuracy) {</div>
<div class="line">                    best_accuracy = current_accuracy;</div>
<div class="line">                }</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Send progress update</span></div>
<div class="line">                sendProgressUpdate(epoch, goal.epochs, current_accuracy, current_loss, </div>
<div class="line">                                 epoch_progress * 100.0f, <span class="stringliteral">&quot;training&quot;</span>, start_time);</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“ˆ Epoch &quot;</span> &lt;&lt; epoch &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; goal.epochs </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot; - Accuracy: &quot;</span> &lt;&lt; current_accuracy </div>
<div class="line">                          &lt;&lt; <span class="stringliteral">&quot;, Loss: &quot;</span> &lt;&lt; current_loss &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Simulate epoch training time</span></div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(200));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Phase 3: Model Saving</span></div>
<div class="line">            sendProgressUpdate(goal.epochs, goal.epochs, best_accuracy, current_loss, </div>
<div class="line">                             95.0f, <span class="stringliteral">&quot;saving&quot;</span>, start_time);</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(300));</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Set final results</span></div>
<div class="line">            result.final_accuracy = best_accuracy;</div>
<div class="line">            result.final_loss = current_loss;</div>
<div class="line">            strcpy(result.model_save_path, <span class="stringliteral">&quot;/models/trained_model.pkl&quot;</span>);</div>
<div class="line">            </div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            result.success = <span class="keyword">false</span>;</div>
<div class="line">            strcpy(result.error_message, e.what());</div>
<div class="line">            server_.setAborted();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> end_time = std::chrono::steady_clock::now();</div>
<div class="line">        result.training_time_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            end_time - start_time).count();</div>
<div class="line">        </div>
<div class="line">        server_.setSucceeded(result);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ‰ Model training completed! Final accuracy: &quot;</span> </div>
<div class="line">                  &lt;&lt; result.final_accuracy &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> sendProgressUpdate(<span class="keywordtype">int</span> current_epoch, <span class="keywordtype">int</span> total_epochs, <span class="keywordtype">float</span> accuracy, <span class="keywordtype">float</span> loss,</div>
<div class="line">                           <span class="keywordtype">float</span> progress_percent, <span class="keyword">const</span> <span class="keywordtype">char</span>* phase,</div>
<div class="line">                           std::chrono::steady_clock::time_point start_time) {</div>
<div class="line">        MLTrainingFeedback feedback;</div>
<div class="line">        feedback.current_epoch = current_epoch;</div>
<div class="line">        feedback.total_epochs = total_epochs;</div>
<div class="line">        feedback.current_accuracy = accuracy;</div>
<div class="line">        feedback.current_loss = loss;</div>
<div class="line">        feedback.progress_percent = progress_percent;</div>
<div class="line">        strcpy(feedback.phase, phase);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Estimate remaining time</span></div>
<div class="line">        <span class="keyword">auto</span> elapsed = std::chrono::steady_clock::now() - start_time;</div>
<div class="line">        <span class="keyword">auto</span> elapsed_us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(elapsed).count();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (progress_percent &gt; 0) {</div>
<div class="line">            uint64_t total_estimated_time = (elapsed_us * 100) / progress_percent;</div>
<div class="line">            feedback.estimated_remaining_time_us = total_estimated_time - elapsed_us;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            feedback.estimated_remaining_time_us = 0;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        server_.sendFeedback(feedback);</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Client usage</span></div>
<div class="line"><span class="keywordtype">void</span> trainNeuralNetwork() {</div>
<div class="line">    ActionClient&lt;MLTrainingGoal, MLTrainingResult, MLTrainingFeedback&gt; client(<span class="stringliteral">&quot;ml_trainer&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    MLTrainingGoal goal;</div>
<div class="line">    strcpy(goal.dataset_path, <span class="stringliteral">&quot;/data/training_set.csv&quot;</span>);</div>
<div class="line">    strcpy(goal.model_type, <span class="stringliteral">&quot;neural_network&quot;</span>);</div>
<div class="line">    goal.epochs = 50;</div>
<div class="line">    goal.learning_rate = 0.001f;</div>
<div class="line">    goal.batch_size = 32;</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš€ Starting neural network training...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    uint64_t goal_id = client.sendGoal(goal);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Monitor training progress</span></div>
<div class="line">    <span class="keywordflow">while</span> (!client.isComplete(goal_id)) {</div>
<div class="line">        MLTrainingFeedback feedback;</div>
<div class="line">        <span class="keywordflow">if</span> (client.getFeedback(goal_id, feedback)) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ§  [&quot;</span> &lt;&lt; feedback.phase &lt;&lt; <span class="stringliteral">&quot;] Epoch &quot;</span> </div>
<div class="line">                      &lt;&lt; feedback.current_epoch &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; feedback.total_epochs</div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; - Progress: &quot;</span> &lt;&lt; feedback.progress_percent &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“Š Accuracy: &quot;</span> &lt;&lt; feedback.current_accuracy </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;, Loss: &quot;</span> &lt;&lt; feedback.current_loss &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;â±ï¸ ETA: &quot;</span> &lt;&lt; (feedback.estimated_remaining_time_us / 1000000.0) </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Get final results</span></div>
<div class="line">    <span class="keywordflow">if</span> (client.getState(goal_id) == ActionState::SUCCEEDED) {</div>
<div class="line">        MLTrainingResult result = client.getResult(goal_id);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ‰ Training completed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ¯ Final accuracy: &quot;</span> &lt;&lt; result.final_accuracy &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“‰ Final loss: &quot;</span> &lt;&lt; result.final_loss &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ’¾ Model saved to: &quot;</span> &lt;&lt; result.model_save_path &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;â±ï¸ Total training time: &quot;</span> &lt;&lt; (result.training_time_us / 1000000.0) </div>
<div class="line">                  &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ Training failed or was cancelled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md271"></a>
ğŸ”§ Advanced Features and Patterns</h1>
<h2><a class="anchor" id="autotoc_md272"></a>
3. Multi-Goal Action Server</h2>
<div class="fragment"><div class="line"><span class="comment">// Advanced server that can handle multiple concurrent goals</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ConcurrentActionServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ActionServer&lt;FileProcessingGoal, FileProcessingResult, FileProcessingFeedback&gt; server_;</div>
<div class="line">    std::map&lt;uint64_t, std::thread&gt; active_goals_;</div>
<div class="line">    std::mutex goals_mutex_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_{<span class="keyword">true</span>};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ConcurrentActionServer() : server_(<span class="stringliteral">&quot;concurrent_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    ~ConcurrentActionServer() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Wait for all active goals to complete</span></div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(goals_mutex_);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; [goal_id, thread] : active_goals_) {</div>
<div class="line">            <span class="keywordflow">if</span> (thread.joinable()) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ”„ Concurrent Action Server started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasGoal()) {</div>
<div class="line">                FileProcessingGoal goal = server_.getGoal();</div>
<div class="line">                uint64_t goal_id = server_.getCurrentGoalId();</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“¥ New goal &quot;</span> &lt;&lt; goal_id &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; goal.input_filename &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Start processing in separate thread</span></div>
<div class="line">                std::lock_guard&lt;std::mutex&gt; lock(goals_mutex_);</div>
<div class="line">                active_goals_[goal_id] = std::thread([<span class="keyword">this</span>, goal, goal_id]() {</div>
<div class="line">                    processGoal(goal, goal_id);</div>
<div class="line">                    </div>
<div class="line">                    <span class="comment">// Clean up completed goal</span></div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(goals_mutex_);</div>
<div class="line">                    active_goals_.erase(goal_id);</div>
<div class="line">                });</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> processGoal(<span class="keyword">const</span> FileProcessingGoal&amp; goal, uint64_t goal_id) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš€ Starting processing for goal &quot;</span> &lt;&lt; goal_id &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Simulate processing with regular feedback</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> progress = 0; progress &lt;= 100; progress += 10) {</div>
<div class="line">            <span class="keywordflow">if</span> (!running_ || server_.isCancellationRequested(goal_id)) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš« Goal &quot;</span> &lt;&lt; goal_id &lt;&lt; <span class="stringliteral">&quot; cancelled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                server_.setAborted(goal_id);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            FileProcessingFeedback feedback;</div>
<div class="line">            feedback.progress_percent = progress;</div>
<div class="line">            feedback.bytes_processed = progress * 1000;</div>
<div class="line">            feedback.estimated_remaining_time_us = (100 - progress) * 100000;</div>
<div class="line">            strcpy(feedback.current_operation, <span class="stringliteral">&quot;Processing chunk&quot;</span>);</div>
<div class="line">            </div>
<div class="line">            server_.sendFeedback(feedback, goal_id);</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“Š Goal &quot;</span> &lt;&lt; goal_id &lt;&lt; <span class="stringliteral">&quot; progress: &quot;</span> &lt;&lt; progress &lt;&lt; <span class="stringliteral">&quot;%&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        FileProcessingResult result;</div>
<div class="line">        result.success = <span class="keyword">true</span>;</div>
<div class="line">        result.input_file_size = 100000;</div>
<div class="line">        result.output_file_size = 95000;</div>
<div class="line">        result.processing_time_us = 5000000;  <span class="comment">// 5 seconds</span></div>
<div class="line">        strcpy(result.error_message, <span class="stringliteral">&quot;&quot;</span>);</div>
<div class="line">        </div>
<div class="line">        server_.setSucceeded(result, goal_id);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… Goal &quot;</span> &lt;&lt; goal_id &lt;&lt; <span class="stringliteral">&quot; completed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md273"></a>
4. Action Chain Workflow</h2>
<div class="fragment"><div class="line"><span class="comment">// Example of chaining multiple actions together</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;functional&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ActionWorkflow {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>WorkflowStep {</div>
<div class="line">        std::string action_name;</div>
<div class="line">        std::function&lt;void()&gt; execute;</div>
<div class="line">        std::function&lt;bool()&gt; check_completion;</div>
<div class="line">        std::function&lt;void()&gt; on_success;</div>
<div class="line">        std::function&lt;void()&gt; on_failure;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::vector&lt;WorkflowStep&gt; steps_;</div>
<div class="line">    <span class="keywordtype">size_t</span> current_step_{0};</div>
<div class="line">    <span class="keywordtype">bool</span> workflow_running_{<span class="keyword">false</span>};</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> addStep(<span class="keyword">const</span> std::string&amp; name, </div>
<div class="line">                std::function&lt;<span class="keywordtype">void</span>()&gt; execute,</div>
<div class="line">                std::function&lt;<span class="keywordtype">bool</span>()&gt; check_completion,</div>
<div class="line">                std::function&lt;<span class="keywordtype">void</span>()&gt; on_success = <span class="keyword">nullptr</span>,</div>
<div class="line">                std::function&lt;<span class="keywordtype">void</span>()&gt; on_failure = <span class="keyword">nullptr</span>) {</div>
<div class="line">        steps_.push_back({name, execute, check_completion, on_success, on_failure});</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> executeWorkflow() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ”— Starting workflow with &quot;</span> &lt;&lt; steps_.size() &lt;&lt; <span class="stringliteral">&quot; steps&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        workflow_running_ = <span class="keyword">true</span>;</div>
<div class="line">        current_step_ = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (workflow_running_ &amp;&amp; current_step_ &lt; steps_.size()) {</div>
<div class="line">            <span class="keyword">auto</span>&amp; step = steps_[current_step_];</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;â–¶ï¸ Executing step &quot;</span> &lt;&lt; (current_step_ + 1) </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; step.action_name &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Execute step</span></div>
<div class="line">            step.execute();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Wait for completion</span></div>
<div class="line">            <span class="keywordflow">while</span> (workflow_running_ &amp;&amp; !step.check_completion()) {</div>
<div class="line">                std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!workflow_running_) {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸš« Workflow cancelled&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Handle success</span></div>
<div class="line">            <span class="keywordflow">if</span> (step.on_success) {</div>
<div class="line">                step.on_success();</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;âœ… Step &quot;</span> &lt;&lt; (current_step_ + 1) &lt;&lt; <span class="stringliteral">&quot; completed&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            current_step_++;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">if</span> (workflow_running_ &amp;&amp; current_step_ &gt;= steps_.size()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ‰ Workflow completed successfully!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        workflow_running_ = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> cancelWorkflow() {</div>
<div class="line">        workflow_running_ = <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Example usage</span></div>
<div class="line"><span class="keywordtype">void</span> runDataProcessingWorkflow() {</div>
<div class="line">    ActionWorkflow workflow;</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Step 1: Download data</span></div>
<div class="line">    ActionClient&lt;FileProcessingGoal, FileProcessingResult, FileProcessingFeedback&gt; download_client(<span class="stringliteral">&quot;downloader&quot;</span>);</div>
<div class="line">    uint64_t download_goal_id;</div>
<div class="line">    </div>
<div class="line">    workflow.addStep(<span class="stringliteral">&quot;Download Data&quot;</span>,</div>
<div class="line">        [&amp;]() {</div>
<div class="line">            FileProcessingGoal goal;</div>
<div class="line">            strcpy(goal.input_filename, <span class="stringliteral">&quot;http://example.com/data.zip&quot;</span>);</div>
<div class="line">            strcpy(goal.output_filename, <span class="stringliteral">&quot;/tmp/data.zip&quot;</span>);</div>
<div class="line">            goal.processing_type = 0;</div>
<div class="line">            download_goal_id = download_client.sendGoal(goal);</div>
<div class="line">        },</div>
<div class="line">        [&amp;]() { <span class="keywordflow">return</span> download_client.isComplete(download_goal_id); },</div>
<div class="line">        [&amp;]() { std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“¥ Download completed&quot;</span> &lt;&lt; std::endl; },</div>
<div class="line">        [&amp;]() { std::cout &lt;&lt; <span class="stringliteral">&quot;âŒ Download failed&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Step 2: Extract data</span></div>
<div class="line">    ActionClient&lt;FileProcessingGoal, FileProcessingResult, FileProcessingFeedback&gt; extract_client(<span class="stringliteral">&quot;extractor&quot;</span>);</div>
<div class="line">    uint64_t extract_goal_id;</div>
<div class="line">    </div>
<div class="line">    workflow.addStep(<span class="stringliteral">&quot;Extract Data&quot;</span>,</div>
<div class="line">        [&amp;]() {</div>
<div class="line">            FileProcessingGoal goal;</div>
<div class="line">            strcpy(goal.input_filename, <span class="stringliteral">&quot;/tmp/data.zip&quot;</span>);</div>
<div class="line">            strcpy(goal.output_filename, <span class="stringliteral">&quot;/tmp/extracted/&quot;</span>);</div>
<div class="line">            goal.processing_type = 1;</div>
<div class="line">            extract_goal_id = extract_client.sendGoal(goal);</div>
<div class="line">        },</div>
<div class="line">        [&amp;]() { <span class="keywordflow">return</span> extract_client.isComplete(extract_goal_id); },</div>
<div class="line">        [&amp;]() { std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ“‚ Extraction completed&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Step 3: Process data</span></div>
<div class="line">    ActionClient&lt;MLTrainingGoal, MLTrainingResult, MLTrainingFeedback&gt; ml_client(<span class="stringliteral">&quot;ml_trainer&quot;</span>);</div>
<div class="line">    uint64_t ml_goal_id;</div>
<div class="line">    </div>
<div class="line">    workflow.addStep(<span class="stringliteral">&quot;Train Model&quot;</span>,</div>
<div class="line">        [&amp;]() {</div>
<div class="line">            MLTrainingGoal goal;</div>
<div class="line">            strcpy(goal.dataset_path, <span class="stringliteral">&quot;/tmp/extracted/dataset.csv&quot;</span>);</div>
<div class="line">            strcpy(goal.model_type, <span class="stringliteral">&quot;neural_network&quot;</span>);</div>
<div class="line">            goal.epochs = 100;</div>
<div class="line">            goal.learning_rate = 0.001f;</div>
<div class="line">            goal.batch_size = 32;</div>
<div class="line">            ml_goal_id = ml_client.sendGoal(goal);</div>
<div class="line">        },</div>
<div class="line">        [&amp;]() { <span class="keywordflow">return</span> ml_client.isComplete(ml_goal_id); },</div>
<div class="line">        [&amp;]() { std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ§  Model training completed&quot;</span> &lt;&lt; std::endl; }</div>
<div class="line">    );</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// Execute the workflow</span></div>
<div class="line">    workflow.executeWorkflow();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md274"></a>
ğŸ“Š Performance Monitoring and Metrics</h1>
<h2><a class="anchor" id="autotoc_md275"></a>
5. Action Performance Analytics</h2>
<div class="fragment"><div class="line"><span class="comment">// Performance monitoring for action servers</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__action_8hpp.html">shm_action.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;map&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ActionPerformanceMonitor {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keyword">struct </span>ActionMetrics {</div>
<div class="line">        uint64_t total_goals;</div>
<div class="line">        uint64_t successful_goals;</div>
<div class="line">        uint64_t failed_goals;</div>
<div class="line">        uint64_t cancelled_goals;</div>
<div class="line">        std::vector&lt;uint64_t&gt; execution_times_us;</div>
<div class="line">        uint64_t total_execution_time_us;</div>
<div class="line">        std::chrono::steady_clock::time_point start_time;</div>
<div class="line">    };</div>
<div class="line">    </div>
<div class="line">    std::map&lt;std::string, ActionMetrics&gt; metrics_;</div>
<div class="line">    std::mutex metrics_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">void</span> startGoal(<span class="keyword">const</span> std::string&amp; action_name, uint64_t goal_id) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(metrics_mutex_);</div>
<div class="line">        <span class="keyword">auto</span>&amp; metrics = metrics_[action_name];</div>
<div class="line">        metrics.total_goals++;</div>
<div class="line">        metrics.start_time = std::chrono::steady_clock::now();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> goalCompleted(<span class="keyword">const</span> std::string&amp; action_name, uint64_t goal_id, </div>
<div class="line">                      ActionState final_state) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(metrics_mutex_);</div>
<div class="line">        <span class="keyword">auto</span>&amp; metrics = metrics_[action_name];</div>
<div class="line">        </div>
<div class="line">        <span class="keyword">auto</span> execution_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(</div>
<div class="line">            std::chrono::steady_clock::now() - metrics.start_time).count();</div>
<div class="line">        </div>
<div class="line">        metrics.execution_times_us.push_back(execution_time);</div>
<div class="line">        metrics.total_execution_time_us += execution_time;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">switch</span> (final_state) {</div>
<div class="line">            <span class="keywordflow">case</span> ActionState::SUCCEEDED:</div>
<div class="line">                metrics.successful_goals++;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionState::ABORTED:</div>
<div class="line">                metrics.failed_goals++;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">            <span class="keywordflow">case</span> ActionState::PREEMPTED:</div>
<div class="line">                metrics.cancelled_goals++;</div>
<div class="line">                <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> printStatistics() {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(metrics_mutex_);</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\nğŸ“Š Action Performance Statistics:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; std::string(50, <span class="charliteral">&#39;=&#39;</span>) &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; [action_name, metrics] : metrics_) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;ğŸ¯ Action: &quot;</span> &lt;&lt; action_name &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Total Goals: &quot;</span> &lt;&lt; metrics.total_goals &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Successful: &quot;</span> &lt;&lt; metrics.successful_goals </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; (metrics.successful_goals * 100.0 / metrics.total_goals) &lt;&lt; <span class="stringliteral">&quot;%)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Failed: &quot;</span> &lt;&lt; metrics.failed_goals </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; (metrics.failed_goals * 100.0 / metrics.total_goals) &lt;&lt; <span class="stringliteral">&quot;%)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Cancelled: &quot;</span> &lt;&lt; metrics.cancelled_goals </div>
<div class="line">                      &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; (metrics.cancelled_goals * 100.0 / metrics.total_goals) &lt;&lt; <span class="stringliteral">&quot;%)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!metrics.execution_times_us.empty()) {</div>
<div class="line">                <span class="keyword">auto</span> avg_time = metrics.total_execution_time_us / metrics.execution_times_us.size();</div>
<div class="line">                <span class="keyword">auto</span> min_time = *std::min_element(metrics.execution_times_us.begin(), </div>
<div class="line">                                                metrics.execution_times_us.end());</div>
<div class="line">                <span class="keyword">auto</span> max_time = *std::max_element(metrics.execution_times_us.begin(), </div>
<div class="line">                                                metrics.execution_times_us.end());</div>
<div class="line">                </div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  Average execution time: &quot;</span> &lt;&lt; (avg_time / 1000000.0) &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  Min execution time: &quot;</span> &lt;&lt; (min_time / 1000000.0) &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;  Max execution time: &quot;</span> &lt;&lt; (max_time / 1000000.0) &lt;&lt; <span class="stringliteral">&quot; seconds&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md276"></a>
ğŸ¯ Best Practices and Design Patterns</h1>
<h2><a class="anchor" id="autotoc_md277"></a>
Design Guidelines</h2>
<ol type="1">
<li><b>Keep Goals and Results Focused</b> <div class="fragment"><div class="line"><span class="comment">// âœ… Good - Focused, specific goal</span></div>
<div class="line"><span class="keyword">struct </span>ImageProcessingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> input_path[256];</div>
<div class="line">    <span class="keywordtype">int</span> filter_type;</div>
<div class="line">    <span class="keywordtype">float</span> parameter;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// âŒ Avoid - Too many responsibilities</span></div>
<div class="line"><span class="keyword">struct </span>MegaProcessingGoal {</div>
<div class="line">    <span class="keywordtype">char</span> files[100][256];</div>
<div class="line">    <span class="keywordtype">int</span> operations[50];</div>
<div class="line">    <span class="keywordtype">float</span> parameters[200];</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Provide Meaningful Feedback</b> <div class="fragment"><div class="line"><span class="keyword">struct </span>ProcessingFeedback {</div>
<div class="line">    <span class="keywordtype">float</span> progress_percent;      <span class="comment">// 0-100</span></div>
<div class="line">    <span class="keywordtype">char</span> current_operation[128]; <span class="comment">// Human-readable description</span></div>
<div class="line">    uint64_t estimated_time_us;  <span class="comment">// Remaining time estimate</span></div>
<div class="line">    uint64_t processed_items;    <span class="comment">// Concrete progress measure</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Handle Cancellation Gracefully</b> <div class="fragment"><div class="line"><span class="keywordtype">void</span> processLongRunningTask() {</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; total_items; ++i) {</div>
<div class="line">        <span class="comment">// Check for cancellation regularly</span></div>
<div class="line">        <span class="keywordflow">if</span> (server_.isCancellationRequested()) {</div>
<div class="line">            cleanupPartialWork();</div>
<div class="line">            server_.setAborted();</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        processItem(i);</div>
<div class="line">        sendProgressUpdate(i, total_items);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md278"></a>
Error Handling Strategies</h2>
<ol type="1">
<li><b>Graceful Degradation</b></li>
<li><b>Retry Mechanisms for Transient Failures</b></li>
<li><b>Detailed Error Reporting</b></li>
<li><b>Partial Result Preservation</b></li>
</ol>
<h1><a class="anchor" id="autotoc_md279"></a>
ğŸ” Troubleshooting Common Issues</h1>
<h2><a class="anchor" id="autotoc_md280"></a>
Action State Issues</h2>
<ol type="1">
<li><b>Stuck in PENDING State</b>: Check if action server is running and processing goals</li>
<li><b>Premature ABORTED State</b>: Verify error handling and exception management</li>
<li><b>Missing Feedback</b>: Ensure regular feedback updates in long-running operations</li>
</ol>
<h2><a class="anchor" id="autotoc_md281"></a>
Performance Issues</h2>
<ol type="1">
<li><b>Slow Action Execution</b>: Profile bottlenecks in goal processing</li>
<li><b>Memory Leaks</b>: Verify proper cleanup in action callbacks</li>
<li><b>Deadlocks</b>: Review threading and synchronization patterns</li>
</ol>
<h1><a class="anchor" id="autotoc_md282"></a>
ğŸ“š Next Steps</h1>
<ul>
<li><b><a class="el" href="md_manual_tutorials_shm_pub_sub_en.html">ğŸ”„ Pub/Sub Communication</a></b> - For high-speed broadcasting</li>
<li><b><a class="el" href="md_manual_tutorials_shm_service_en.html">ğŸ¤ Service Communication</a></b> - For request-response patterns</li>
<li><b><a class="el" href="md_manual_tutorials_python_en.html">ğŸ Python Integration</a></b> - Multi-language development</li>
</ul>
<hr  />
<p><b>ğŸ‰ Congratulations!</b> You've mastered advanced asynchronous communication! Your applications can now handle complex, long-running workflows with full monitoring and control! ğŸš€âœ¨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2025 14:47:59 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
