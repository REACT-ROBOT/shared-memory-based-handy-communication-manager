<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SHM: 🤝 Service Communication Complete Guide - Master Reliable Request-Response Communication</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SHM
   </div>
   <div id="projectbrief">Shared-memory based Handy-communication Manager</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">🤝 Service Communication Complete Guide - Master Reliable Request-Response Communication </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>[English | <a href="docs_jp/md_manual_tutorials_shm_service_jp.html">日本語</a>]</p>
<h1><a class="anchor" id="autotoc_md326"></a>
🎯 What You'll Learn in This Guide</h1>
<ul>
<li><b>Deep Understanding of Service Communication</b>: From design philosophy to implementation details of request-response patterns</li>
<li><b>Reliable Data Exchange</b>: Timeout handling, error management, and retry mechanisms</li>
<li><b>High-Performance Server Design</b>: Concurrent processing, load balancing, and memory efficiency</li>
<li><b>Practical Applications</b>: Database operations, computation services, and configuration management</li>
</ul>
<h1><a class="anchor" id="autotoc_md327"></a>
🧠 Deep Understanding of Service Communication</h1>
<h2><a class="anchor" id="autotoc_md328"></a>
🏗️ Architecture Overview</h2>
<div class="fragment"><div class="line"><span class="comment">// Service communication internal structure</span></div>
<div class="line">┌─────────────────────────────────────────────────────────────┐</div>
<div class="line">│                   Shared Memory Space                        │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              Request Queue                          │    │</div>
<div class="line">│  │ [Req 0][Req 1][Req 2]...[Req N-1]                 │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  Process Pos                 Add Pos                │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  ┌─────────────────────────────────────────────────────┐    │</div>
<div class="line">│  │              Response Queue                         │    │</div>
<div class="line">│  │ [Res 0][Res 1][Res 2]...[Res N-1]                 │    │</div>
<div class="line">│  │    ↑                           ↑                    │    │</div>
<div class="line">│  │  Read Pos                   Write Pos               │    │</div>
<div class="line">│  └─────────────────────────────────────────────────────┘    │</div>
<div class="line">│                                                             │</div>
<div class="line">│  Request-Response Mapping:                                  │</div>
<div class="line">│  - Request ID (unique identifier)                           │</div>
<div class="line">│  - Timestamp (timeout management)                           │</div>
<div class="line">│  - Process State (waiting/processing/completed)             │</div>
<div class="line">│  - Error Code (detailed failure information)                │</div>
<div class="line">└─────────────────────────────────────────────────────────────┘</div>
<div class="line"> </div>
<div class="line">Multiple Clients ← [shared memory] → Single Server</div>
<div class="line">      │                                        │</div>
<div class="line">   Send Request                        Processing Engine</div>
<div class="line">   Receive Response                           │</div>
<div class="line">      │                                   Parallel Processing</div>
<div class="line">   Timeout Management                     Result Generation</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md329"></a>
⚡ Why is it Reliable and Fast?</h2>
<p><b>1. Both Synchronous and Asynchronous Support</b> </p><div class="fragment"><div class="line"><span class="comment">// Synchronous communication (simple)</span></div>
<div class="line">ServiceClient&lt;int, int&gt; client(<span class="stringliteral">&quot;calc_service&quot;</span>);</div>
<div class="line">client.sendRequest(42);</div>
<div class="line"><span class="keywordflow">if</span> (client.waitForResponse(5000000)) {  <span class="comment">// 5 second timeout</span></div>
<div class="line">    <span class="keywordtype">int</span> result = client.getResponse();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Asynchronous communication (high performance)</span></div>
<div class="line">client.sendRequestAsync(42);</div>
<div class="line"><span class="comment">// Execute other processing...</span></div>
<div class="line"><span class="keywordflow">if</span> (client.checkResponse()) {</div>
<div class="line">    <span class="keywordtype">int</span> result = client.getResponse();</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>2. Reliable Request-Response Mapping</b> </p><div class="fragment"><div class="line"><span class="comment">// Internal request management</span></div>
<div class="line"><span class="keyword">struct </span>RequestHeader {</div>
<div class="line">    uint64_t request_id;        <span class="comment">// Unique request ID</span></div>
<div class="line">    uint64_t timestamp_us;      <span class="comment">// Send timestamp</span></div>
<div class="line">    uint32_t timeout_ms;        <span class="comment">// Timeout duration</span></div>
<div class="line">    uint32_t retry_count;       <span class="comment">// Retry count</span></div>
<div class="line">    uint32_t priority;          <span class="comment">// Priority</span></div>
<div class="line">    RequestStatus status;       <span class="comment">// Processing status</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reliable request-response pairing</span></div>
<div class="line"><span class="keyword">class </span>RequestTracker {</div>
<div class="line">    std::unordered_map&lt;uint64_t, RequestInfo&gt; pending_requests_;</div>
<div class="line">    std::mutex requests_mutex_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    uint64_t addRequest(<span class="keyword">const</span> RequestInfo&amp; info) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        uint64_t <span class="keywordtype">id</span> = generateUniqueId();</div>
<div class="line">        pending_requests_[id] = info;</div>
<div class="line">        <span class="keywordflow">return</span> id;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> checkResponse(uint64_t request_id, ResponseInfo&amp; response) {</div>
<div class="line">        std::lock_guard&lt;std::mutex&gt; lock(requests_mutex_);</div>
<div class="line">        <span class="keyword">auto</span> it = pending_requests_.find(request_id);</div>
<div class="line">        <span class="keywordflow">if</span> (it != pending_requests_.end() &amp;&amp; it-&gt;second.status == COMPLETED) {</div>
<div class="line">            response = it-&gt;second.response;</div>
<div class="line">            pending_requests_.erase(it);</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md330"></a>
🚀 Basic Usage Examples</h1>
<h2><a class="anchor" id="autotoc_md331"></a>
1. Simple Calculator Service</h2>
<p><b>Server Side:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__service_8hpp.html">shm_service.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <span class="comment">// Create calculation service server</span></div>
<div class="line">    ServiceServer&lt;int, int&gt; calc_server(<span class="stringliteral">&quot;calculator&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;🖥️ Calculator service started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">        <span class="keywordflow">if</span> (calc_server.hasRequest()) {</div>
<div class="line">            <span class="keywordtype">int</span> input = calc_server.getRequest();</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Processing request: &quot;</span> &lt;&lt; input &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Perform calculation (square)</span></div>
<div class="line">            <span class="keywordtype">int</span> result = input * input;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Send response</span></div>
<div class="line">            calc_server.sendResponse(result);</div>
<div class="line">            </div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Sent result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
<div class="ttc" id="ashm__service_8hpp_html"><div class="ttname"><a href="shm__service_8hpp.html">shm_service.hpp</a></div><div class="ttdoc">メモリの格納方法を規定するクラスの定義</div></div>
</div><!-- fragment --><p><b>Client Side:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="shm__service_8hpp.html">shm_service.hpp</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;thread&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span>irlab::shm;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    ServiceClient&lt;int, int&gt; calc_client(<span class="stringliteral">&quot;calculator&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;🔢 Calculator client started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt;= 10; ++i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Sending request: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        calc_client.sendRequest(i);</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Wait for response (5 second timeout)</span></div>
<div class="line">        <span class="keywordflow">if</span> (calc_client.waitForResponse(5000000)) {</div>
<div class="line">            <span class="keywordtype">int</span> result = calc_client.getResponse();</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;✅ &quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;² = &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;❌ Timeout for request: &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(500));</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md332"></a>
2. String Processing Service</h2>
<div class="fragment"><div class="line"><span class="comment">// Custom data structures</span></div>
<div class="line"><span class="keyword">struct </span>StringRequest {</div>
<div class="line">    <span class="keywordtype">char</span> text[256];</div>
<div class="line">    <span class="keywordtype">int</span> operation;  <span class="comment">// 0: uppercase, 1: lowercase, 2: reverse</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>StringResponse {</div>
<div class="line">    <span class="keywordtype">char</span> result[256];</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">int</span> error_code;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Server implementation</span></div>
<div class="line"><span class="keyword">class </span>StringProcessorServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceServer&lt;StringRequest, StringResponse&gt; server_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    StringProcessorServer() : server_(<span class="stringliteral">&quot;string_processor&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;📝 String Processor Service started!&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasRequest()) {</div>
<div class="line">                StringRequest req = server_.getRequest();</div>
<div class="line">                StringResponse resp = processString(req);</div>
<div class="line">                server_.sendResponse(resp);</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    StringResponse processString(<span class="keyword">const</span> StringRequest&amp; req) {</div>
<div class="line">        StringResponse resp;</div>
<div class="line">        resp.success = <span class="keyword">true</span>;</div>
<div class="line">        resp.error_code = 0;</div>
<div class="line">        </div>
<div class="line">        std::string text(req.text);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="keywordflow">switch</span> (req.operation) {</div>
<div class="line">                <span class="keywordflow">case</span> 0: <span class="comment">// uppercase</span></div>
<div class="line">                    std::transform(text.begin(), text.end(), text.begin(), ::toupper);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> 1: <span class="comment">// lowercase</span></div>
<div class="line">                    std::transform(text.begin(), text.end(), text.begin(), ::tolower);</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> 2: <span class="comment">// reverse</span></div>
<div class="line">                    std::reverse(text.begin(), text.end());</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    resp.success = <span class="keyword">false</span>;</div>
<div class="line">                    resp.error_code = 1; <span class="comment">// Invalid operation</span></div>
<div class="line">                    strcpy(resp.result, <span class="stringliteral">&quot;Invalid operation&quot;</span>);</div>
<div class="line">                    <span class="keywordflow">return</span> resp;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            strcpy(resp.result, text.c_str());</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            resp.success = <span class="keyword">false</span>;</div>
<div class="line">            resp.error_code = 2; <span class="comment">// Processing error</span></div>
<div class="line">            strcpy(resp.result, e.what());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> resp;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Client usage</span></div>
<div class="line"><span class="keywordtype">void</span> useStringProcessor() {</div>
<div class="line">    ServiceClient&lt;StringRequest, StringResponse&gt; client(<span class="stringliteral">&quot;string_processor&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    StringRequest req;</div>
<div class="line">    strcpy(req.text, <span class="stringliteral">&quot;Hello World&quot;</span>);</div>
<div class="line">    req.operation = 0; <span class="comment">// uppercase</span></div>
<div class="line">    </div>
<div class="line">    client.sendRequest(req);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">if</span> (client.waitForResponse(3000000)) { <span class="comment">// 3 second timeout</span></div>
<div class="line">        StringResponse resp = client.getResponse();</div>
<div class="line">        <span class="keywordflow">if</span> (resp.success) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Result: &quot;</span> &lt;&lt; resp.result &lt;&lt; std::endl; <span class="comment">// &quot;HELLO WORLD&quot;</span></div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Error: &quot;</span> &lt;&lt; resp.result &lt;&lt; <span class="stringliteral">&quot; (code: &quot;</span> &lt;&lt; resp.error_code &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md333"></a>
🔧 Advanced Features and Error Handling</h1>
<h2><a class="anchor" id="autotoc_md334"></a>
3. Robust Service with Timeout and Retry</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>RobustServiceClient {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceClient&lt;int, int&gt; client_;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> MAX_RETRIES = 3;</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> TIMEOUT_US = 2000000; <span class="comment">// 2 seconds</span></div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    RobustServiceClient(<span class="keyword">const</span> std::string&amp; service_name) : client_(service_name) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">bool</span> callService(<span class="keywordtype">int</span> input, <span class="keywordtype">int</span>&amp; output) {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> retry = 0; retry &lt; MAX_RETRIES; ++retry) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Attempt &quot;</span> &lt;&lt; (retry + 1) &lt;&lt; <span class="stringliteral">&quot;/&quot;</span> &lt;&lt; MAX_RETRIES &lt;&lt; std::endl;</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Send request</span></div>
<div class="line">            client_.sendRequest(input);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Wait for response with timeout</span></div>
<div class="line">            <span class="keywordflow">if</span> (client_.waitForResponse(TIMEOUT_US)) {</div>
<div class="line">                output = client_.getResponse();</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;✅ Service call successful&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">                <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;⏰ Timeout on attempt &quot;</span> &lt;&lt; (retry + 1) &lt;&lt; std::endl;</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Wait before retry</span></div>
<div class="line">                <span class="keywordflow">if</span> (retry &lt; MAX_RETRIES - 1) {</div>
<div class="line">                    std::this_thread::sleep_for(std::chrono::milliseconds(100));</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;❌ Service call failed after &quot;</span> &lt;&lt; MAX_RETRIES &lt;&lt; <span class="stringliteral">&quot; attempts&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Usage</span></div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    RobustServiceClient client(<span class="stringliteral">&quot;robust_calc&quot;</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> result;</div>
<div class="line">    <span class="keywordflow">if</span> (client.callService(42, result)) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Final result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Service unavailable&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md335"></a>
4. High-Performance Concurrent Server</h2>
<div class="fragment"><div class="line"><span class="keyword">class </span>ConcurrentCalculatorServer {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceServer&lt;int, int&gt; server_;</div>
<div class="line">    std::atomic&lt;bool&gt; running_;</div>
<div class="line">    std::vector&lt;std::thread&gt; worker_threads_;</div>
<div class="line">    std::queue&lt;std::pair&lt;int, std::promise&lt;int&gt;&gt;&gt; task_queue_;</div>
<div class="line">    std::mutex queue_mutex_;</div>
<div class="line">    std::condition_variable queue_cv_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ConcurrentCalculatorServer(<span class="keywordtype">int</span> num_workers = 4) </div>
<div class="line">        : server_(<span class="stringliteral">&quot;concurrent_calc&quot;</span>), running_(true) {</div>
<div class="line">        </div>
<div class="line">        <span class="comment">// Start worker threads</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_workers; ++i) {</div>
<div class="line">            worker_threads_.emplace_back([<span class="keyword">this</span>, i]() {</div>
<div class="line">                workerLoop(i);</div>
<div class="line">            });</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;🚀 Concurrent server started with &quot;</span> &lt;&lt; num_workers &lt;&lt; <span class="stringliteral">&quot; workers&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    ~ConcurrentCalculatorServer() {</div>
<div class="line">        running_ = <span class="keyword">false</span>;</div>
<div class="line">        queue_cv_.notify_all();</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; thread : worker_threads_) {</div>
<div class="line">            <span class="keywordflow">if</span> (thread.joinable()) {</div>
<div class="line">                thread.join();</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasRequest()) {</div>
<div class="line">                <span class="keywordtype">int</span> request = server_.getRequest();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Create a promise for the result</span></div>
<div class="line">                std::promise&lt;int&gt; result_promise;</div>
<div class="line">                <span class="keyword">auto</span> result_future = result_promise.get_future();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Add task to queue</span></div>
<div class="line">                {</div>
<div class="line">                    std::lock_guard&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">                    task_queue_.emplace(request, std::move(result_promise));</div>
<div class="line">                }</div>
<div class="line">                queue_cv_.notify_one();</div>
<div class="line">                </div>
<div class="line">                <span class="comment">// Wait for result and send response</span></div>
<div class="line">                <span class="keywordtype">int</span> result = result_future.get();</div>
<div class="line">                server_.sendResponse(result);</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> workerLoop(<span class="keywordtype">int</span> worker_id) {</div>
<div class="line">        <span class="keywordflow">while</span> (running_) {</div>
<div class="line">            std::unique_lock&lt;std::mutex&gt; lock(queue_mutex_);</div>
<div class="line">            queue_cv_.wait(lock, [<span class="keyword">this</span>]() { <span class="keywordflow">return</span> !task_queue_.empty() || !running_; });</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (!running_) <span class="keywordflow">break</span>;</div>
<div class="line">            </div>
<div class="line">            <span class="keyword">auto</span> task = std::move(task_queue_.front());</div>
<div class="line">            task_queue_.pop();</div>
<div class="line">            lock.unlock();</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Process the task (expensive computation)</span></div>
<div class="line">            <span class="keywordtype">int</span> input = task.first;</div>
<div class="line">            <span class="keywordtype">int</span> result = performComplexCalculation(input, worker_id);</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Set the result</span></div>
<div class="line">            task.second.set_value(result);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">int</span> performComplexCalculation(<span class="keywordtype">int</span> input, <span class="keywordtype">int</span> worker_id) {</div>
<div class="line">        <span class="comment">// Simulate complex computation</span></div>
<div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Worker &quot;</span> &lt;&lt; worker_id &lt;&lt; <span class="stringliteral">&quot; processed: &quot;</span> &lt;&lt; input &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">return</span> input * input + input; <span class="comment">// Simple formula</span></div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md336"></a>
📊 Performance Measurement and Optimization</h1>
<h2><a class="anchor" id="autotoc_md337"></a>
5. Latency Benchmarking</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;chrono&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ServiceBenchmark {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceClient&lt;int, int&gt; client_;</div>
<div class="line">    std::vector&lt;double&gt; latencies_;</div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ServiceBenchmark(<span class="keyword">const</span> std::string&amp; service_name) : client_(service_name) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> runBenchmark(<span class="keywordtype">int</span> num_requests = 1000) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;🏁 Starting benchmark with &quot;</span> &lt;&lt; num_requests &lt;&lt; <span class="stringliteral">&quot; requests...&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        </div>
<div class="line">        latencies_.clear();</div>
<div class="line">        latencies_.reserve(num_requests);</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; num_requests; ++i) {</div>
<div class="line">            <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::now();</div>
<div class="line">            </div>
<div class="line">            client_.sendRequest(i);</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">if</span> (client_.waitForResponse(1000000)) { <span class="comment">// 1 second timeout</span></div>
<div class="line">                <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::now();</div>
<div class="line">                <span class="keyword">auto</span> duration = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(end - start);</div>
<div class="line">                latencies_.push_back(duration.count());</div>
<div class="line">                client_.getResponse(); <span class="comment">// Consume response</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">                std::cout &lt;&lt; <span class="stringliteral">&quot;❌ Timeout on request &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</div>
<div class="line">            }</div>
<div class="line">            </div>
<div class="line">            <span class="comment">// Small delay to avoid overwhelming</span></div>
<div class="line">            std::this_thread::sleep_for(std::chrono::microseconds(100));</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        printStatistics();</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    <span class="keywordtype">void</span> printStatistics() {</div>
<div class="line">        <span class="keywordflow">if</span> (latencies_.empty()) {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;No successful requests&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        std::sort(latencies_.begin(), latencies_.end());</div>
<div class="line">        </div>
<div class="line">        <span class="keywordtype">double</span> avg = std::accumulate(latencies_.begin(), latencies_.end(), 0.0) / latencies_.size();</div>
<div class="line">        <span class="keywordtype">double</span> median = latencies_[latencies_.size() / 2];</div>
<div class="line">        <span class="keywordtype">double</span> min_latency = latencies_.front();</div>
<div class="line">        <span class="keywordtype">double</span> max_latency = latencies_.back();</div>
<div class="line">        <span class="keywordtype">double</span> p95 = latencies_[<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(latencies_.size() * 0.95)];</div>
<div class="line">        <span class="keywordtype">double</span> p99 = latencies_[<span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(latencies_.size() * 0.99)];</div>
<div class="line">        </div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n📊 Benchmark Results:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Successful requests: &quot;</span> &lt;&lt; latencies_.size() &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Average latency: &quot;</span> &lt;&lt; avg &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Median latency: &quot;</span> &lt;&lt; median &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Min latency: &quot;</span> &lt;&lt; min_latency &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Max latency: &quot;</span> &lt;&lt; max_latency &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;95th percentile: &quot;</span> &lt;&lt; p95 &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;99th percentile: &quot;</span> &lt;&lt; p99 &lt;&lt; <span class="stringliteral">&quot; μs&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Throughput: &quot;</span> &lt;&lt; (1000000.0 / avg) &lt;&lt; <span class="stringliteral">&quot; requests/second&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md338"></a>
🛠️ Real-World Applications</h1>
<h2><a class="anchor" id="autotoc_md339"></a>
6. Database Service Proxy</h2>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DatabaseQuery {</div>
<div class="line">    <span class="keywordtype">char</span> sql[512];</div>
<div class="line">    <span class="keywordtype">int</span> query_type; <span class="comment">// 0: SELECT, 1: INSERT, 2: UPDATE, 3: DELETE</span></div>
<div class="line">    <span class="keywordtype">int</span> timeout_ms;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>DatabaseResult {</div>
<div class="line">    <span class="keywordtype">char</span> data[1024];</div>
<div class="line">    <span class="keywordtype">int</span> row_count;</div>
<div class="line">    <span class="keywordtype">bool</span> success;</div>
<div class="line">    <span class="keywordtype">int</span> error_code;</div>
<div class="line">    <span class="keywordtype">char</span> error_message[256];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DatabaseServiceProxy {</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    ServiceServer&lt;DatabaseQuery, DatabaseResult&gt; server_;</div>
<div class="line">    <span class="comment">// Assume some database connection</span></div>
<div class="line">    </div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    DatabaseServiceProxy() : server_(<span class="stringliteral">&quot;database_service&quot;</span>) {}</div>
<div class="line">    </div>
<div class="line">    <span class="keywordtype">void</span> run() {</div>
<div class="line">        <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">            <span class="keywordflow">if</span> (server_.hasRequest()) {</div>
<div class="line">                DatabaseQuery query = server_.getRequest();</div>
<div class="line">                DatabaseResult result = executeQuery(query);</div>
<div class="line">                server_.sendResponse(result);</div>
<div class="line">            }</div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(1));</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    DatabaseResult executeQuery(<span class="keyword">const</span> DatabaseQuery&amp; query) {</div>
<div class="line">        DatabaseResult result;</div>
<div class="line">        result.success = <span class="keyword">true</span>;</div>
<div class="line">        result.error_code = 0;</div>
<div class="line">        result.row_count = 0;</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">            <span class="comment">// Simulate database operation</span></div>
<div class="line">            std::this_thread::sleep_for(std::chrono::milliseconds(query.timeout_ms / 10));</div>
<div class="line">            </div>
<div class="line">            <span class="keywordflow">switch</span> (query.query_type) {</div>
<div class="line">                <span class="keywordflow">case</span> 0: <span class="comment">// SELECT</span></div>
<div class="line">                    strcpy(result.data, <span class="stringliteral">&quot;[{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;test\&quot;}]&quot;</span>);</div>
<div class="line">                    result.row_count = 1;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">case</span> 1: <span class="comment">// INSERT</span></div>
<div class="line">                    strcpy(result.data, <span class="stringliteral">&quot;INSERT successful&quot;</span>);</div>
<div class="line">                    result.row_count = 1;</div>
<div class="line">                    <span class="keywordflow">break</span>;</div>
<div class="line">                <span class="keywordflow">default</span>:</div>
<div class="line">                    strcpy(result.data, <span class="stringliteral">&quot;Operation completed&quot;</span>);</div>
<div class="line">                    result.row_count = 0;</div>
<div class="line">            }</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; e) {</div>
<div class="line">            result.success = <span class="keyword">false</span>;</div>
<div class="line">            result.error_code = 500;</div>
<div class="line">            strcpy(result.error_message, e.what());</div>
<div class="line">        }</div>
<div class="line">        </div>
<div class="line">        <span class="keywordflow">return</span> result;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md340"></a>
🎯 Best Practices and Guidelines</h1>
<h2><a class="anchor" id="autotoc_md341"></a>
Design Principles</h2>
<ol type="1">
<li><b>Keep Request/Response Data Small</b> <div class="fragment"><div class="line"><span class="comment">// ✅ Good - Small, focused data</span></div>
<div class="line"><span class="keyword">struct </span>CalculationRequest {</div>
<div class="line">    <span class="keywordtype">double</span> value;</div>
<div class="line">    <span class="keywordtype">int</span> operation;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ❌ Avoid - Large data structures</span></div>
<div class="line"><span class="keyword">struct </span>HugeRequest {</div>
<div class="line">    <span class="keywordtype">char</span> large_buffer[1024*1024]; <span class="comment">// 1MB - too large</span></div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li><b>Use Appropriate Timeouts</b> <div class="fragment"><div class="line"><span class="comment">// Different timeouts for different operations</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> QUICK_OPERATION_TIMEOUT = 100000;    <span class="comment">// 100ms</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> NORMAL_OPERATION_TIMEOUT = 1000000;  <span class="comment">// 1s</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> LONG_OPERATION_TIMEOUT = 10000000;   <span class="comment">// 10s</span></div>
</div><!-- fragment --></li>
<li><b>Implement Proper Error Handling</b> <div class="fragment"><div class="line"><span class="keyword">enum class</span> ServiceError {</div>
<div class="line">    SUCCESS = 0,</div>
<div class="line">    TIMEOUT = 1,</div>
<div class="line">    INVALID_REQUEST = 2,</div>
<div class="line">    PROCESSING_ERROR = 3,</div>
<div class="line">    SERVICE_UNAVAILABLE = 4</div>
<div class="line">};</div>
</div><!-- fragment --></li>
</ol>
<h2><a class="anchor" id="autotoc_md342"></a>
Performance Tips</h2>
<ol type="1">
<li><b>Minimize Memory Allocations</b></li>
<li><b>Use Async Pattern for High Throughput</b> <br  />
</li>
<li><b>Implement Connection Pooling for Multiple Services</b></li>
<li><b>Monitor Service Health and Performance</b></li>
</ol>
<h1><a class="anchor" id="autotoc_md343"></a>
🔍 Troubleshooting Common Issues</h1>
<h2><a class="anchor" id="autotoc_md344"></a>
Common Problems and Solutions</h2>
<ol type="1">
<li><b>Service Server Not Responding</b><ul>
<li>Check if server process is running</li>
<li>Verify service name matches exactly</li>
<li>Ensure shared memory permissions</li>
</ul>
</li>
<li><b>Client Timeout Issues</b><ul>
<li>Increase timeout value</li>
<li>Check server processing time</li>
<li>Implement retry mechanism</li>
</ul>
</li>
<li><b>Memory Issues</b><ul>
<li>Monitor shared memory usage</li>
<li>Implement proper cleanup</li>
<li>Use appropriate buffer sizes</li>
</ul>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md345"></a>
📚 Next Steps</h1>
<ul>
<li><b><a class="el" href="md_manual_tutorials_shm_action_en.html">⚡ Action Communication</a></b> - For long-running asynchronous tasks</li>
<li><b><a class="el" href="md_manual_tutorials_shm_pub_sub_en.html">🔄 Pub/Sub Communication</a></b> - For broadcast communication</li>
<li><b><a class="el" href="md_manual_tutorials_python_en.html">🐍 Python Integration</a></b> - Multi-language development</li>
</ul>
<hr  />
<p><b>🎉 Congratulations!</b> You've mastered reliable request-response communication! Your distributed applications now have rock-solid service communication! 🚀✨ </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jul 6 2025 00:08:41 for SHM by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
