# 📖 はじめに - 通信ライブラリの基礎知識
[[English](../md_manual_introduction_en.html) | 日本語]

## 🌟 Welcome to プロセス間通信の世界！

**Shared Memory Based Handy Communication Manager**は、プロセス間通信を手軽に実現するための包括的なライブラリ集です。このライブラリを使えば、複雑な通信処理を数行のコードで実現できます。

## 🤔 プロセス間通信って何？

### 身近な例で理解しよう

プロセス間通信とは、**異なるプログラム同士が情報をやり取りすること**です。

```
📱 スマートフォンの例
┌─────────────────┐    データ    ┌─────────────────┐
│   カメラアプリ   │ ────────────▶ │   写真編集アプリ │
│  (撮影データ)    │              │  (加工処理)      │
└─────────────────┘              └─────────────────┘

🏭 工場の例  
┌─────────────────┐   センサー値  ┌─────────────────┐
│  センサー監視    │ ────────────▶ │   制御システム   │
│  プログラム      │              │   プログラム      │
└─────────────────┘              └─────────────────┘
```

### なぜプロセス間通信が必要？

**🔹 分業による効率化**
- 各プログラムが専門的な処理に集中
- 開発・保守・テストが簡単

**🔹 安定性の向上**  
- 一つのプログラムがクラッシュしても他に影響しない
- 部分的な更新・再起動が可能

**🔹 スケーラビリティ**
- 処理能力に応じてプロセス数を調整
- 複数のコンピューターでの分散処理

## 🧠 このライブラリが解決する課題

### 従来の課題
```cpp
// ❌ 従来の方法: 複雑で危険
void* shared_mem = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
int* data = reinterpret_cast<int*>(shared_mem);  // 危険な型変換
pthread_mutex_lock(&mutex);                      // 手動排他制御
*data = 42;
pthread_mutex_unlock(&mutex);
munmap(shared_mem, size);                        // 手動メモリ管理
```

### 本ライブラリの解決策
```cpp
// ✅ 本ライブラリ: シンプルで安全
Publisher<int> pub("my_topic");
pub.publish(42);  // たったこれだけ！
```

## 🚀 3つの通信方式の特徴

**使用場面**: 同一PC内でのリアルタイム通信

| ライブラリ | 特徴 | 用途例 |
|------------|------|--------|
| **shm_pub_sub** | 📡 出版者/購読者モデル<br>⚡ マイクロ秒レベルの超低遅延 | ロボット制御、リアルタイム画像処理 |
| **shm_service** | 🤝 要求/応答モデル<br>🔒 送受信の確実性保証 | データベース操作、ファイル処理 |
| **shm_action** | ⚡ 非同期処理モデル<br>📊 進捗監視・キャンセル機能 | 長時間計算、ファイルダウンロード |

```cpp
// 例: ロボットのセンサーデータ配信
Publisher<SensorData> sensor_pub("robot_sensors");
sensor_pub.publish(sensor_reading);  // 超高速配信
```

## 🎯 どの通信方式を選ぶべき？

### 📊 通信方式選択フローチャート

```
あなたの用途は？
│
├─ 最高速度が必要（マイクロ秒）
│  └─ 📡 shm_pub_sub (Pub/Sub)
│
├─ 確実にデータを送受信したい
│  └─ 🤝 shm_service (Service)
│
└─ 時間のかかる処理を監視したい
   └─ ⚡ shm_action (Action)
```

### 🔍 詳細比較表

| 特徴 | shm_pub_sub | shm_service | shm_action |
|------|-------------|-------------|------------|
| **通信範囲** | 同一PC | 同一PC | 同一PC |
| **速度** | ⚡⚡⚡ 最速 | ⚡⚡ 高速 | ⚡⚡ 高速 |
| **信頼性** | 📦 ベストエフォート | 🔒 確実 | 🔒 確実 |
| **通信パターン** | 1:N (ブロードキャスト) | 1:1 (要求応答) | 1:1 (非同期) |
| **データサイズ** | 任意 | 任意 | 任意 |
| **設定の簡単さ** | 🟢 とても簡単 | 🟢 とても簡単 | 🟡 簡単 |

## 🛠️ 開発の歴史と設計思想

### 🏛️ ライブラリの系譜

このライブラリは、**尾崎功一教授**が研究室でのロボット開発のために作成したC言語ライブラリを基にしています。

**進化の過程**:
```
🕰️ 初期版 (C言語)
   ↓ 機能追加・改良
🔧 C++版 (オブジェクト指向化)
```

### 🎯 設計哲学

**1. 🎛️ シンプルAPI**
```cpp
// データ送信（パブリッシュ）の例
Publisher<int> pub("topic");
pub.publish(42);
```

**2. 🔒 安全性**
- 型安全なテンプレート設計
- 自動メモリ管理
- 例外による適切なエラーハンドリング

**3. 🚀 パフォーマンス**
- ゼロコピー設計（共有メモリ）
- 効率的なデータ構造（リングバッファ）
- 最小限のオーバーヘッド

**4. 🔧 拡張性と互換性**
- **ROS互換API**: ROSの概念をベースとした直感的な設計
- **カスタムデータ型**: 任意のC++構造体をサポート
- **Python バインディング**: C++とPythonで同一API
- **プラットフォーム対応**: Linux、Windows（WSL）対応
- **コンパイラ対応**: GCC、Clang、MSVC対応

## 🎓 API設計の特徴

### 名前空間による整理

```cpp
// 共有メモリ通信
namespace irlab::shm {
    Publisher<T>, Subscriber<T>         // Pub/Subモデル
    ServiceClient<T>, ServiceServer<T>  // Serviceモデル  
    ActionClient<T>, ActionServer<T>    // Actionモデル
}

// 共通のベース機能
namespace irlab::shm_base {
    // 共有メモリの基盤機能（メモリマップ、排他制御等）
}
```

### 一貫した設計パターン

**🔹 送信側**: データを送る側の命名パターン
- `Publisher` (データを出版)
- `ServiceClient` (サービスに要求)
- `ActionClient` (アクションを依頼)

**🔹 受信側**: データを受け取る側の命名パターン  
- `Subscriber` (データを購読)
- `ServiceServer` (サービスを提供)
- `ActionServer` (アクションを実行)

### 自動リソース管理

```cpp
{
    Publisher<int> pub("topic");  // ← 自動的にメモリ確保
    pub.publish(42);
    // ← スコープを抜けると自動的にリソース解放
}
// メモリリークなし！
```

## 🎁 参考にしたシステム

### 1. fuRom [1]
- 共有メモリによる低遅延通信の実現
- リングバッファの効率的な実装

### 2. ROS (Robot Operating System) [2]
- Pub/Sub、Service、Actionの通信パターン
- トピックベースの名前空間管理

### 3. 現代的なC++設計
- RAIIによるリソース管理
- テンプレートによる型安全性
- 例外による適切なエラーハンドリング

## 🚀 次のステップ

基本概念を理解できましたか？次は実際に手を動かしてみましょう！

### 🏃 今すぐ試したい方
- **[🚀 クイックスタートガイド](quickstart_jp.md)** - 5分で通信を体験

### 📚 じっくり学びたい方  
- **[📝 基本チュートリアル](tutorials_jp.md)** - 段階的に機能を学習

### 🔧 特定の機能を知りたい方
- **[🔄 Pub/Sub通信](tutorials_shm_pub_sub_jp.md)** - 高速ブロードキャスト
- **[🤝 Service通信](tutorials_shm_service_jp.md)** - 確実な要求応答
- **[⚡ Action通信](tutorials_shm_action_jp.md)** - 非同期処理管理

### 🐍 Python開発者の方
- **[🐍 Python基礎](tutorials_python_jp.md)** - PythonAPIの基本
- **[🔄 Python Pub/Sub](tutorials_shm_pub_sub_python_jp.md)** - Python版出版者/購読者

---

## 📚 参考文献

[1] 入江清. "ROS との相互運用性に配慮した共有メモリによる低遅延プロセス間通信フレームワーク." 第 35 回日本ロボット学会学術講演会予稿集, RSJ2017AC2B2-01 (2017).
    <https://furo.org/irie/papers/rsj2017_irie.pdf>

[2] Open Robotics, "ROS.org", <http://wiki.ros.org/ja/>

---

**準備はできましたか？** さあ、プロセス間通信をマスターしましょう！ 🚀✨